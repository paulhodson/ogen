// Code generated by ogen, DO NOT EDIT.

package api

import (
	"context"
	"net/http"
	"time"

	"github.com/go-faster/errors"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/codes"
	"go.opentelemetry.io/otel/metric"
	semconv "go.opentelemetry.io/otel/semconv/v1.26.0"
	"go.opentelemetry.io/otel/trace"

	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/middleware"
	"github.com/ogen-go/ogen/ogenerrors"
	"github.com/ogen-go/ogen/otelogen"
)

// handleConnectCoreV1DeleteNamespacedPodProxyRequest handles connectCoreV1DeleteNamespacedPodProxy operation.
//
// Connect DELETE requests to proxy of Pod.
//
// DELETE /api/v1/namespaces/{namespace}/pods/{name}/proxy
func (s *Server) handleConnectCoreV1DeleteNamespacedPodProxyRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("connectCoreV1DeleteNamespacedPodProxy"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/api/v1/namespaces/{namespace}/pods/{name}/proxy"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ConnectCoreV1DeleteNamespacedPodProxy",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ConnectCoreV1DeleteNamespacedPodProxy",
			ID:   "connectCoreV1DeleteNamespacedPodProxy",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ConnectCoreV1DeleteNamespacedPodProxy", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeConnectCoreV1DeleteNamespacedPodProxyParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ConnectCoreV1DeleteNamespacedPodProxyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ConnectCoreV1DeleteNamespacedPodProxy",
			OperationSummary: "",
			OperationID:      "connectCoreV1DeleteNamespacedPodProxy",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "path",
					In:   "query",
				}: params.Path,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ConnectCoreV1DeleteNamespacedPodProxyParams
			Response = ConnectCoreV1DeleteNamespacedPodProxyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackConnectCoreV1DeleteNamespacedPodProxyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ConnectCoreV1DeleteNamespacedPodProxy(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ConnectCoreV1DeleteNamespacedPodProxy(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeConnectCoreV1DeleteNamespacedPodProxyResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleConnectCoreV1DeleteNamespacedPodProxyWithPathRequest handles connectCoreV1DeleteNamespacedPodProxyWithPath operation.
//
// Connect DELETE requests to proxy of Pod.
//
// DELETE /api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}
func (s *Server) handleConnectCoreV1DeleteNamespacedPodProxyWithPathRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("connectCoreV1DeleteNamespacedPodProxyWithPath"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ConnectCoreV1DeleteNamespacedPodProxyWithPath",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ConnectCoreV1DeleteNamespacedPodProxyWithPath",
			ID:   "connectCoreV1DeleteNamespacedPodProxyWithPath",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ConnectCoreV1DeleteNamespacedPodProxyWithPath", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeConnectCoreV1DeleteNamespacedPodProxyWithPathParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ConnectCoreV1DeleteNamespacedPodProxyWithPathRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ConnectCoreV1DeleteNamespacedPodProxyWithPath",
			OperationSummary: "",
			OperationID:      "connectCoreV1DeleteNamespacedPodProxyWithPath",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "path",
					In:   "path",
				}: params.PathPath,
				{
					Name: "path",
					In:   "query",
				}: params.QueryPath,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ConnectCoreV1DeleteNamespacedPodProxyWithPathParams
			Response = ConnectCoreV1DeleteNamespacedPodProxyWithPathRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackConnectCoreV1DeleteNamespacedPodProxyWithPathParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ConnectCoreV1DeleteNamespacedPodProxyWithPath(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ConnectCoreV1DeleteNamespacedPodProxyWithPath(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeConnectCoreV1DeleteNamespacedPodProxyWithPathResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleConnectCoreV1DeleteNamespacedServiceProxyRequest handles connectCoreV1DeleteNamespacedServiceProxy operation.
//
// Connect DELETE requests to proxy of Service.
//
// DELETE /api/v1/namespaces/{namespace}/services/{name}/proxy
func (s *Server) handleConnectCoreV1DeleteNamespacedServiceProxyRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("connectCoreV1DeleteNamespacedServiceProxy"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/api/v1/namespaces/{namespace}/services/{name}/proxy"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ConnectCoreV1DeleteNamespacedServiceProxy",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ConnectCoreV1DeleteNamespacedServiceProxy",
			ID:   "connectCoreV1DeleteNamespacedServiceProxy",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ConnectCoreV1DeleteNamespacedServiceProxy", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeConnectCoreV1DeleteNamespacedServiceProxyParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ConnectCoreV1DeleteNamespacedServiceProxyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ConnectCoreV1DeleteNamespacedServiceProxy",
			OperationSummary: "",
			OperationID:      "connectCoreV1DeleteNamespacedServiceProxy",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "path",
					In:   "query",
				}: params.Path,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ConnectCoreV1DeleteNamespacedServiceProxyParams
			Response = ConnectCoreV1DeleteNamespacedServiceProxyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackConnectCoreV1DeleteNamespacedServiceProxyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ConnectCoreV1DeleteNamespacedServiceProxy(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ConnectCoreV1DeleteNamespacedServiceProxy(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeConnectCoreV1DeleteNamespacedServiceProxyResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleConnectCoreV1DeleteNamespacedServiceProxyWithPathRequest handles connectCoreV1DeleteNamespacedServiceProxyWithPath operation.
//
// Connect DELETE requests to proxy of Service.
//
// DELETE /api/v1/namespaces/{namespace}/services/{name}/proxy/{path}
func (s *Server) handleConnectCoreV1DeleteNamespacedServiceProxyWithPathRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("connectCoreV1DeleteNamespacedServiceProxyWithPath"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ConnectCoreV1DeleteNamespacedServiceProxyWithPath",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ConnectCoreV1DeleteNamespacedServiceProxyWithPath",
			ID:   "connectCoreV1DeleteNamespacedServiceProxyWithPath",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ConnectCoreV1DeleteNamespacedServiceProxyWithPath", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeConnectCoreV1DeleteNamespacedServiceProxyWithPathParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ConnectCoreV1DeleteNamespacedServiceProxyWithPathRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ConnectCoreV1DeleteNamespacedServiceProxyWithPath",
			OperationSummary: "",
			OperationID:      "connectCoreV1DeleteNamespacedServiceProxyWithPath",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "path",
					In:   "path",
				}: params.PathPath,
				{
					Name: "path",
					In:   "query",
				}: params.QueryPath,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ConnectCoreV1DeleteNamespacedServiceProxyWithPathParams
			Response = ConnectCoreV1DeleteNamespacedServiceProxyWithPathRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackConnectCoreV1DeleteNamespacedServiceProxyWithPathParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ConnectCoreV1DeleteNamespacedServiceProxyWithPath(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ConnectCoreV1DeleteNamespacedServiceProxyWithPath(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeConnectCoreV1DeleteNamespacedServiceProxyWithPathResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleConnectCoreV1DeleteNodeProxyRequest handles connectCoreV1DeleteNodeProxy operation.
//
// Connect DELETE requests to proxy of Node.
//
// DELETE /api/v1/nodes/{name}/proxy
func (s *Server) handleConnectCoreV1DeleteNodeProxyRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("connectCoreV1DeleteNodeProxy"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/api/v1/nodes/{name}/proxy"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ConnectCoreV1DeleteNodeProxy",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ConnectCoreV1DeleteNodeProxy",
			ID:   "connectCoreV1DeleteNodeProxy",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ConnectCoreV1DeleteNodeProxy", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeConnectCoreV1DeleteNodeProxyParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ConnectCoreV1DeleteNodeProxyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ConnectCoreV1DeleteNodeProxy",
			OperationSummary: "",
			OperationID:      "connectCoreV1DeleteNodeProxy",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "path",
					In:   "query",
				}: params.Path,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ConnectCoreV1DeleteNodeProxyParams
			Response = ConnectCoreV1DeleteNodeProxyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackConnectCoreV1DeleteNodeProxyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ConnectCoreV1DeleteNodeProxy(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ConnectCoreV1DeleteNodeProxy(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeConnectCoreV1DeleteNodeProxyResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleConnectCoreV1DeleteNodeProxyWithPathRequest handles connectCoreV1DeleteNodeProxyWithPath operation.
//
// Connect DELETE requests to proxy of Node.
//
// DELETE /api/v1/nodes/{name}/proxy/{path}
func (s *Server) handleConnectCoreV1DeleteNodeProxyWithPathRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("connectCoreV1DeleteNodeProxyWithPath"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/api/v1/nodes/{name}/proxy/{path}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ConnectCoreV1DeleteNodeProxyWithPath",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ConnectCoreV1DeleteNodeProxyWithPath",
			ID:   "connectCoreV1DeleteNodeProxyWithPath",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ConnectCoreV1DeleteNodeProxyWithPath", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeConnectCoreV1DeleteNodeProxyWithPathParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ConnectCoreV1DeleteNodeProxyWithPathRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ConnectCoreV1DeleteNodeProxyWithPath",
			OperationSummary: "",
			OperationID:      "connectCoreV1DeleteNodeProxyWithPath",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "path",
					In:   "path",
				}: params.PathPath,
				{
					Name: "path",
					In:   "query",
				}: params.QueryPath,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ConnectCoreV1DeleteNodeProxyWithPathParams
			Response = ConnectCoreV1DeleteNodeProxyWithPathRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackConnectCoreV1DeleteNodeProxyWithPathParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ConnectCoreV1DeleteNodeProxyWithPath(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ConnectCoreV1DeleteNodeProxyWithPath(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeConnectCoreV1DeleteNodeProxyWithPathResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleConnectCoreV1GetNamespacedPodAttachRequest handles connectCoreV1GetNamespacedPodAttach operation.
//
// Connect GET requests to attach of Pod.
//
// GET /api/v1/namespaces/{namespace}/pods/{name}/attach
func (s *Server) handleConnectCoreV1GetNamespacedPodAttachRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("connectCoreV1GetNamespacedPodAttach"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/v1/namespaces/{namespace}/pods/{name}/attach"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ConnectCoreV1GetNamespacedPodAttach",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ConnectCoreV1GetNamespacedPodAttach",
			ID:   "connectCoreV1GetNamespacedPodAttach",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ConnectCoreV1GetNamespacedPodAttach", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeConnectCoreV1GetNamespacedPodAttachParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ConnectCoreV1GetNamespacedPodAttachRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ConnectCoreV1GetNamespacedPodAttach",
			OperationSummary: "",
			OperationID:      "connectCoreV1GetNamespacedPodAttach",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "container",
					In:   "query",
				}: params.Container,
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "stderr",
					In:   "query",
				}: params.Stderr,
				{
					Name: "stdin",
					In:   "query",
				}: params.Stdin,
				{
					Name: "stdout",
					In:   "query",
				}: params.Stdout,
				{
					Name: "tty",
					In:   "query",
				}: params.Tty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ConnectCoreV1GetNamespacedPodAttachParams
			Response = ConnectCoreV1GetNamespacedPodAttachRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackConnectCoreV1GetNamespacedPodAttachParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ConnectCoreV1GetNamespacedPodAttach(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ConnectCoreV1GetNamespacedPodAttach(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeConnectCoreV1GetNamespacedPodAttachResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleConnectCoreV1GetNamespacedPodExecRequest handles connectCoreV1GetNamespacedPodExec operation.
//
// Connect GET requests to exec of Pod.
//
// GET /api/v1/namespaces/{namespace}/pods/{name}/exec
func (s *Server) handleConnectCoreV1GetNamespacedPodExecRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("connectCoreV1GetNamespacedPodExec"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/v1/namespaces/{namespace}/pods/{name}/exec"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ConnectCoreV1GetNamespacedPodExec",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ConnectCoreV1GetNamespacedPodExec",
			ID:   "connectCoreV1GetNamespacedPodExec",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ConnectCoreV1GetNamespacedPodExec", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeConnectCoreV1GetNamespacedPodExecParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ConnectCoreV1GetNamespacedPodExecRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ConnectCoreV1GetNamespacedPodExec",
			OperationSummary: "",
			OperationID:      "connectCoreV1GetNamespacedPodExec",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "command",
					In:   "query",
				}: params.Command,
				{
					Name: "container",
					In:   "query",
				}: params.Container,
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "stderr",
					In:   "query",
				}: params.Stderr,
				{
					Name: "stdin",
					In:   "query",
				}: params.Stdin,
				{
					Name: "stdout",
					In:   "query",
				}: params.Stdout,
				{
					Name: "tty",
					In:   "query",
				}: params.Tty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ConnectCoreV1GetNamespacedPodExecParams
			Response = ConnectCoreV1GetNamespacedPodExecRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackConnectCoreV1GetNamespacedPodExecParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ConnectCoreV1GetNamespacedPodExec(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ConnectCoreV1GetNamespacedPodExec(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeConnectCoreV1GetNamespacedPodExecResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleConnectCoreV1GetNamespacedPodPortforwardRequest handles connectCoreV1GetNamespacedPodPortforward operation.
//
// Connect GET requests to portforward of Pod.
//
// GET /api/v1/namespaces/{namespace}/pods/{name}/portforward
func (s *Server) handleConnectCoreV1GetNamespacedPodPortforwardRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("connectCoreV1GetNamespacedPodPortforward"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/v1/namespaces/{namespace}/pods/{name}/portforward"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ConnectCoreV1GetNamespacedPodPortforward",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ConnectCoreV1GetNamespacedPodPortforward",
			ID:   "connectCoreV1GetNamespacedPodPortforward",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ConnectCoreV1GetNamespacedPodPortforward", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeConnectCoreV1GetNamespacedPodPortforwardParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ConnectCoreV1GetNamespacedPodPortforwardRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ConnectCoreV1GetNamespacedPodPortforward",
			OperationSummary: "",
			OperationID:      "connectCoreV1GetNamespacedPodPortforward",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "ports",
					In:   "query",
				}: params.Ports,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ConnectCoreV1GetNamespacedPodPortforwardParams
			Response = ConnectCoreV1GetNamespacedPodPortforwardRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackConnectCoreV1GetNamespacedPodPortforwardParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ConnectCoreV1GetNamespacedPodPortforward(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ConnectCoreV1GetNamespacedPodPortforward(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeConnectCoreV1GetNamespacedPodPortforwardResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleConnectCoreV1GetNamespacedPodProxyRequest handles connectCoreV1GetNamespacedPodProxy operation.
//
// Connect GET requests to proxy of Pod.
//
// GET /api/v1/namespaces/{namespace}/pods/{name}/proxy
func (s *Server) handleConnectCoreV1GetNamespacedPodProxyRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("connectCoreV1GetNamespacedPodProxy"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/v1/namespaces/{namespace}/pods/{name}/proxy"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ConnectCoreV1GetNamespacedPodProxy",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ConnectCoreV1GetNamespacedPodProxy",
			ID:   "connectCoreV1GetNamespacedPodProxy",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ConnectCoreV1GetNamespacedPodProxy", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeConnectCoreV1GetNamespacedPodProxyParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ConnectCoreV1GetNamespacedPodProxyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ConnectCoreV1GetNamespacedPodProxy",
			OperationSummary: "",
			OperationID:      "connectCoreV1GetNamespacedPodProxy",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "path",
					In:   "query",
				}: params.Path,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ConnectCoreV1GetNamespacedPodProxyParams
			Response = ConnectCoreV1GetNamespacedPodProxyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackConnectCoreV1GetNamespacedPodProxyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ConnectCoreV1GetNamespacedPodProxy(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ConnectCoreV1GetNamespacedPodProxy(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeConnectCoreV1GetNamespacedPodProxyResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleConnectCoreV1GetNamespacedPodProxyWithPathRequest handles connectCoreV1GetNamespacedPodProxyWithPath operation.
//
// Connect GET requests to proxy of Pod.
//
// GET /api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}
func (s *Server) handleConnectCoreV1GetNamespacedPodProxyWithPathRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("connectCoreV1GetNamespacedPodProxyWithPath"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ConnectCoreV1GetNamespacedPodProxyWithPath",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ConnectCoreV1GetNamespacedPodProxyWithPath",
			ID:   "connectCoreV1GetNamespacedPodProxyWithPath",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ConnectCoreV1GetNamespacedPodProxyWithPath", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeConnectCoreV1GetNamespacedPodProxyWithPathParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ConnectCoreV1GetNamespacedPodProxyWithPathRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ConnectCoreV1GetNamespacedPodProxyWithPath",
			OperationSummary: "",
			OperationID:      "connectCoreV1GetNamespacedPodProxyWithPath",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "path",
					In:   "path",
				}: params.PathPath,
				{
					Name: "path",
					In:   "query",
				}: params.QueryPath,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ConnectCoreV1GetNamespacedPodProxyWithPathParams
			Response = ConnectCoreV1GetNamespacedPodProxyWithPathRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackConnectCoreV1GetNamespacedPodProxyWithPathParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ConnectCoreV1GetNamespacedPodProxyWithPath(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ConnectCoreV1GetNamespacedPodProxyWithPath(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeConnectCoreV1GetNamespacedPodProxyWithPathResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleConnectCoreV1GetNamespacedServiceProxyRequest handles connectCoreV1GetNamespacedServiceProxy operation.
//
// Connect GET requests to proxy of Service.
//
// GET /api/v1/namespaces/{namespace}/services/{name}/proxy
func (s *Server) handleConnectCoreV1GetNamespacedServiceProxyRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("connectCoreV1GetNamespacedServiceProxy"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/v1/namespaces/{namespace}/services/{name}/proxy"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ConnectCoreV1GetNamespacedServiceProxy",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ConnectCoreV1GetNamespacedServiceProxy",
			ID:   "connectCoreV1GetNamespacedServiceProxy",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ConnectCoreV1GetNamespacedServiceProxy", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeConnectCoreV1GetNamespacedServiceProxyParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ConnectCoreV1GetNamespacedServiceProxyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ConnectCoreV1GetNamespacedServiceProxy",
			OperationSummary: "",
			OperationID:      "connectCoreV1GetNamespacedServiceProxy",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "path",
					In:   "query",
				}: params.Path,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ConnectCoreV1GetNamespacedServiceProxyParams
			Response = ConnectCoreV1GetNamespacedServiceProxyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackConnectCoreV1GetNamespacedServiceProxyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ConnectCoreV1GetNamespacedServiceProxy(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ConnectCoreV1GetNamespacedServiceProxy(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeConnectCoreV1GetNamespacedServiceProxyResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleConnectCoreV1GetNamespacedServiceProxyWithPathRequest handles connectCoreV1GetNamespacedServiceProxyWithPath operation.
//
// Connect GET requests to proxy of Service.
//
// GET /api/v1/namespaces/{namespace}/services/{name}/proxy/{path}
func (s *Server) handleConnectCoreV1GetNamespacedServiceProxyWithPathRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("connectCoreV1GetNamespacedServiceProxyWithPath"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ConnectCoreV1GetNamespacedServiceProxyWithPath",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ConnectCoreV1GetNamespacedServiceProxyWithPath",
			ID:   "connectCoreV1GetNamespacedServiceProxyWithPath",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ConnectCoreV1GetNamespacedServiceProxyWithPath", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeConnectCoreV1GetNamespacedServiceProxyWithPathParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ConnectCoreV1GetNamespacedServiceProxyWithPathRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ConnectCoreV1GetNamespacedServiceProxyWithPath",
			OperationSummary: "",
			OperationID:      "connectCoreV1GetNamespacedServiceProxyWithPath",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "path",
					In:   "path",
				}: params.PathPath,
				{
					Name: "path",
					In:   "query",
				}: params.QueryPath,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ConnectCoreV1GetNamespacedServiceProxyWithPathParams
			Response = ConnectCoreV1GetNamespacedServiceProxyWithPathRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackConnectCoreV1GetNamespacedServiceProxyWithPathParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ConnectCoreV1GetNamespacedServiceProxyWithPath(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ConnectCoreV1GetNamespacedServiceProxyWithPath(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeConnectCoreV1GetNamespacedServiceProxyWithPathResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleConnectCoreV1GetNodeProxyRequest handles connectCoreV1GetNodeProxy operation.
//
// Connect GET requests to proxy of Node.
//
// GET /api/v1/nodes/{name}/proxy
func (s *Server) handleConnectCoreV1GetNodeProxyRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("connectCoreV1GetNodeProxy"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/v1/nodes/{name}/proxy"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ConnectCoreV1GetNodeProxy",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ConnectCoreV1GetNodeProxy",
			ID:   "connectCoreV1GetNodeProxy",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ConnectCoreV1GetNodeProxy", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeConnectCoreV1GetNodeProxyParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ConnectCoreV1GetNodeProxyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ConnectCoreV1GetNodeProxy",
			OperationSummary: "",
			OperationID:      "connectCoreV1GetNodeProxy",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "path",
					In:   "query",
				}: params.Path,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ConnectCoreV1GetNodeProxyParams
			Response = ConnectCoreV1GetNodeProxyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackConnectCoreV1GetNodeProxyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ConnectCoreV1GetNodeProxy(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ConnectCoreV1GetNodeProxy(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeConnectCoreV1GetNodeProxyResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleConnectCoreV1GetNodeProxyWithPathRequest handles connectCoreV1GetNodeProxyWithPath operation.
//
// Connect GET requests to proxy of Node.
//
// GET /api/v1/nodes/{name}/proxy/{path}
func (s *Server) handleConnectCoreV1GetNodeProxyWithPathRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("connectCoreV1GetNodeProxyWithPath"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/v1/nodes/{name}/proxy/{path}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ConnectCoreV1GetNodeProxyWithPath",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ConnectCoreV1GetNodeProxyWithPath",
			ID:   "connectCoreV1GetNodeProxyWithPath",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ConnectCoreV1GetNodeProxyWithPath", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeConnectCoreV1GetNodeProxyWithPathParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ConnectCoreV1GetNodeProxyWithPathRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ConnectCoreV1GetNodeProxyWithPath",
			OperationSummary: "",
			OperationID:      "connectCoreV1GetNodeProxyWithPath",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "path",
					In:   "path",
				}: params.PathPath,
				{
					Name: "path",
					In:   "query",
				}: params.QueryPath,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ConnectCoreV1GetNodeProxyWithPathParams
			Response = ConnectCoreV1GetNodeProxyWithPathRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackConnectCoreV1GetNodeProxyWithPathParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ConnectCoreV1GetNodeProxyWithPath(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ConnectCoreV1GetNodeProxyWithPath(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeConnectCoreV1GetNodeProxyWithPathResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleConnectCoreV1HeadNamespacedPodProxyRequest handles connectCoreV1HeadNamespacedPodProxy operation.
//
// Connect HEAD requests to proxy of Pod.
//
// HEAD /api/v1/namespaces/{namespace}/pods/{name}/proxy
func (s *Server) handleConnectCoreV1HeadNamespacedPodProxyRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("connectCoreV1HeadNamespacedPodProxy"),
		semconv.HTTPRequestMethodKey.String("HEAD"),
		semconv.HTTPRouteKey.String("/api/v1/namespaces/{namespace}/pods/{name}/proxy"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ConnectCoreV1HeadNamespacedPodProxy",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ConnectCoreV1HeadNamespacedPodProxy",
			ID:   "connectCoreV1HeadNamespacedPodProxy",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ConnectCoreV1HeadNamespacedPodProxy", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeConnectCoreV1HeadNamespacedPodProxyParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ConnectCoreV1HeadNamespacedPodProxyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ConnectCoreV1HeadNamespacedPodProxy",
			OperationSummary: "",
			OperationID:      "connectCoreV1HeadNamespacedPodProxy",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "path",
					In:   "query",
				}: params.Path,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ConnectCoreV1HeadNamespacedPodProxyParams
			Response = ConnectCoreV1HeadNamespacedPodProxyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackConnectCoreV1HeadNamespacedPodProxyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ConnectCoreV1HeadNamespacedPodProxy(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ConnectCoreV1HeadNamespacedPodProxy(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeConnectCoreV1HeadNamespacedPodProxyResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleConnectCoreV1HeadNamespacedPodProxyWithPathRequest handles connectCoreV1HeadNamespacedPodProxyWithPath operation.
//
// Connect HEAD requests to proxy of Pod.
//
// HEAD /api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}
func (s *Server) handleConnectCoreV1HeadNamespacedPodProxyWithPathRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("connectCoreV1HeadNamespacedPodProxyWithPath"),
		semconv.HTTPRequestMethodKey.String("HEAD"),
		semconv.HTTPRouteKey.String("/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ConnectCoreV1HeadNamespacedPodProxyWithPath",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ConnectCoreV1HeadNamespacedPodProxyWithPath",
			ID:   "connectCoreV1HeadNamespacedPodProxyWithPath",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ConnectCoreV1HeadNamespacedPodProxyWithPath", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeConnectCoreV1HeadNamespacedPodProxyWithPathParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ConnectCoreV1HeadNamespacedPodProxyWithPathRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ConnectCoreV1HeadNamespacedPodProxyWithPath",
			OperationSummary: "",
			OperationID:      "connectCoreV1HeadNamespacedPodProxyWithPath",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "path",
					In:   "path",
				}: params.PathPath,
				{
					Name: "path",
					In:   "query",
				}: params.QueryPath,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ConnectCoreV1HeadNamespacedPodProxyWithPathParams
			Response = ConnectCoreV1HeadNamespacedPodProxyWithPathRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackConnectCoreV1HeadNamespacedPodProxyWithPathParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ConnectCoreV1HeadNamespacedPodProxyWithPath(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ConnectCoreV1HeadNamespacedPodProxyWithPath(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeConnectCoreV1HeadNamespacedPodProxyWithPathResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleConnectCoreV1HeadNamespacedServiceProxyRequest handles connectCoreV1HeadNamespacedServiceProxy operation.
//
// Connect HEAD requests to proxy of Service.
//
// HEAD /api/v1/namespaces/{namespace}/services/{name}/proxy
func (s *Server) handleConnectCoreV1HeadNamespacedServiceProxyRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("connectCoreV1HeadNamespacedServiceProxy"),
		semconv.HTTPRequestMethodKey.String("HEAD"),
		semconv.HTTPRouteKey.String("/api/v1/namespaces/{namespace}/services/{name}/proxy"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ConnectCoreV1HeadNamespacedServiceProxy",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ConnectCoreV1HeadNamespacedServiceProxy",
			ID:   "connectCoreV1HeadNamespacedServiceProxy",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ConnectCoreV1HeadNamespacedServiceProxy", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeConnectCoreV1HeadNamespacedServiceProxyParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ConnectCoreV1HeadNamespacedServiceProxyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ConnectCoreV1HeadNamespacedServiceProxy",
			OperationSummary: "",
			OperationID:      "connectCoreV1HeadNamespacedServiceProxy",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "path",
					In:   "query",
				}: params.Path,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ConnectCoreV1HeadNamespacedServiceProxyParams
			Response = ConnectCoreV1HeadNamespacedServiceProxyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackConnectCoreV1HeadNamespacedServiceProxyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ConnectCoreV1HeadNamespacedServiceProxy(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ConnectCoreV1HeadNamespacedServiceProxy(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeConnectCoreV1HeadNamespacedServiceProxyResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleConnectCoreV1HeadNamespacedServiceProxyWithPathRequest handles connectCoreV1HeadNamespacedServiceProxyWithPath operation.
//
// Connect HEAD requests to proxy of Service.
//
// HEAD /api/v1/namespaces/{namespace}/services/{name}/proxy/{path}
func (s *Server) handleConnectCoreV1HeadNamespacedServiceProxyWithPathRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("connectCoreV1HeadNamespacedServiceProxyWithPath"),
		semconv.HTTPRequestMethodKey.String("HEAD"),
		semconv.HTTPRouteKey.String("/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ConnectCoreV1HeadNamespacedServiceProxyWithPath",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ConnectCoreV1HeadNamespacedServiceProxyWithPath",
			ID:   "connectCoreV1HeadNamespacedServiceProxyWithPath",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ConnectCoreV1HeadNamespacedServiceProxyWithPath", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeConnectCoreV1HeadNamespacedServiceProxyWithPathParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ConnectCoreV1HeadNamespacedServiceProxyWithPathRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ConnectCoreV1HeadNamespacedServiceProxyWithPath",
			OperationSummary: "",
			OperationID:      "connectCoreV1HeadNamespacedServiceProxyWithPath",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "path",
					In:   "path",
				}: params.PathPath,
				{
					Name: "path",
					In:   "query",
				}: params.QueryPath,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ConnectCoreV1HeadNamespacedServiceProxyWithPathParams
			Response = ConnectCoreV1HeadNamespacedServiceProxyWithPathRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackConnectCoreV1HeadNamespacedServiceProxyWithPathParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ConnectCoreV1HeadNamespacedServiceProxyWithPath(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ConnectCoreV1HeadNamespacedServiceProxyWithPath(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeConnectCoreV1HeadNamespacedServiceProxyWithPathResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleConnectCoreV1HeadNodeProxyRequest handles connectCoreV1HeadNodeProxy operation.
//
// Connect HEAD requests to proxy of Node.
//
// HEAD /api/v1/nodes/{name}/proxy
func (s *Server) handleConnectCoreV1HeadNodeProxyRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("connectCoreV1HeadNodeProxy"),
		semconv.HTTPRequestMethodKey.String("HEAD"),
		semconv.HTTPRouteKey.String("/api/v1/nodes/{name}/proxy"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ConnectCoreV1HeadNodeProxy",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ConnectCoreV1HeadNodeProxy",
			ID:   "connectCoreV1HeadNodeProxy",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ConnectCoreV1HeadNodeProxy", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeConnectCoreV1HeadNodeProxyParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ConnectCoreV1HeadNodeProxyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ConnectCoreV1HeadNodeProxy",
			OperationSummary: "",
			OperationID:      "connectCoreV1HeadNodeProxy",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "path",
					In:   "query",
				}: params.Path,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ConnectCoreV1HeadNodeProxyParams
			Response = ConnectCoreV1HeadNodeProxyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackConnectCoreV1HeadNodeProxyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ConnectCoreV1HeadNodeProxy(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ConnectCoreV1HeadNodeProxy(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeConnectCoreV1HeadNodeProxyResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleConnectCoreV1HeadNodeProxyWithPathRequest handles connectCoreV1HeadNodeProxyWithPath operation.
//
// Connect HEAD requests to proxy of Node.
//
// HEAD /api/v1/nodes/{name}/proxy/{path}
func (s *Server) handleConnectCoreV1HeadNodeProxyWithPathRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("connectCoreV1HeadNodeProxyWithPath"),
		semconv.HTTPRequestMethodKey.String("HEAD"),
		semconv.HTTPRouteKey.String("/api/v1/nodes/{name}/proxy/{path}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ConnectCoreV1HeadNodeProxyWithPath",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ConnectCoreV1HeadNodeProxyWithPath",
			ID:   "connectCoreV1HeadNodeProxyWithPath",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ConnectCoreV1HeadNodeProxyWithPath", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeConnectCoreV1HeadNodeProxyWithPathParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ConnectCoreV1HeadNodeProxyWithPathRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ConnectCoreV1HeadNodeProxyWithPath",
			OperationSummary: "",
			OperationID:      "connectCoreV1HeadNodeProxyWithPath",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "path",
					In:   "path",
				}: params.PathPath,
				{
					Name: "path",
					In:   "query",
				}: params.QueryPath,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ConnectCoreV1HeadNodeProxyWithPathParams
			Response = ConnectCoreV1HeadNodeProxyWithPathRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackConnectCoreV1HeadNodeProxyWithPathParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ConnectCoreV1HeadNodeProxyWithPath(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ConnectCoreV1HeadNodeProxyWithPath(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeConnectCoreV1HeadNodeProxyWithPathResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleConnectCoreV1OptionsNamespacedPodProxyRequest handles connectCoreV1OptionsNamespacedPodProxy operation.
//
// Connect OPTIONS requests to proxy of Pod.
//
// OPTIONS /api/v1/namespaces/{namespace}/pods/{name}/proxy
func (s *Server) handleConnectCoreV1OptionsNamespacedPodProxyRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("connectCoreV1OptionsNamespacedPodProxy"),
		semconv.HTTPRequestMethodKey.String("OPTIONS"),
		semconv.HTTPRouteKey.String("/api/v1/namespaces/{namespace}/pods/{name}/proxy"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ConnectCoreV1OptionsNamespacedPodProxy",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ConnectCoreV1OptionsNamespacedPodProxy",
			ID:   "connectCoreV1OptionsNamespacedPodProxy",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ConnectCoreV1OptionsNamespacedPodProxy", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeConnectCoreV1OptionsNamespacedPodProxyParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ConnectCoreV1OptionsNamespacedPodProxyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ConnectCoreV1OptionsNamespacedPodProxy",
			OperationSummary: "",
			OperationID:      "connectCoreV1OptionsNamespacedPodProxy",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "path",
					In:   "query",
				}: params.Path,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ConnectCoreV1OptionsNamespacedPodProxyParams
			Response = ConnectCoreV1OptionsNamespacedPodProxyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackConnectCoreV1OptionsNamespacedPodProxyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ConnectCoreV1OptionsNamespacedPodProxy(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ConnectCoreV1OptionsNamespacedPodProxy(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeConnectCoreV1OptionsNamespacedPodProxyResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleConnectCoreV1OptionsNamespacedPodProxyWithPathRequest handles connectCoreV1OptionsNamespacedPodProxyWithPath operation.
//
// Connect OPTIONS requests to proxy of Pod.
//
// OPTIONS /api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}
func (s *Server) handleConnectCoreV1OptionsNamespacedPodProxyWithPathRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("connectCoreV1OptionsNamespacedPodProxyWithPath"),
		semconv.HTTPRequestMethodKey.String("OPTIONS"),
		semconv.HTTPRouteKey.String("/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ConnectCoreV1OptionsNamespacedPodProxyWithPath",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ConnectCoreV1OptionsNamespacedPodProxyWithPath",
			ID:   "connectCoreV1OptionsNamespacedPodProxyWithPath",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ConnectCoreV1OptionsNamespacedPodProxyWithPath", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeConnectCoreV1OptionsNamespacedPodProxyWithPathParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ConnectCoreV1OptionsNamespacedPodProxyWithPathRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ConnectCoreV1OptionsNamespacedPodProxyWithPath",
			OperationSummary: "",
			OperationID:      "connectCoreV1OptionsNamespacedPodProxyWithPath",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "path",
					In:   "path",
				}: params.PathPath,
				{
					Name: "path",
					In:   "query",
				}: params.QueryPath,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ConnectCoreV1OptionsNamespacedPodProxyWithPathParams
			Response = ConnectCoreV1OptionsNamespacedPodProxyWithPathRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackConnectCoreV1OptionsNamespacedPodProxyWithPathParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ConnectCoreV1OptionsNamespacedPodProxyWithPath(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ConnectCoreV1OptionsNamespacedPodProxyWithPath(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeConnectCoreV1OptionsNamespacedPodProxyWithPathResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleConnectCoreV1OptionsNamespacedServiceProxyRequest handles connectCoreV1OptionsNamespacedServiceProxy operation.
//
// Connect OPTIONS requests to proxy of Service.
//
// OPTIONS /api/v1/namespaces/{namespace}/services/{name}/proxy
func (s *Server) handleConnectCoreV1OptionsNamespacedServiceProxyRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("connectCoreV1OptionsNamespacedServiceProxy"),
		semconv.HTTPRequestMethodKey.String("OPTIONS"),
		semconv.HTTPRouteKey.String("/api/v1/namespaces/{namespace}/services/{name}/proxy"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ConnectCoreV1OptionsNamespacedServiceProxy",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ConnectCoreV1OptionsNamespacedServiceProxy",
			ID:   "connectCoreV1OptionsNamespacedServiceProxy",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ConnectCoreV1OptionsNamespacedServiceProxy", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeConnectCoreV1OptionsNamespacedServiceProxyParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ConnectCoreV1OptionsNamespacedServiceProxyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ConnectCoreV1OptionsNamespacedServiceProxy",
			OperationSummary: "",
			OperationID:      "connectCoreV1OptionsNamespacedServiceProxy",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "path",
					In:   "query",
				}: params.Path,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ConnectCoreV1OptionsNamespacedServiceProxyParams
			Response = ConnectCoreV1OptionsNamespacedServiceProxyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackConnectCoreV1OptionsNamespacedServiceProxyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ConnectCoreV1OptionsNamespacedServiceProxy(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ConnectCoreV1OptionsNamespacedServiceProxy(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeConnectCoreV1OptionsNamespacedServiceProxyResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleConnectCoreV1OptionsNamespacedServiceProxyWithPathRequest handles connectCoreV1OptionsNamespacedServiceProxyWithPath operation.
//
// Connect OPTIONS requests to proxy of Service.
//
// OPTIONS /api/v1/namespaces/{namespace}/services/{name}/proxy/{path}
func (s *Server) handleConnectCoreV1OptionsNamespacedServiceProxyWithPathRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("connectCoreV1OptionsNamespacedServiceProxyWithPath"),
		semconv.HTTPRequestMethodKey.String("OPTIONS"),
		semconv.HTTPRouteKey.String("/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ConnectCoreV1OptionsNamespacedServiceProxyWithPath",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ConnectCoreV1OptionsNamespacedServiceProxyWithPath",
			ID:   "connectCoreV1OptionsNamespacedServiceProxyWithPath",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ConnectCoreV1OptionsNamespacedServiceProxyWithPath", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeConnectCoreV1OptionsNamespacedServiceProxyWithPathParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ConnectCoreV1OptionsNamespacedServiceProxyWithPathRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ConnectCoreV1OptionsNamespacedServiceProxyWithPath",
			OperationSummary: "",
			OperationID:      "connectCoreV1OptionsNamespacedServiceProxyWithPath",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "path",
					In:   "path",
				}: params.PathPath,
				{
					Name: "path",
					In:   "query",
				}: params.QueryPath,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ConnectCoreV1OptionsNamespacedServiceProxyWithPathParams
			Response = ConnectCoreV1OptionsNamespacedServiceProxyWithPathRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackConnectCoreV1OptionsNamespacedServiceProxyWithPathParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ConnectCoreV1OptionsNamespacedServiceProxyWithPath(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ConnectCoreV1OptionsNamespacedServiceProxyWithPath(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeConnectCoreV1OptionsNamespacedServiceProxyWithPathResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleConnectCoreV1OptionsNodeProxyRequest handles connectCoreV1OptionsNodeProxy operation.
//
// Connect OPTIONS requests to proxy of Node.
//
// OPTIONS /api/v1/nodes/{name}/proxy
func (s *Server) handleConnectCoreV1OptionsNodeProxyRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("connectCoreV1OptionsNodeProxy"),
		semconv.HTTPRequestMethodKey.String("OPTIONS"),
		semconv.HTTPRouteKey.String("/api/v1/nodes/{name}/proxy"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ConnectCoreV1OptionsNodeProxy",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ConnectCoreV1OptionsNodeProxy",
			ID:   "connectCoreV1OptionsNodeProxy",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ConnectCoreV1OptionsNodeProxy", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeConnectCoreV1OptionsNodeProxyParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ConnectCoreV1OptionsNodeProxyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ConnectCoreV1OptionsNodeProxy",
			OperationSummary: "",
			OperationID:      "connectCoreV1OptionsNodeProxy",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "path",
					In:   "query",
				}: params.Path,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ConnectCoreV1OptionsNodeProxyParams
			Response = ConnectCoreV1OptionsNodeProxyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackConnectCoreV1OptionsNodeProxyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ConnectCoreV1OptionsNodeProxy(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ConnectCoreV1OptionsNodeProxy(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeConnectCoreV1OptionsNodeProxyResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleConnectCoreV1OptionsNodeProxyWithPathRequest handles connectCoreV1OptionsNodeProxyWithPath operation.
//
// Connect OPTIONS requests to proxy of Node.
//
// OPTIONS /api/v1/nodes/{name}/proxy/{path}
func (s *Server) handleConnectCoreV1OptionsNodeProxyWithPathRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("connectCoreV1OptionsNodeProxyWithPath"),
		semconv.HTTPRequestMethodKey.String("OPTIONS"),
		semconv.HTTPRouteKey.String("/api/v1/nodes/{name}/proxy/{path}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ConnectCoreV1OptionsNodeProxyWithPath",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ConnectCoreV1OptionsNodeProxyWithPath",
			ID:   "connectCoreV1OptionsNodeProxyWithPath",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ConnectCoreV1OptionsNodeProxyWithPath", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeConnectCoreV1OptionsNodeProxyWithPathParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ConnectCoreV1OptionsNodeProxyWithPathRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ConnectCoreV1OptionsNodeProxyWithPath",
			OperationSummary: "",
			OperationID:      "connectCoreV1OptionsNodeProxyWithPath",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "path",
					In:   "path",
				}: params.PathPath,
				{
					Name: "path",
					In:   "query",
				}: params.QueryPath,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ConnectCoreV1OptionsNodeProxyWithPathParams
			Response = ConnectCoreV1OptionsNodeProxyWithPathRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackConnectCoreV1OptionsNodeProxyWithPathParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ConnectCoreV1OptionsNodeProxyWithPath(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ConnectCoreV1OptionsNodeProxyWithPath(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeConnectCoreV1OptionsNodeProxyWithPathResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleConnectCoreV1PatchNamespacedPodProxyRequest handles connectCoreV1PatchNamespacedPodProxy operation.
//
// Connect PATCH requests to proxy of Pod.
//
// PATCH /api/v1/namespaces/{namespace}/pods/{name}/proxy
func (s *Server) handleConnectCoreV1PatchNamespacedPodProxyRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("connectCoreV1PatchNamespacedPodProxy"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/api/v1/namespaces/{namespace}/pods/{name}/proxy"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ConnectCoreV1PatchNamespacedPodProxy",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ConnectCoreV1PatchNamespacedPodProxy",
			ID:   "connectCoreV1PatchNamespacedPodProxy",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ConnectCoreV1PatchNamespacedPodProxy", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeConnectCoreV1PatchNamespacedPodProxyParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ConnectCoreV1PatchNamespacedPodProxyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ConnectCoreV1PatchNamespacedPodProxy",
			OperationSummary: "",
			OperationID:      "connectCoreV1PatchNamespacedPodProxy",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "path",
					In:   "query",
				}: params.Path,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ConnectCoreV1PatchNamespacedPodProxyParams
			Response = ConnectCoreV1PatchNamespacedPodProxyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackConnectCoreV1PatchNamespacedPodProxyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ConnectCoreV1PatchNamespacedPodProxy(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ConnectCoreV1PatchNamespacedPodProxy(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeConnectCoreV1PatchNamespacedPodProxyResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleConnectCoreV1PatchNamespacedPodProxyWithPathRequest handles connectCoreV1PatchNamespacedPodProxyWithPath operation.
//
// Connect PATCH requests to proxy of Pod.
//
// PATCH /api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}
func (s *Server) handleConnectCoreV1PatchNamespacedPodProxyWithPathRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("connectCoreV1PatchNamespacedPodProxyWithPath"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ConnectCoreV1PatchNamespacedPodProxyWithPath",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ConnectCoreV1PatchNamespacedPodProxyWithPath",
			ID:   "connectCoreV1PatchNamespacedPodProxyWithPath",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ConnectCoreV1PatchNamespacedPodProxyWithPath", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeConnectCoreV1PatchNamespacedPodProxyWithPathParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ConnectCoreV1PatchNamespacedPodProxyWithPathRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ConnectCoreV1PatchNamespacedPodProxyWithPath",
			OperationSummary: "",
			OperationID:      "connectCoreV1PatchNamespacedPodProxyWithPath",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "path",
					In:   "path",
				}: params.PathPath,
				{
					Name: "path",
					In:   "query",
				}: params.QueryPath,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ConnectCoreV1PatchNamespacedPodProxyWithPathParams
			Response = ConnectCoreV1PatchNamespacedPodProxyWithPathRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackConnectCoreV1PatchNamespacedPodProxyWithPathParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ConnectCoreV1PatchNamespacedPodProxyWithPath(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ConnectCoreV1PatchNamespacedPodProxyWithPath(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeConnectCoreV1PatchNamespacedPodProxyWithPathResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleConnectCoreV1PatchNamespacedServiceProxyRequest handles connectCoreV1PatchNamespacedServiceProxy operation.
//
// Connect PATCH requests to proxy of Service.
//
// PATCH /api/v1/namespaces/{namespace}/services/{name}/proxy
func (s *Server) handleConnectCoreV1PatchNamespacedServiceProxyRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("connectCoreV1PatchNamespacedServiceProxy"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/api/v1/namespaces/{namespace}/services/{name}/proxy"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ConnectCoreV1PatchNamespacedServiceProxy",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ConnectCoreV1PatchNamespacedServiceProxy",
			ID:   "connectCoreV1PatchNamespacedServiceProxy",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ConnectCoreV1PatchNamespacedServiceProxy", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeConnectCoreV1PatchNamespacedServiceProxyParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ConnectCoreV1PatchNamespacedServiceProxyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ConnectCoreV1PatchNamespacedServiceProxy",
			OperationSummary: "",
			OperationID:      "connectCoreV1PatchNamespacedServiceProxy",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "path",
					In:   "query",
				}: params.Path,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ConnectCoreV1PatchNamespacedServiceProxyParams
			Response = ConnectCoreV1PatchNamespacedServiceProxyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackConnectCoreV1PatchNamespacedServiceProxyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ConnectCoreV1PatchNamespacedServiceProxy(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ConnectCoreV1PatchNamespacedServiceProxy(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeConnectCoreV1PatchNamespacedServiceProxyResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleConnectCoreV1PatchNamespacedServiceProxyWithPathRequest handles connectCoreV1PatchNamespacedServiceProxyWithPath operation.
//
// Connect PATCH requests to proxy of Service.
//
// PATCH /api/v1/namespaces/{namespace}/services/{name}/proxy/{path}
func (s *Server) handleConnectCoreV1PatchNamespacedServiceProxyWithPathRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("connectCoreV1PatchNamespacedServiceProxyWithPath"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ConnectCoreV1PatchNamespacedServiceProxyWithPath",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ConnectCoreV1PatchNamespacedServiceProxyWithPath",
			ID:   "connectCoreV1PatchNamespacedServiceProxyWithPath",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ConnectCoreV1PatchNamespacedServiceProxyWithPath", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeConnectCoreV1PatchNamespacedServiceProxyWithPathParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ConnectCoreV1PatchNamespacedServiceProxyWithPathRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ConnectCoreV1PatchNamespacedServiceProxyWithPath",
			OperationSummary: "",
			OperationID:      "connectCoreV1PatchNamespacedServiceProxyWithPath",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "path",
					In:   "path",
				}: params.PathPath,
				{
					Name: "path",
					In:   "query",
				}: params.QueryPath,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ConnectCoreV1PatchNamespacedServiceProxyWithPathParams
			Response = ConnectCoreV1PatchNamespacedServiceProxyWithPathRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackConnectCoreV1PatchNamespacedServiceProxyWithPathParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ConnectCoreV1PatchNamespacedServiceProxyWithPath(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ConnectCoreV1PatchNamespacedServiceProxyWithPath(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeConnectCoreV1PatchNamespacedServiceProxyWithPathResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleConnectCoreV1PatchNodeProxyRequest handles connectCoreV1PatchNodeProxy operation.
//
// Connect PATCH requests to proxy of Node.
//
// PATCH /api/v1/nodes/{name}/proxy
func (s *Server) handleConnectCoreV1PatchNodeProxyRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("connectCoreV1PatchNodeProxy"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/api/v1/nodes/{name}/proxy"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ConnectCoreV1PatchNodeProxy",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ConnectCoreV1PatchNodeProxy",
			ID:   "connectCoreV1PatchNodeProxy",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ConnectCoreV1PatchNodeProxy", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeConnectCoreV1PatchNodeProxyParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ConnectCoreV1PatchNodeProxyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ConnectCoreV1PatchNodeProxy",
			OperationSummary: "",
			OperationID:      "connectCoreV1PatchNodeProxy",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "path",
					In:   "query",
				}: params.Path,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ConnectCoreV1PatchNodeProxyParams
			Response = ConnectCoreV1PatchNodeProxyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackConnectCoreV1PatchNodeProxyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ConnectCoreV1PatchNodeProxy(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ConnectCoreV1PatchNodeProxy(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeConnectCoreV1PatchNodeProxyResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleConnectCoreV1PatchNodeProxyWithPathRequest handles connectCoreV1PatchNodeProxyWithPath operation.
//
// Connect PATCH requests to proxy of Node.
//
// PATCH /api/v1/nodes/{name}/proxy/{path}
func (s *Server) handleConnectCoreV1PatchNodeProxyWithPathRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("connectCoreV1PatchNodeProxyWithPath"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/api/v1/nodes/{name}/proxy/{path}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ConnectCoreV1PatchNodeProxyWithPath",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ConnectCoreV1PatchNodeProxyWithPath",
			ID:   "connectCoreV1PatchNodeProxyWithPath",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ConnectCoreV1PatchNodeProxyWithPath", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeConnectCoreV1PatchNodeProxyWithPathParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ConnectCoreV1PatchNodeProxyWithPathRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ConnectCoreV1PatchNodeProxyWithPath",
			OperationSummary: "",
			OperationID:      "connectCoreV1PatchNodeProxyWithPath",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "path",
					In:   "path",
				}: params.PathPath,
				{
					Name: "path",
					In:   "query",
				}: params.QueryPath,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ConnectCoreV1PatchNodeProxyWithPathParams
			Response = ConnectCoreV1PatchNodeProxyWithPathRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackConnectCoreV1PatchNodeProxyWithPathParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ConnectCoreV1PatchNodeProxyWithPath(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ConnectCoreV1PatchNodeProxyWithPath(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeConnectCoreV1PatchNodeProxyWithPathResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleConnectCoreV1PostNamespacedPodAttachRequest handles connectCoreV1PostNamespacedPodAttach operation.
//
// Connect POST requests to attach of Pod.
//
// POST /api/v1/namespaces/{namespace}/pods/{name}/attach
func (s *Server) handleConnectCoreV1PostNamespacedPodAttachRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("connectCoreV1PostNamespacedPodAttach"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/api/v1/namespaces/{namespace}/pods/{name}/attach"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ConnectCoreV1PostNamespacedPodAttach",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ConnectCoreV1PostNamespacedPodAttach",
			ID:   "connectCoreV1PostNamespacedPodAttach",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ConnectCoreV1PostNamespacedPodAttach", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeConnectCoreV1PostNamespacedPodAttachParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ConnectCoreV1PostNamespacedPodAttachRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ConnectCoreV1PostNamespacedPodAttach",
			OperationSummary: "",
			OperationID:      "connectCoreV1PostNamespacedPodAttach",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "container",
					In:   "query",
				}: params.Container,
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "stderr",
					In:   "query",
				}: params.Stderr,
				{
					Name: "stdin",
					In:   "query",
				}: params.Stdin,
				{
					Name: "stdout",
					In:   "query",
				}: params.Stdout,
				{
					Name: "tty",
					In:   "query",
				}: params.Tty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ConnectCoreV1PostNamespacedPodAttachParams
			Response = ConnectCoreV1PostNamespacedPodAttachRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackConnectCoreV1PostNamespacedPodAttachParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ConnectCoreV1PostNamespacedPodAttach(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ConnectCoreV1PostNamespacedPodAttach(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeConnectCoreV1PostNamespacedPodAttachResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleConnectCoreV1PostNamespacedPodExecRequest handles connectCoreV1PostNamespacedPodExec operation.
//
// Connect POST requests to exec of Pod.
//
// POST /api/v1/namespaces/{namespace}/pods/{name}/exec
func (s *Server) handleConnectCoreV1PostNamespacedPodExecRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("connectCoreV1PostNamespacedPodExec"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/api/v1/namespaces/{namespace}/pods/{name}/exec"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ConnectCoreV1PostNamespacedPodExec",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ConnectCoreV1PostNamespacedPodExec",
			ID:   "connectCoreV1PostNamespacedPodExec",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ConnectCoreV1PostNamespacedPodExec", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeConnectCoreV1PostNamespacedPodExecParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ConnectCoreV1PostNamespacedPodExecRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ConnectCoreV1PostNamespacedPodExec",
			OperationSummary: "",
			OperationID:      "connectCoreV1PostNamespacedPodExec",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "command",
					In:   "query",
				}: params.Command,
				{
					Name: "container",
					In:   "query",
				}: params.Container,
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "stderr",
					In:   "query",
				}: params.Stderr,
				{
					Name: "stdin",
					In:   "query",
				}: params.Stdin,
				{
					Name: "stdout",
					In:   "query",
				}: params.Stdout,
				{
					Name: "tty",
					In:   "query",
				}: params.Tty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ConnectCoreV1PostNamespacedPodExecParams
			Response = ConnectCoreV1PostNamespacedPodExecRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackConnectCoreV1PostNamespacedPodExecParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ConnectCoreV1PostNamespacedPodExec(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ConnectCoreV1PostNamespacedPodExec(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeConnectCoreV1PostNamespacedPodExecResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleConnectCoreV1PostNamespacedPodPortforwardRequest handles connectCoreV1PostNamespacedPodPortforward operation.
//
// Connect POST requests to portforward of Pod.
//
// POST /api/v1/namespaces/{namespace}/pods/{name}/portforward
func (s *Server) handleConnectCoreV1PostNamespacedPodPortforwardRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("connectCoreV1PostNamespacedPodPortforward"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/api/v1/namespaces/{namespace}/pods/{name}/portforward"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ConnectCoreV1PostNamespacedPodPortforward",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ConnectCoreV1PostNamespacedPodPortforward",
			ID:   "connectCoreV1PostNamespacedPodPortforward",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ConnectCoreV1PostNamespacedPodPortforward", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeConnectCoreV1PostNamespacedPodPortforwardParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ConnectCoreV1PostNamespacedPodPortforwardRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ConnectCoreV1PostNamespacedPodPortforward",
			OperationSummary: "",
			OperationID:      "connectCoreV1PostNamespacedPodPortforward",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "ports",
					In:   "query",
				}: params.Ports,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ConnectCoreV1PostNamespacedPodPortforwardParams
			Response = ConnectCoreV1PostNamespacedPodPortforwardRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackConnectCoreV1PostNamespacedPodPortforwardParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ConnectCoreV1PostNamespacedPodPortforward(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ConnectCoreV1PostNamespacedPodPortforward(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeConnectCoreV1PostNamespacedPodPortforwardResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleConnectCoreV1PostNamespacedPodProxyRequest handles connectCoreV1PostNamespacedPodProxy operation.
//
// Connect POST requests to proxy of Pod.
//
// POST /api/v1/namespaces/{namespace}/pods/{name}/proxy
func (s *Server) handleConnectCoreV1PostNamespacedPodProxyRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("connectCoreV1PostNamespacedPodProxy"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/api/v1/namespaces/{namespace}/pods/{name}/proxy"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ConnectCoreV1PostNamespacedPodProxy",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ConnectCoreV1PostNamespacedPodProxy",
			ID:   "connectCoreV1PostNamespacedPodProxy",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ConnectCoreV1PostNamespacedPodProxy", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeConnectCoreV1PostNamespacedPodProxyParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ConnectCoreV1PostNamespacedPodProxyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ConnectCoreV1PostNamespacedPodProxy",
			OperationSummary: "",
			OperationID:      "connectCoreV1PostNamespacedPodProxy",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "path",
					In:   "query",
				}: params.Path,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ConnectCoreV1PostNamespacedPodProxyParams
			Response = ConnectCoreV1PostNamespacedPodProxyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackConnectCoreV1PostNamespacedPodProxyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ConnectCoreV1PostNamespacedPodProxy(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ConnectCoreV1PostNamespacedPodProxy(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeConnectCoreV1PostNamespacedPodProxyResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleConnectCoreV1PostNamespacedPodProxyWithPathRequest handles connectCoreV1PostNamespacedPodProxyWithPath operation.
//
// Connect POST requests to proxy of Pod.
//
// POST /api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}
func (s *Server) handleConnectCoreV1PostNamespacedPodProxyWithPathRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("connectCoreV1PostNamespacedPodProxyWithPath"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ConnectCoreV1PostNamespacedPodProxyWithPath",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ConnectCoreV1PostNamespacedPodProxyWithPath",
			ID:   "connectCoreV1PostNamespacedPodProxyWithPath",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ConnectCoreV1PostNamespacedPodProxyWithPath", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeConnectCoreV1PostNamespacedPodProxyWithPathParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ConnectCoreV1PostNamespacedPodProxyWithPathRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ConnectCoreV1PostNamespacedPodProxyWithPath",
			OperationSummary: "",
			OperationID:      "connectCoreV1PostNamespacedPodProxyWithPath",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "path",
					In:   "path",
				}: params.PathPath,
				{
					Name: "path",
					In:   "query",
				}: params.QueryPath,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ConnectCoreV1PostNamespacedPodProxyWithPathParams
			Response = ConnectCoreV1PostNamespacedPodProxyWithPathRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackConnectCoreV1PostNamespacedPodProxyWithPathParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ConnectCoreV1PostNamespacedPodProxyWithPath(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ConnectCoreV1PostNamespacedPodProxyWithPath(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeConnectCoreV1PostNamespacedPodProxyWithPathResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleConnectCoreV1PostNamespacedServiceProxyRequest handles connectCoreV1PostNamespacedServiceProxy operation.
//
// Connect POST requests to proxy of Service.
//
// POST /api/v1/namespaces/{namespace}/services/{name}/proxy
func (s *Server) handleConnectCoreV1PostNamespacedServiceProxyRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("connectCoreV1PostNamespacedServiceProxy"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/api/v1/namespaces/{namespace}/services/{name}/proxy"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ConnectCoreV1PostNamespacedServiceProxy",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ConnectCoreV1PostNamespacedServiceProxy",
			ID:   "connectCoreV1PostNamespacedServiceProxy",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ConnectCoreV1PostNamespacedServiceProxy", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeConnectCoreV1PostNamespacedServiceProxyParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ConnectCoreV1PostNamespacedServiceProxyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ConnectCoreV1PostNamespacedServiceProxy",
			OperationSummary: "",
			OperationID:      "connectCoreV1PostNamespacedServiceProxy",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "path",
					In:   "query",
				}: params.Path,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ConnectCoreV1PostNamespacedServiceProxyParams
			Response = ConnectCoreV1PostNamespacedServiceProxyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackConnectCoreV1PostNamespacedServiceProxyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ConnectCoreV1PostNamespacedServiceProxy(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ConnectCoreV1PostNamespacedServiceProxy(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeConnectCoreV1PostNamespacedServiceProxyResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleConnectCoreV1PostNamespacedServiceProxyWithPathRequest handles connectCoreV1PostNamespacedServiceProxyWithPath operation.
//
// Connect POST requests to proxy of Service.
//
// POST /api/v1/namespaces/{namespace}/services/{name}/proxy/{path}
func (s *Server) handleConnectCoreV1PostNamespacedServiceProxyWithPathRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("connectCoreV1PostNamespacedServiceProxyWithPath"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ConnectCoreV1PostNamespacedServiceProxyWithPath",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ConnectCoreV1PostNamespacedServiceProxyWithPath",
			ID:   "connectCoreV1PostNamespacedServiceProxyWithPath",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ConnectCoreV1PostNamespacedServiceProxyWithPath", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeConnectCoreV1PostNamespacedServiceProxyWithPathParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ConnectCoreV1PostNamespacedServiceProxyWithPathRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ConnectCoreV1PostNamespacedServiceProxyWithPath",
			OperationSummary: "",
			OperationID:      "connectCoreV1PostNamespacedServiceProxyWithPath",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "path",
					In:   "path",
				}: params.PathPath,
				{
					Name: "path",
					In:   "query",
				}: params.QueryPath,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ConnectCoreV1PostNamespacedServiceProxyWithPathParams
			Response = ConnectCoreV1PostNamespacedServiceProxyWithPathRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackConnectCoreV1PostNamespacedServiceProxyWithPathParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ConnectCoreV1PostNamespacedServiceProxyWithPath(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ConnectCoreV1PostNamespacedServiceProxyWithPath(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeConnectCoreV1PostNamespacedServiceProxyWithPathResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleConnectCoreV1PostNodeProxyRequest handles connectCoreV1PostNodeProxy operation.
//
// Connect POST requests to proxy of Node.
//
// POST /api/v1/nodes/{name}/proxy
func (s *Server) handleConnectCoreV1PostNodeProxyRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("connectCoreV1PostNodeProxy"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/api/v1/nodes/{name}/proxy"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ConnectCoreV1PostNodeProxy",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ConnectCoreV1PostNodeProxy",
			ID:   "connectCoreV1PostNodeProxy",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ConnectCoreV1PostNodeProxy", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeConnectCoreV1PostNodeProxyParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ConnectCoreV1PostNodeProxyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ConnectCoreV1PostNodeProxy",
			OperationSummary: "",
			OperationID:      "connectCoreV1PostNodeProxy",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "path",
					In:   "query",
				}: params.Path,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ConnectCoreV1PostNodeProxyParams
			Response = ConnectCoreV1PostNodeProxyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackConnectCoreV1PostNodeProxyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ConnectCoreV1PostNodeProxy(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ConnectCoreV1PostNodeProxy(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeConnectCoreV1PostNodeProxyResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleConnectCoreV1PostNodeProxyWithPathRequest handles connectCoreV1PostNodeProxyWithPath operation.
//
// Connect POST requests to proxy of Node.
//
// POST /api/v1/nodes/{name}/proxy/{path}
func (s *Server) handleConnectCoreV1PostNodeProxyWithPathRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("connectCoreV1PostNodeProxyWithPath"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/api/v1/nodes/{name}/proxy/{path}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ConnectCoreV1PostNodeProxyWithPath",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ConnectCoreV1PostNodeProxyWithPath",
			ID:   "connectCoreV1PostNodeProxyWithPath",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ConnectCoreV1PostNodeProxyWithPath", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeConnectCoreV1PostNodeProxyWithPathParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ConnectCoreV1PostNodeProxyWithPathRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ConnectCoreV1PostNodeProxyWithPath",
			OperationSummary: "",
			OperationID:      "connectCoreV1PostNodeProxyWithPath",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "path",
					In:   "path",
				}: params.PathPath,
				{
					Name: "path",
					In:   "query",
				}: params.QueryPath,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ConnectCoreV1PostNodeProxyWithPathParams
			Response = ConnectCoreV1PostNodeProxyWithPathRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackConnectCoreV1PostNodeProxyWithPathParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ConnectCoreV1PostNodeProxyWithPath(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ConnectCoreV1PostNodeProxyWithPath(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeConnectCoreV1PostNodeProxyWithPathResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleConnectCoreV1PutNamespacedPodProxyRequest handles connectCoreV1PutNamespacedPodProxy operation.
//
// Connect PUT requests to proxy of Pod.
//
// PUT /api/v1/namespaces/{namespace}/pods/{name}/proxy
func (s *Server) handleConnectCoreV1PutNamespacedPodProxyRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("connectCoreV1PutNamespacedPodProxy"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/api/v1/namespaces/{namespace}/pods/{name}/proxy"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ConnectCoreV1PutNamespacedPodProxy",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ConnectCoreV1PutNamespacedPodProxy",
			ID:   "connectCoreV1PutNamespacedPodProxy",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ConnectCoreV1PutNamespacedPodProxy", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeConnectCoreV1PutNamespacedPodProxyParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ConnectCoreV1PutNamespacedPodProxyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ConnectCoreV1PutNamespacedPodProxy",
			OperationSummary: "",
			OperationID:      "connectCoreV1PutNamespacedPodProxy",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "path",
					In:   "query",
				}: params.Path,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ConnectCoreV1PutNamespacedPodProxyParams
			Response = ConnectCoreV1PutNamespacedPodProxyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackConnectCoreV1PutNamespacedPodProxyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ConnectCoreV1PutNamespacedPodProxy(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ConnectCoreV1PutNamespacedPodProxy(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeConnectCoreV1PutNamespacedPodProxyResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleConnectCoreV1PutNamespacedPodProxyWithPathRequest handles connectCoreV1PutNamespacedPodProxyWithPath operation.
//
// Connect PUT requests to proxy of Pod.
//
// PUT /api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}
func (s *Server) handleConnectCoreV1PutNamespacedPodProxyWithPathRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("connectCoreV1PutNamespacedPodProxyWithPath"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ConnectCoreV1PutNamespacedPodProxyWithPath",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ConnectCoreV1PutNamespacedPodProxyWithPath",
			ID:   "connectCoreV1PutNamespacedPodProxyWithPath",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ConnectCoreV1PutNamespacedPodProxyWithPath", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeConnectCoreV1PutNamespacedPodProxyWithPathParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ConnectCoreV1PutNamespacedPodProxyWithPathRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ConnectCoreV1PutNamespacedPodProxyWithPath",
			OperationSummary: "",
			OperationID:      "connectCoreV1PutNamespacedPodProxyWithPath",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "path",
					In:   "path",
				}: params.PathPath,
				{
					Name: "path",
					In:   "query",
				}: params.QueryPath,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ConnectCoreV1PutNamespacedPodProxyWithPathParams
			Response = ConnectCoreV1PutNamespacedPodProxyWithPathRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackConnectCoreV1PutNamespacedPodProxyWithPathParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ConnectCoreV1PutNamespacedPodProxyWithPath(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ConnectCoreV1PutNamespacedPodProxyWithPath(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeConnectCoreV1PutNamespacedPodProxyWithPathResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleConnectCoreV1PutNamespacedServiceProxyRequest handles connectCoreV1PutNamespacedServiceProxy operation.
//
// Connect PUT requests to proxy of Service.
//
// PUT /api/v1/namespaces/{namespace}/services/{name}/proxy
func (s *Server) handleConnectCoreV1PutNamespacedServiceProxyRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("connectCoreV1PutNamespacedServiceProxy"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/api/v1/namespaces/{namespace}/services/{name}/proxy"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ConnectCoreV1PutNamespacedServiceProxy",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ConnectCoreV1PutNamespacedServiceProxy",
			ID:   "connectCoreV1PutNamespacedServiceProxy",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ConnectCoreV1PutNamespacedServiceProxy", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeConnectCoreV1PutNamespacedServiceProxyParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ConnectCoreV1PutNamespacedServiceProxyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ConnectCoreV1PutNamespacedServiceProxy",
			OperationSummary: "",
			OperationID:      "connectCoreV1PutNamespacedServiceProxy",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "path",
					In:   "query",
				}: params.Path,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ConnectCoreV1PutNamespacedServiceProxyParams
			Response = ConnectCoreV1PutNamespacedServiceProxyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackConnectCoreV1PutNamespacedServiceProxyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ConnectCoreV1PutNamespacedServiceProxy(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ConnectCoreV1PutNamespacedServiceProxy(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeConnectCoreV1PutNamespacedServiceProxyResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleConnectCoreV1PutNamespacedServiceProxyWithPathRequest handles connectCoreV1PutNamespacedServiceProxyWithPath operation.
//
// Connect PUT requests to proxy of Service.
//
// PUT /api/v1/namespaces/{namespace}/services/{name}/proxy/{path}
func (s *Server) handleConnectCoreV1PutNamespacedServiceProxyWithPathRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("connectCoreV1PutNamespacedServiceProxyWithPath"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ConnectCoreV1PutNamespacedServiceProxyWithPath",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ConnectCoreV1PutNamespacedServiceProxyWithPath",
			ID:   "connectCoreV1PutNamespacedServiceProxyWithPath",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ConnectCoreV1PutNamespacedServiceProxyWithPath", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeConnectCoreV1PutNamespacedServiceProxyWithPathParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ConnectCoreV1PutNamespacedServiceProxyWithPathRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ConnectCoreV1PutNamespacedServiceProxyWithPath",
			OperationSummary: "",
			OperationID:      "connectCoreV1PutNamespacedServiceProxyWithPath",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "path",
					In:   "path",
				}: params.PathPath,
				{
					Name: "path",
					In:   "query",
				}: params.QueryPath,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ConnectCoreV1PutNamespacedServiceProxyWithPathParams
			Response = ConnectCoreV1PutNamespacedServiceProxyWithPathRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackConnectCoreV1PutNamespacedServiceProxyWithPathParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ConnectCoreV1PutNamespacedServiceProxyWithPath(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ConnectCoreV1PutNamespacedServiceProxyWithPath(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeConnectCoreV1PutNamespacedServiceProxyWithPathResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleConnectCoreV1PutNodeProxyRequest handles connectCoreV1PutNodeProxy operation.
//
// Connect PUT requests to proxy of Node.
//
// PUT /api/v1/nodes/{name}/proxy
func (s *Server) handleConnectCoreV1PutNodeProxyRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("connectCoreV1PutNodeProxy"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/api/v1/nodes/{name}/proxy"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ConnectCoreV1PutNodeProxy",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ConnectCoreV1PutNodeProxy",
			ID:   "connectCoreV1PutNodeProxy",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ConnectCoreV1PutNodeProxy", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeConnectCoreV1PutNodeProxyParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ConnectCoreV1PutNodeProxyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ConnectCoreV1PutNodeProxy",
			OperationSummary: "",
			OperationID:      "connectCoreV1PutNodeProxy",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "path",
					In:   "query",
				}: params.Path,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ConnectCoreV1PutNodeProxyParams
			Response = ConnectCoreV1PutNodeProxyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackConnectCoreV1PutNodeProxyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ConnectCoreV1PutNodeProxy(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ConnectCoreV1PutNodeProxy(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeConnectCoreV1PutNodeProxyResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleConnectCoreV1PutNodeProxyWithPathRequest handles connectCoreV1PutNodeProxyWithPath operation.
//
// Connect PUT requests to proxy of Node.
//
// PUT /api/v1/nodes/{name}/proxy/{path}
func (s *Server) handleConnectCoreV1PutNodeProxyWithPathRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("connectCoreV1PutNodeProxyWithPath"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/api/v1/nodes/{name}/proxy/{path}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ConnectCoreV1PutNodeProxyWithPath",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ConnectCoreV1PutNodeProxyWithPath",
			ID:   "connectCoreV1PutNodeProxyWithPath",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ConnectCoreV1PutNodeProxyWithPath", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeConnectCoreV1PutNodeProxyWithPathParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ConnectCoreV1PutNodeProxyWithPathRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ConnectCoreV1PutNodeProxyWithPath",
			OperationSummary: "",
			OperationID:      "connectCoreV1PutNodeProxyWithPath",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "path",
					In:   "path",
				}: params.PathPath,
				{
					Name: "path",
					In:   "query",
				}: params.QueryPath,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ConnectCoreV1PutNodeProxyWithPathParams
			Response = ConnectCoreV1PutNodeProxyWithPathRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackConnectCoreV1PutNodeProxyWithPathParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ConnectCoreV1PutNodeProxyWithPath(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ConnectCoreV1PutNodeProxyWithPath(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeConnectCoreV1PutNodeProxyWithPathResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetAPIVersionsRequest handles getAPIVersions operation.
//
// Get available API versions.
//
// GET /apis/
func (s *Server) handleGetAPIVersionsRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getAPIVersions"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetAPIVersions",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetAPIVersions",
			ID:   "getAPIVersions",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "GetAPIVersions", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}

	var response GetAPIVersionsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetAPIVersions",
			OperationSummary: "",
			OperationID:      "getAPIVersions",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetAPIVersionsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetAPIVersions(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetAPIVersions(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetAPIVersionsResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetAdmissionregistrationAPIGroupRequest handles getAdmissionregistrationAPIGroup operation.
//
// Get information of a group.
//
// GET /apis/admissionregistration.k8s.io/
func (s *Server) handleGetAdmissionregistrationAPIGroupRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getAdmissionregistrationAPIGroup"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/admissionregistration.k8s.io/"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetAdmissionregistrationAPIGroup",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetAdmissionregistrationAPIGroup",
			ID:   "getAdmissionregistrationAPIGroup",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "GetAdmissionregistrationAPIGroup", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}

	var response GetAdmissionregistrationAPIGroupRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetAdmissionregistrationAPIGroup",
			OperationSummary: "",
			OperationID:      "getAdmissionregistrationAPIGroup",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetAdmissionregistrationAPIGroupRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetAdmissionregistrationAPIGroup(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetAdmissionregistrationAPIGroup(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetAdmissionregistrationAPIGroupResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetAdmissionregistrationV1APIResourcesRequest handles getAdmissionregistrationV1APIResources operation.
//
// Get available resources.
//
// GET /apis/admissionregistration.k8s.io/v1/
func (s *Server) handleGetAdmissionregistrationV1APIResourcesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getAdmissionregistrationV1APIResources"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/admissionregistration.k8s.io/v1/"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetAdmissionregistrationV1APIResources",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetAdmissionregistrationV1APIResources",
			ID:   "getAdmissionregistrationV1APIResources",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "GetAdmissionregistrationV1APIResources", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}

	var response GetAdmissionregistrationV1APIResourcesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetAdmissionregistrationV1APIResources",
			OperationSummary: "",
			OperationID:      "getAdmissionregistrationV1APIResources",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetAdmissionregistrationV1APIResourcesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetAdmissionregistrationV1APIResources(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetAdmissionregistrationV1APIResources(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetAdmissionregistrationV1APIResourcesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetApiextensionsAPIGroupRequest handles getApiextensionsAPIGroup operation.
//
// Get information of a group.
//
// GET /apis/apiextensions.k8s.io/
func (s *Server) handleGetApiextensionsAPIGroupRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getApiextensionsAPIGroup"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/apiextensions.k8s.io/"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetApiextensionsAPIGroup",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetApiextensionsAPIGroup",
			ID:   "getApiextensionsAPIGroup",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "GetApiextensionsAPIGroup", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}

	var response GetApiextensionsAPIGroupRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetApiextensionsAPIGroup",
			OperationSummary: "",
			OperationID:      "getApiextensionsAPIGroup",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetApiextensionsAPIGroupRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetApiextensionsAPIGroup(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetApiextensionsAPIGroup(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetApiextensionsAPIGroupResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetApiextensionsV1APIResourcesRequest handles getApiextensionsV1APIResources operation.
//
// Get available resources.
//
// GET /apis/apiextensions.k8s.io/v1/
func (s *Server) handleGetApiextensionsV1APIResourcesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getApiextensionsV1APIResources"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/apiextensions.k8s.io/v1/"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetApiextensionsV1APIResources",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetApiextensionsV1APIResources",
			ID:   "getApiextensionsV1APIResources",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "GetApiextensionsV1APIResources", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}

	var response GetApiextensionsV1APIResourcesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetApiextensionsV1APIResources",
			OperationSummary: "",
			OperationID:      "getApiextensionsV1APIResources",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetApiextensionsV1APIResourcesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetApiextensionsV1APIResources(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetApiextensionsV1APIResources(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetApiextensionsV1APIResourcesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetApiregistrationAPIGroupRequest handles getApiregistrationAPIGroup operation.
//
// Get information of a group.
//
// GET /apis/apiregistration.k8s.io/
func (s *Server) handleGetApiregistrationAPIGroupRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getApiregistrationAPIGroup"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/apiregistration.k8s.io/"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetApiregistrationAPIGroup",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetApiregistrationAPIGroup",
			ID:   "getApiregistrationAPIGroup",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "GetApiregistrationAPIGroup", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}

	var response GetApiregistrationAPIGroupRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetApiregistrationAPIGroup",
			OperationSummary: "",
			OperationID:      "getApiregistrationAPIGroup",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetApiregistrationAPIGroupRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetApiregistrationAPIGroup(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetApiregistrationAPIGroup(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetApiregistrationAPIGroupResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetApiregistrationV1APIResourcesRequest handles getApiregistrationV1APIResources operation.
//
// Get available resources.
//
// GET /apis/apiregistration.k8s.io/v1/
func (s *Server) handleGetApiregistrationV1APIResourcesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getApiregistrationV1APIResources"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/apiregistration.k8s.io/v1/"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetApiregistrationV1APIResources",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetApiregistrationV1APIResources",
			ID:   "getApiregistrationV1APIResources",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "GetApiregistrationV1APIResources", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}

	var response GetApiregistrationV1APIResourcesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetApiregistrationV1APIResources",
			OperationSummary: "",
			OperationID:      "getApiregistrationV1APIResources",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetApiregistrationV1APIResourcesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetApiregistrationV1APIResources(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetApiregistrationV1APIResources(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetApiregistrationV1APIResourcesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetAppsAPIGroupRequest handles getAppsAPIGroup operation.
//
// Get information of a group.
//
// GET /apis/apps/
func (s *Server) handleGetAppsAPIGroupRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getAppsAPIGroup"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/apps/"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetAppsAPIGroup",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetAppsAPIGroup",
			ID:   "getAppsAPIGroup",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "GetAppsAPIGroup", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}

	var response GetAppsAPIGroupRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetAppsAPIGroup",
			OperationSummary: "",
			OperationID:      "getAppsAPIGroup",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetAppsAPIGroupRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetAppsAPIGroup(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetAppsAPIGroup(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetAppsAPIGroupResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetAppsV1APIResourcesRequest handles getAppsV1APIResources operation.
//
// Get available resources.
//
// GET /apis/apps/v1/
func (s *Server) handleGetAppsV1APIResourcesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getAppsV1APIResources"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/apps/v1/"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetAppsV1APIResources",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetAppsV1APIResources",
			ID:   "getAppsV1APIResources",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "GetAppsV1APIResources", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}

	var response GetAppsV1APIResourcesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetAppsV1APIResources",
			OperationSummary: "",
			OperationID:      "getAppsV1APIResources",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetAppsV1APIResourcesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetAppsV1APIResources(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetAppsV1APIResources(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetAppsV1APIResourcesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetAuthenticationAPIGroupRequest handles getAuthenticationAPIGroup operation.
//
// Get information of a group.
//
// GET /apis/authentication.k8s.io/
func (s *Server) handleGetAuthenticationAPIGroupRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getAuthenticationAPIGroup"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/authentication.k8s.io/"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetAuthenticationAPIGroup",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetAuthenticationAPIGroup",
			ID:   "getAuthenticationAPIGroup",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "GetAuthenticationAPIGroup", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}

	var response GetAuthenticationAPIGroupRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetAuthenticationAPIGroup",
			OperationSummary: "",
			OperationID:      "getAuthenticationAPIGroup",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetAuthenticationAPIGroupRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetAuthenticationAPIGroup(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetAuthenticationAPIGroup(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetAuthenticationAPIGroupResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetAuthenticationV1APIResourcesRequest handles getAuthenticationV1APIResources operation.
//
// Get available resources.
//
// GET /apis/authentication.k8s.io/v1/
func (s *Server) handleGetAuthenticationV1APIResourcesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getAuthenticationV1APIResources"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/authentication.k8s.io/v1/"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetAuthenticationV1APIResources",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetAuthenticationV1APIResources",
			ID:   "getAuthenticationV1APIResources",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "GetAuthenticationV1APIResources", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}

	var response GetAuthenticationV1APIResourcesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetAuthenticationV1APIResources",
			OperationSummary: "",
			OperationID:      "getAuthenticationV1APIResources",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetAuthenticationV1APIResourcesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetAuthenticationV1APIResources(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetAuthenticationV1APIResources(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetAuthenticationV1APIResourcesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetAuthorizationAPIGroupRequest handles getAuthorizationAPIGroup operation.
//
// Get information of a group.
//
// GET /apis/authorization.k8s.io/
func (s *Server) handleGetAuthorizationAPIGroupRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getAuthorizationAPIGroup"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/authorization.k8s.io/"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetAuthorizationAPIGroup",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetAuthorizationAPIGroup",
			ID:   "getAuthorizationAPIGroup",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "GetAuthorizationAPIGroup", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}

	var response GetAuthorizationAPIGroupRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetAuthorizationAPIGroup",
			OperationSummary: "",
			OperationID:      "getAuthorizationAPIGroup",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetAuthorizationAPIGroupRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetAuthorizationAPIGroup(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetAuthorizationAPIGroup(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetAuthorizationAPIGroupResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetAuthorizationV1APIResourcesRequest handles getAuthorizationV1APIResources operation.
//
// Get available resources.
//
// GET /apis/authorization.k8s.io/v1/
func (s *Server) handleGetAuthorizationV1APIResourcesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getAuthorizationV1APIResources"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/authorization.k8s.io/v1/"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetAuthorizationV1APIResources",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetAuthorizationV1APIResources",
			ID:   "getAuthorizationV1APIResources",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "GetAuthorizationV1APIResources", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}

	var response GetAuthorizationV1APIResourcesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetAuthorizationV1APIResources",
			OperationSummary: "",
			OperationID:      "getAuthorizationV1APIResources",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetAuthorizationV1APIResourcesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetAuthorizationV1APIResources(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetAuthorizationV1APIResources(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetAuthorizationV1APIResourcesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetAutoscalingAPIGroupRequest handles getAutoscalingAPIGroup operation.
//
// Get information of a group.
//
// GET /apis/autoscaling/
func (s *Server) handleGetAutoscalingAPIGroupRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getAutoscalingAPIGroup"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/autoscaling/"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetAutoscalingAPIGroup",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetAutoscalingAPIGroup",
			ID:   "getAutoscalingAPIGroup",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "GetAutoscalingAPIGroup", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}

	var response GetAutoscalingAPIGroupRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetAutoscalingAPIGroup",
			OperationSummary: "",
			OperationID:      "getAutoscalingAPIGroup",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetAutoscalingAPIGroupRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetAutoscalingAPIGroup(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetAutoscalingAPIGroup(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetAutoscalingAPIGroupResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetAutoscalingV1APIResourcesRequest handles getAutoscalingV1APIResources operation.
//
// Get available resources.
//
// GET /apis/autoscaling/v1/
func (s *Server) handleGetAutoscalingV1APIResourcesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getAutoscalingV1APIResources"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/autoscaling/v1/"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetAutoscalingV1APIResources",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetAutoscalingV1APIResources",
			ID:   "getAutoscalingV1APIResources",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "GetAutoscalingV1APIResources", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}

	var response GetAutoscalingV1APIResourcesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetAutoscalingV1APIResources",
			OperationSummary: "",
			OperationID:      "getAutoscalingV1APIResources",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetAutoscalingV1APIResourcesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetAutoscalingV1APIResources(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetAutoscalingV1APIResources(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetAutoscalingV1APIResourcesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetAutoscalingV2beta1APIResourcesRequest handles getAutoscalingV2beta1APIResources operation.
//
// Get available resources.
//
// GET /apis/autoscaling/v2beta1/
func (s *Server) handleGetAutoscalingV2beta1APIResourcesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getAutoscalingV2beta1APIResources"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/autoscaling/v2beta1/"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetAutoscalingV2beta1APIResources",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetAutoscalingV2beta1APIResources",
			ID:   "getAutoscalingV2beta1APIResources",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "GetAutoscalingV2beta1APIResources", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}

	var response GetAutoscalingV2beta1APIResourcesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetAutoscalingV2beta1APIResources",
			OperationSummary: "",
			OperationID:      "getAutoscalingV2beta1APIResources",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetAutoscalingV2beta1APIResourcesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetAutoscalingV2beta1APIResources(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetAutoscalingV2beta1APIResources(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetAutoscalingV2beta1APIResourcesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetAutoscalingV2beta2APIResourcesRequest handles getAutoscalingV2beta2APIResources operation.
//
// Get available resources.
//
// GET /apis/autoscaling/v2beta2/
func (s *Server) handleGetAutoscalingV2beta2APIResourcesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getAutoscalingV2beta2APIResources"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/autoscaling/v2beta2/"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetAutoscalingV2beta2APIResources",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetAutoscalingV2beta2APIResources",
			ID:   "getAutoscalingV2beta2APIResources",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "GetAutoscalingV2beta2APIResources", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}

	var response GetAutoscalingV2beta2APIResourcesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetAutoscalingV2beta2APIResources",
			OperationSummary: "",
			OperationID:      "getAutoscalingV2beta2APIResources",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetAutoscalingV2beta2APIResourcesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetAutoscalingV2beta2APIResources(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetAutoscalingV2beta2APIResources(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetAutoscalingV2beta2APIResourcesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetBatchAPIGroupRequest handles getBatchAPIGroup operation.
//
// Get information of a group.
//
// GET /apis/batch/
func (s *Server) handleGetBatchAPIGroupRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getBatchAPIGroup"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/batch/"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetBatchAPIGroup",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetBatchAPIGroup",
			ID:   "getBatchAPIGroup",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "GetBatchAPIGroup", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}

	var response GetBatchAPIGroupRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetBatchAPIGroup",
			OperationSummary: "",
			OperationID:      "getBatchAPIGroup",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetBatchAPIGroupRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetBatchAPIGroup(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetBatchAPIGroup(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetBatchAPIGroupResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetBatchV1APIResourcesRequest handles getBatchV1APIResources operation.
//
// Get available resources.
//
// GET /apis/batch/v1/
func (s *Server) handleGetBatchV1APIResourcesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getBatchV1APIResources"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/batch/v1/"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetBatchV1APIResources",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetBatchV1APIResources",
			ID:   "getBatchV1APIResources",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "GetBatchV1APIResources", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}

	var response GetBatchV1APIResourcesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetBatchV1APIResources",
			OperationSummary: "",
			OperationID:      "getBatchV1APIResources",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetBatchV1APIResourcesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetBatchV1APIResources(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetBatchV1APIResources(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetBatchV1APIResourcesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetBatchV1beta1APIResourcesRequest handles getBatchV1beta1APIResources operation.
//
// Get available resources.
//
// GET /apis/batch/v1beta1/
func (s *Server) handleGetBatchV1beta1APIResourcesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getBatchV1beta1APIResources"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/batch/v1beta1/"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetBatchV1beta1APIResources",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetBatchV1beta1APIResources",
			ID:   "getBatchV1beta1APIResources",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "GetBatchV1beta1APIResources", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}

	var response GetBatchV1beta1APIResourcesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetBatchV1beta1APIResources",
			OperationSummary: "",
			OperationID:      "getBatchV1beta1APIResources",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetBatchV1beta1APIResourcesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetBatchV1beta1APIResources(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetBatchV1beta1APIResources(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetBatchV1beta1APIResourcesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetCertificatesAPIGroupRequest handles getCertificatesAPIGroup operation.
//
// Get information of a group.
//
// GET /apis/certificates.k8s.io/
func (s *Server) handleGetCertificatesAPIGroupRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getCertificatesAPIGroup"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/certificates.k8s.io/"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetCertificatesAPIGroup",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetCertificatesAPIGroup",
			ID:   "getCertificatesAPIGroup",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "GetCertificatesAPIGroup", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}

	var response GetCertificatesAPIGroupRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetCertificatesAPIGroup",
			OperationSummary: "",
			OperationID:      "getCertificatesAPIGroup",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetCertificatesAPIGroupRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetCertificatesAPIGroup(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetCertificatesAPIGroup(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetCertificatesAPIGroupResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetCertificatesV1APIResourcesRequest handles getCertificatesV1APIResources operation.
//
// Get available resources.
//
// GET /apis/certificates.k8s.io/v1/
func (s *Server) handleGetCertificatesV1APIResourcesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getCertificatesV1APIResources"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/certificates.k8s.io/v1/"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetCertificatesV1APIResources",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetCertificatesV1APIResources",
			ID:   "getCertificatesV1APIResources",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "GetCertificatesV1APIResources", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}

	var response GetCertificatesV1APIResourcesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetCertificatesV1APIResources",
			OperationSummary: "",
			OperationID:      "getCertificatesV1APIResources",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetCertificatesV1APIResourcesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetCertificatesV1APIResources(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetCertificatesV1APIResources(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetCertificatesV1APIResourcesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetCodeVersionRequest handles getCodeVersion operation.
//
// Get the code version.
//
// GET /version/
func (s *Server) handleGetCodeVersionRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getCodeVersion"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/version/"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetCodeVersion",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetCodeVersion",
			ID:   "getCodeVersion",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "GetCodeVersion", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}

	var response GetCodeVersionRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetCodeVersion",
			OperationSummary: "",
			OperationID:      "getCodeVersion",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetCodeVersionRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetCodeVersion(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetCodeVersion(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetCodeVersionResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetCoordinationAPIGroupRequest handles getCoordinationAPIGroup operation.
//
// Get information of a group.
//
// GET /apis/coordination.k8s.io/
func (s *Server) handleGetCoordinationAPIGroupRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getCoordinationAPIGroup"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/coordination.k8s.io/"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetCoordinationAPIGroup",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetCoordinationAPIGroup",
			ID:   "getCoordinationAPIGroup",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "GetCoordinationAPIGroup", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}

	var response GetCoordinationAPIGroupRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetCoordinationAPIGroup",
			OperationSummary: "",
			OperationID:      "getCoordinationAPIGroup",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetCoordinationAPIGroupRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetCoordinationAPIGroup(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetCoordinationAPIGroup(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetCoordinationAPIGroupResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetCoordinationV1APIResourcesRequest handles getCoordinationV1APIResources operation.
//
// Get available resources.
//
// GET /apis/coordination.k8s.io/v1/
func (s *Server) handleGetCoordinationV1APIResourcesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getCoordinationV1APIResources"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/coordination.k8s.io/v1/"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetCoordinationV1APIResources",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetCoordinationV1APIResources",
			ID:   "getCoordinationV1APIResources",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "GetCoordinationV1APIResources", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}

	var response GetCoordinationV1APIResourcesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetCoordinationV1APIResources",
			OperationSummary: "",
			OperationID:      "getCoordinationV1APIResources",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetCoordinationV1APIResourcesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetCoordinationV1APIResources(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetCoordinationV1APIResources(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetCoordinationV1APIResourcesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetCoreAPIVersionsRequest handles getCoreAPIVersions operation.
//
// Get available API versions.
//
// GET /api/
func (s *Server) handleGetCoreAPIVersionsRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getCoreAPIVersions"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetCoreAPIVersions",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetCoreAPIVersions",
			ID:   "getCoreAPIVersions",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "GetCoreAPIVersions", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}

	var response GetCoreAPIVersionsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetCoreAPIVersions",
			OperationSummary: "",
			OperationID:      "getCoreAPIVersions",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetCoreAPIVersionsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetCoreAPIVersions(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetCoreAPIVersions(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetCoreAPIVersionsResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetCoreV1APIResourcesRequest handles getCoreV1APIResources operation.
//
// Get available resources.
//
// GET /api/v1/
func (s *Server) handleGetCoreV1APIResourcesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getCoreV1APIResources"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/v1/"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetCoreV1APIResources",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetCoreV1APIResources",
			ID:   "getCoreV1APIResources",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "GetCoreV1APIResources", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}

	var response GetCoreV1APIResourcesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetCoreV1APIResources",
			OperationSummary: "",
			OperationID:      "getCoreV1APIResources",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetCoreV1APIResourcesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetCoreV1APIResources(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetCoreV1APIResources(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetCoreV1APIResourcesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetDiscoveryAPIGroupRequest handles getDiscoveryAPIGroup operation.
//
// Get information of a group.
//
// GET /apis/discovery.k8s.io/
func (s *Server) handleGetDiscoveryAPIGroupRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getDiscoveryAPIGroup"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/discovery.k8s.io/"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetDiscoveryAPIGroup",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetDiscoveryAPIGroup",
			ID:   "getDiscoveryAPIGroup",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "GetDiscoveryAPIGroup", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}

	var response GetDiscoveryAPIGroupRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetDiscoveryAPIGroup",
			OperationSummary: "",
			OperationID:      "getDiscoveryAPIGroup",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetDiscoveryAPIGroupRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetDiscoveryAPIGroup(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetDiscoveryAPIGroup(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetDiscoveryAPIGroupResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetDiscoveryV1APIResourcesRequest handles getDiscoveryV1APIResources operation.
//
// Get available resources.
//
// GET /apis/discovery.k8s.io/v1/
func (s *Server) handleGetDiscoveryV1APIResourcesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getDiscoveryV1APIResources"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/discovery.k8s.io/v1/"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetDiscoveryV1APIResources",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetDiscoveryV1APIResources",
			ID:   "getDiscoveryV1APIResources",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "GetDiscoveryV1APIResources", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}

	var response GetDiscoveryV1APIResourcesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetDiscoveryV1APIResources",
			OperationSummary: "",
			OperationID:      "getDiscoveryV1APIResources",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetDiscoveryV1APIResourcesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetDiscoveryV1APIResources(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetDiscoveryV1APIResources(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetDiscoveryV1APIResourcesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetDiscoveryV1beta1APIResourcesRequest handles getDiscoveryV1beta1APIResources operation.
//
// Get available resources.
//
// GET /apis/discovery.k8s.io/v1beta1/
func (s *Server) handleGetDiscoveryV1beta1APIResourcesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getDiscoveryV1beta1APIResources"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/discovery.k8s.io/v1beta1/"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetDiscoveryV1beta1APIResources",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetDiscoveryV1beta1APIResources",
			ID:   "getDiscoveryV1beta1APIResources",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "GetDiscoveryV1beta1APIResources", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}

	var response GetDiscoveryV1beta1APIResourcesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetDiscoveryV1beta1APIResources",
			OperationSummary: "",
			OperationID:      "getDiscoveryV1beta1APIResources",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetDiscoveryV1beta1APIResourcesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetDiscoveryV1beta1APIResources(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetDiscoveryV1beta1APIResources(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetDiscoveryV1beta1APIResourcesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetEventsAPIGroupRequest handles getEventsAPIGroup operation.
//
// Get information of a group.
//
// GET /apis/events.k8s.io/
func (s *Server) handleGetEventsAPIGroupRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getEventsAPIGroup"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/events.k8s.io/"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetEventsAPIGroup",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetEventsAPIGroup",
			ID:   "getEventsAPIGroup",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "GetEventsAPIGroup", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}

	var response GetEventsAPIGroupRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetEventsAPIGroup",
			OperationSummary: "",
			OperationID:      "getEventsAPIGroup",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetEventsAPIGroupRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetEventsAPIGroup(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetEventsAPIGroup(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetEventsAPIGroupResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetEventsV1APIResourcesRequest handles getEventsV1APIResources operation.
//
// Get available resources.
//
// GET /apis/events.k8s.io/v1/
func (s *Server) handleGetEventsV1APIResourcesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getEventsV1APIResources"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/events.k8s.io/v1/"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetEventsV1APIResources",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetEventsV1APIResources",
			ID:   "getEventsV1APIResources",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "GetEventsV1APIResources", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}

	var response GetEventsV1APIResourcesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetEventsV1APIResources",
			OperationSummary: "",
			OperationID:      "getEventsV1APIResources",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetEventsV1APIResourcesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetEventsV1APIResources(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetEventsV1APIResources(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetEventsV1APIResourcesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetEventsV1beta1APIResourcesRequest handles getEventsV1beta1APIResources operation.
//
// Get available resources.
//
// GET /apis/events.k8s.io/v1beta1/
func (s *Server) handleGetEventsV1beta1APIResourcesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getEventsV1beta1APIResources"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/events.k8s.io/v1beta1/"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetEventsV1beta1APIResources",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetEventsV1beta1APIResources",
			ID:   "getEventsV1beta1APIResources",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "GetEventsV1beta1APIResources", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}

	var response GetEventsV1beta1APIResourcesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetEventsV1beta1APIResources",
			OperationSummary: "",
			OperationID:      "getEventsV1beta1APIResources",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetEventsV1beta1APIResourcesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetEventsV1beta1APIResources(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetEventsV1beta1APIResources(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetEventsV1beta1APIResourcesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetFlowcontrolApiserverAPIGroupRequest handles getFlowcontrolApiserverAPIGroup operation.
//
// Get information of a group.
//
// GET /apis/flowcontrol.apiserver.k8s.io/
func (s *Server) handleGetFlowcontrolApiserverAPIGroupRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getFlowcontrolApiserverAPIGroup"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/flowcontrol.apiserver.k8s.io/"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetFlowcontrolApiserverAPIGroup",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetFlowcontrolApiserverAPIGroup",
			ID:   "getFlowcontrolApiserverAPIGroup",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "GetFlowcontrolApiserverAPIGroup", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}

	var response GetFlowcontrolApiserverAPIGroupRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetFlowcontrolApiserverAPIGroup",
			OperationSummary: "",
			OperationID:      "getFlowcontrolApiserverAPIGroup",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetFlowcontrolApiserverAPIGroupRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetFlowcontrolApiserverAPIGroup(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetFlowcontrolApiserverAPIGroup(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetFlowcontrolApiserverAPIGroupResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetFlowcontrolApiserverV1beta1APIResourcesRequest handles getFlowcontrolApiserverV1beta1APIResources operation.
//
// Get available resources.
//
// GET /apis/flowcontrol.apiserver.k8s.io/v1beta1/
func (s *Server) handleGetFlowcontrolApiserverV1beta1APIResourcesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getFlowcontrolApiserverV1beta1APIResources"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/flowcontrol.apiserver.k8s.io/v1beta1/"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetFlowcontrolApiserverV1beta1APIResources",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetFlowcontrolApiserverV1beta1APIResources",
			ID:   "getFlowcontrolApiserverV1beta1APIResources",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "GetFlowcontrolApiserverV1beta1APIResources", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}

	var response GetFlowcontrolApiserverV1beta1APIResourcesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetFlowcontrolApiserverV1beta1APIResources",
			OperationSummary: "",
			OperationID:      "getFlowcontrolApiserverV1beta1APIResources",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetFlowcontrolApiserverV1beta1APIResourcesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetFlowcontrolApiserverV1beta1APIResources(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetFlowcontrolApiserverV1beta1APIResources(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetFlowcontrolApiserverV1beta1APIResourcesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetFlowcontrolApiserverV1beta2APIResourcesRequest handles getFlowcontrolApiserverV1beta2APIResources operation.
//
// Get available resources.
//
// GET /apis/flowcontrol.apiserver.k8s.io/v1beta2/
func (s *Server) handleGetFlowcontrolApiserverV1beta2APIResourcesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getFlowcontrolApiserverV1beta2APIResources"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/flowcontrol.apiserver.k8s.io/v1beta2/"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetFlowcontrolApiserverV1beta2APIResources",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetFlowcontrolApiserverV1beta2APIResources",
			ID:   "getFlowcontrolApiserverV1beta2APIResources",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "GetFlowcontrolApiserverV1beta2APIResources", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}

	var response GetFlowcontrolApiserverV1beta2APIResourcesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetFlowcontrolApiserverV1beta2APIResources",
			OperationSummary: "",
			OperationID:      "getFlowcontrolApiserverV1beta2APIResources",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetFlowcontrolApiserverV1beta2APIResourcesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetFlowcontrolApiserverV1beta2APIResources(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetFlowcontrolApiserverV1beta2APIResources(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetFlowcontrolApiserverV1beta2APIResourcesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetInternalApiserverAPIGroupRequest handles getInternalApiserverAPIGroup operation.
//
// Get information of a group.
//
// GET /apis/internal.apiserver.k8s.io/
func (s *Server) handleGetInternalApiserverAPIGroupRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getInternalApiserverAPIGroup"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/internal.apiserver.k8s.io/"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetInternalApiserverAPIGroup",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetInternalApiserverAPIGroup",
			ID:   "getInternalApiserverAPIGroup",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "GetInternalApiserverAPIGroup", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}

	var response GetInternalApiserverAPIGroupRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetInternalApiserverAPIGroup",
			OperationSummary: "",
			OperationID:      "getInternalApiserverAPIGroup",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetInternalApiserverAPIGroupRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetInternalApiserverAPIGroup(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetInternalApiserverAPIGroup(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetInternalApiserverAPIGroupResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetInternalApiserverV1alpha1APIResourcesRequest handles getInternalApiserverV1alpha1APIResources operation.
//
// Get available resources.
//
// GET /apis/internal.apiserver.k8s.io/v1alpha1/
func (s *Server) handleGetInternalApiserverV1alpha1APIResourcesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getInternalApiserverV1alpha1APIResources"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/internal.apiserver.k8s.io/v1alpha1/"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetInternalApiserverV1alpha1APIResources",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetInternalApiserverV1alpha1APIResources",
			ID:   "getInternalApiserverV1alpha1APIResources",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "GetInternalApiserverV1alpha1APIResources", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}

	var response GetInternalApiserverV1alpha1APIResourcesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetInternalApiserverV1alpha1APIResources",
			OperationSummary: "",
			OperationID:      "getInternalApiserverV1alpha1APIResources",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetInternalApiserverV1alpha1APIResourcesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetInternalApiserverV1alpha1APIResources(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetInternalApiserverV1alpha1APIResources(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetInternalApiserverV1alpha1APIResourcesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetNetworkingAPIGroupRequest handles getNetworkingAPIGroup operation.
//
// Get information of a group.
//
// GET /apis/networking.k8s.io/
func (s *Server) handleGetNetworkingAPIGroupRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getNetworkingAPIGroup"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/networking.k8s.io/"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetNetworkingAPIGroup",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetNetworkingAPIGroup",
			ID:   "getNetworkingAPIGroup",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "GetNetworkingAPIGroup", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}

	var response GetNetworkingAPIGroupRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetNetworkingAPIGroup",
			OperationSummary: "",
			OperationID:      "getNetworkingAPIGroup",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetNetworkingAPIGroupRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetNetworkingAPIGroup(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetNetworkingAPIGroup(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetNetworkingAPIGroupResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetNetworkingV1APIResourcesRequest handles getNetworkingV1APIResources operation.
//
// Get available resources.
//
// GET /apis/networking.k8s.io/v1/
func (s *Server) handleGetNetworkingV1APIResourcesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getNetworkingV1APIResources"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/networking.k8s.io/v1/"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetNetworkingV1APIResources",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetNetworkingV1APIResources",
			ID:   "getNetworkingV1APIResources",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "GetNetworkingV1APIResources", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}

	var response GetNetworkingV1APIResourcesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetNetworkingV1APIResources",
			OperationSummary: "",
			OperationID:      "getNetworkingV1APIResources",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetNetworkingV1APIResourcesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetNetworkingV1APIResources(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetNetworkingV1APIResources(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetNetworkingV1APIResourcesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetNodeAPIGroupRequest handles getNodeAPIGroup operation.
//
// Get information of a group.
//
// GET /apis/node.k8s.io/
func (s *Server) handleGetNodeAPIGroupRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getNodeAPIGroup"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/node.k8s.io/"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetNodeAPIGroup",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetNodeAPIGroup",
			ID:   "getNodeAPIGroup",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "GetNodeAPIGroup", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}

	var response GetNodeAPIGroupRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetNodeAPIGroup",
			OperationSummary: "",
			OperationID:      "getNodeAPIGroup",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetNodeAPIGroupRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetNodeAPIGroup(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetNodeAPIGroup(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetNodeAPIGroupResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetNodeV1APIResourcesRequest handles getNodeV1APIResources operation.
//
// Get available resources.
//
// GET /apis/node.k8s.io/v1/
func (s *Server) handleGetNodeV1APIResourcesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getNodeV1APIResources"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/node.k8s.io/v1/"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetNodeV1APIResources",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetNodeV1APIResources",
			ID:   "getNodeV1APIResources",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "GetNodeV1APIResources", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}

	var response GetNodeV1APIResourcesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetNodeV1APIResources",
			OperationSummary: "",
			OperationID:      "getNodeV1APIResources",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetNodeV1APIResourcesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetNodeV1APIResources(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetNodeV1APIResources(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetNodeV1APIResourcesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetNodeV1alpha1APIResourcesRequest handles getNodeV1alpha1APIResources operation.
//
// Get available resources.
//
// GET /apis/node.k8s.io/v1alpha1/
func (s *Server) handleGetNodeV1alpha1APIResourcesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getNodeV1alpha1APIResources"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/node.k8s.io/v1alpha1/"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetNodeV1alpha1APIResources",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetNodeV1alpha1APIResources",
			ID:   "getNodeV1alpha1APIResources",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "GetNodeV1alpha1APIResources", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}

	var response GetNodeV1alpha1APIResourcesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetNodeV1alpha1APIResources",
			OperationSummary: "",
			OperationID:      "getNodeV1alpha1APIResources",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetNodeV1alpha1APIResourcesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetNodeV1alpha1APIResources(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetNodeV1alpha1APIResources(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetNodeV1alpha1APIResourcesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetNodeV1beta1APIResourcesRequest handles getNodeV1beta1APIResources operation.
//
// Get available resources.
//
// GET /apis/node.k8s.io/v1beta1/
func (s *Server) handleGetNodeV1beta1APIResourcesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getNodeV1beta1APIResources"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/node.k8s.io/v1beta1/"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetNodeV1beta1APIResources",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetNodeV1beta1APIResources",
			ID:   "getNodeV1beta1APIResources",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "GetNodeV1beta1APIResources", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}

	var response GetNodeV1beta1APIResourcesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetNodeV1beta1APIResources",
			OperationSummary: "",
			OperationID:      "getNodeV1beta1APIResources",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetNodeV1beta1APIResourcesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetNodeV1beta1APIResources(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetNodeV1beta1APIResources(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetNodeV1beta1APIResourcesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetPolicyAPIGroupRequest handles getPolicyAPIGroup operation.
//
// Get information of a group.
//
// GET /apis/policy/
func (s *Server) handleGetPolicyAPIGroupRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getPolicyAPIGroup"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/policy/"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetPolicyAPIGroup",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetPolicyAPIGroup",
			ID:   "getPolicyAPIGroup",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "GetPolicyAPIGroup", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}

	var response GetPolicyAPIGroupRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetPolicyAPIGroup",
			OperationSummary: "",
			OperationID:      "getPolicyAPIGroup",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetPolicyAPIGroupRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetPolicyAPIGroup(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetPolicyAPIGroup(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetPolicyAPIGroupResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetPolicyV1APIResourcesRequest handles getPolicyV1APIResources operation.
//
// Get available resources.
//
// GET /apis/policy/v1/
func (s *Server) handleGetPolicyV1APIResourcesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getPolicyV1APIResources"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/policy/v1/"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetPolicyV1APIResources",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetPolicyV1APIResources",
			ID:   "getPolicyV1APIResources",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "GetPolicyV1APIResources", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}

	var response GetPolicyV1APIResourcesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetPolicyV1APIResources",
			OperationSummary: "",
			OperationID:      "getPolicyV1APIResources",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetPolicyV1APIResourcesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetPolicyV1APIResources(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetPolicyV1APIResources(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetPolicyV1APIResourcesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetPolicyV1beta1APIResourcesRequest handles getPolicyV1beta1APIResources operation.
//
// Get available resources.
//
// GET /apis/policy/v1beta1/
func (s *Server) handleGetPolicyV1beta1APIResourcesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getPolicyV1beta1APIResources"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/policy/v1beta1/"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetPolicyV1beta1APIResources",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetPolicyV1beta1APIResources",
			ID:   "getPolicyV1beta1APIResources",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "GetPolicyV1beta1APIResources", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}

	var response GetPolicyV1beta1APIResourcesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetPolicyV1beta1APIResources",
			OperationSummary: "",
			OperationID:      "getPolicyV1beta1APIResources",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetPolicyV1beta1APIResourcesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetPolicyV1beta1APIResources(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetPolicyV1beta1APIResources(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetPolicyV1beta1APIResourcesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetRbacAuthorizationAPIGroupRequest handles getRbacAuthorizationAPIGroup operation.
//
// Get information of a group.
//
// GET /apis/rbac.authorization.k8s.io/
func (s *Server) handleGetRbacAuthorizationAPIGroupRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getRbacAuthorizationAPIGroup"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/rbac.authorization.k8s.io/"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetRbacAuthorizationAPIGroup",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetRbacAuthorizationAPIGroup",
			ID:   "getRbacAuthorizationAPIGroup",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "GetRbacAuthorizationAPIGroup", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}

	var response GetRbacAuthorizationAPIGroupRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetRbacAuthorizationAPIGroup",
			OperationSummary: "",
			OperationID:      "getRbacAuthorizationAPIGroup",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetRbacAuthorizationAPIGroupRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetRbacAuthorizationAPIGroup(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetRbacAuthorizationAPIGroup(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetRbacAuthorizationAPIGroupResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetRbacAuthorizationV1APIResourcesRequest handles getRbacAuthorizationV1APIResources operation.
//
// Get available resources.
//
// GET /apis/rbac.authorization.k8s.io/v1/
func (s *Server) handleGetRbacAuthorizationV1APIResourcesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getRbacAuthorizationV1APIResources"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/rbac.authorization.k8s.io/v1/"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetRbacAuthorizationV1APIResources",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetRbacAuthorizationV1APIResources",
			ID:   "getRbacAuthorizationV1APIResources",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "GetRbacAuthorizationV1APIResources", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}

	var response GetRbacAuthorizationV1APIResourcesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetRbacAuthorizationV1APIResources",
			OperationSummary: "",
			OperationID:      "getRbacAuthorizationV1APIResources",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetRbacAuthorizationV1APIResourcesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetRbacAuthorizationV1APIResources(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetRbacAuthorizationV1APIResources(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetRbacAuthorizationV1APIResourcesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetSchedulingAPIGroupRequest handles getSchedulingAPIGroup operation.
//
// Get information of a group.
//
// GET /apis/scheduling.k8s.io/
func (s *Server) handleGetSchedulingAPIGroupRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getSchedulingAPIGroup"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/scheduling.k8s.io/"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetSchedulingAPIGroup",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetSchedulingAPIGroup",
			ID:   "getSchedulingAPIGroup",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "GetSchedulingAPIGroup", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}

	var response GetSchedulingAPIGroupRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetSchedulingAPIGroup",
			OperationSummary: "",
			OperationID:      "getSchedulingAPIGroup",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetSchedulingAPIGroupRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetSchedulingAPIGroup(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetSchedulingAPIGroup(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetSchedulingAPIGroupResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetSchedulingV1APIResourcesRequest handles getSchedulingV1APIResources operation.
//
// Get available resources.
//
// GET /apis/scheduling.k8s.io/v1/
func (s *Server) handleGetSchedulingV1APIResourcesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getSchedulingV1APIResources"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/scheduling.k8s.io/v1/"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetSchedulingV1APIResources",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetSchedulingV1APIResources",
			ID:   "getSchedulingV1APIResources",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "GetSchedulingV1APIResources", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}

	var response GetSchedulingV1APIResourcesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetSchedulingV1APIResources",
			OperationSummary: "",
			OperationID:      "getSchedulingV1APIResources",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetSchedulingV1APIResourcesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetSchedulingV1APIResources(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetSchedulingV1APIResources(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetSchedulingV1APIResourcesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetServiceAccountIssuerOpenIDConfigurationRequest handles getServiceAccountIssuerOpenIDConfiguration operation.
//
// Get service account issuer OpenID configuration, also known as the 'OIDC discovery doc'.
//
// GET /.well-known/openid-configuration/
func (s *Server) handleGetServiceAccountIssuerOpenIDConfigurationRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getServiceAccountIssuerOpenIDConfiguration"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/.well-known/openid-configuration/"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetServiceAccountIssuerOpenIDConfiguration",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetServiceAccountIssuerOpenIDConfiguration",
			ID:   "getServiceAccountIssuerOpenIDConfiguration",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "GetServiceAccountIssuerOpenIDConfiguration", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}

	var response GetServiceAccountIssuerOpenIDConfigurationRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetServiceAccountIssuerOpenIDConfiguration",
			OperationSummary: "",
			OperationID:      "getServiceAccountIssuerOpenIDConfiguration",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetServiceAccountIssuerOpenIDConfigurationRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetServiceAccountIssuerOpenIDConfiguration(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetServiceAccountIssuerOpenIDConfiguration(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetServiceAccountIssuerOpenIDConfigurationResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetServiceAccountIssuerOpenIDKeysetRequest handles getServiceAccountIssuerOpenIDKeyset operation.
//
// Get service account issuer OpenID JSON Web Key Set (contains public token verification keys).
//
// GET /openid/v1/jwks/
func (s *Server) handleGetServiceAccountIssuerOpenIDKeysetRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getServiceAccountIssuerOpenIDKeyset"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/openid/v1/jwks/"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetServiceAccountIssuerOpenIDKeyset",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetServiceAccountIssuerOpenIDKeyset",
			ID:   "getServiceAccountIssuerOpenIDKeyset",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "GetServiceAccountIssuerOpenIDKeyset", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}

	var response GetServiceAccountIssuerOpenIDKeysetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetServiceAccountIssuerOpenIDKeyset",
			OperationSummary: "",
			OperationID:      "getServiceAccountIssuerOpenIDKeyset",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetServiceAccountIssuerOpenIDKeysetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetServiceAccountIssuerOpenIDKeyset(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetServiceAccountIssuerOpenIDKeyset(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetServiceAccountIssuerOpenIDKeysetResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetStorageAPIGroupRequest handles getStorageAPIGroup operation.
//
// Get information of a group.
//
// GET /apis/storage.k8s.io/
func (s *Server) handleGetStorageAPIGroupRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getStorageAPIGroup"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/storage.k8s.io/"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetStorageAPIGroup",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetStorageAPIGroup",
			ID:   "getStorageAPIGroup",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "GetStorageAPIGroup", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}

	var response GetStorageAPIGroupRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetStorageAPIGroup",
			OperationSummary: "",
			OperationID:      "getStorageAPIGroup",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetStorageAPIGroupRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetStorageAPIGroup(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetStorageAPIGroup(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetStorageAPIGroupResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetStorageV1APIResourcesRequest handles getStorageV1APIResources operation.
//
// Get available resources.
//
// GET /apis/storage.k8s.io/v1/
func (s *Server) handleGetStorageV1APIResourcesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getStorageV1APIResources"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/storage.k8s.io/v1/"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetStorageV1APIResources",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetStorageV1APIResources",
			ID:   "getStorageV1APIResources",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "GetStorageV1APIResources", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}

	var response GetStorageV1APIResourcesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetStorageV1APIResources",
			OperationSummary: "",
			OperationID:      "getStorageV1APIResources",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetStorageV1APIResourcesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetStorageV1APIResources(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetStorageV1APIResources(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetStorageV1APIResourcesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetStorageV1alpha1APIResourcesRequest handles getStorageV1alpha1APIResources operation.
//
// Get available resources.
//
// GET /apis/storage.k8s.io/v1alpha1/
func (s *Server) handleGetStorageV1alpha1APIResourcesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getStorageV1alpha1APIResources"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/storage.k8s.io/v1alpha1/"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetStorageV1alpha1APIResources",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetStorageV1alpha1APIResources",
			ID:   "getStorageV1alpha1APIResources",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "GetStorageV1alpha1APIResources", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}

	var response GetStorageV1alpha1APIResourcesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetStorageV1alpha1APIResources",
			OperationSummary: "",
			OperationID:      "getStorageV1alpha1APIResources",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetStorageV1alpha1APIResourcesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetStorageV1alpha1APIResources(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetStorageV1alpha1APIResources(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetStorageV1alpha1APIResourcesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetStorageV1beta1APIResourcesRequest handles getStorageV1beta1APIResources operation.
//
// Get available resources.
//
// GET /apis/storage.k8s.io/v1beta1/
func (s *Server) handleGetStorageV1beta1APIResourcesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getStorageV1beta1APIResources"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/storage.k8s.io/v1beta1/"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetStorageV1beta1APIResources",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetStorageV1beta1APIResources",
			ID:   "getStorageV1beta1APIResources",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "GetStorageV1beta1APIResources", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}

	var response GetStorageV1beta1APIResourcesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetStorageV1beta1APIResources",
			OperationSummary: "",
			OperationID:      "getStorageV1beta1APIResources",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetStorageV1beta1APIResourcesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetStorageV1beta1APIResources(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetStorageV1beta1APIResources(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetStorageV1beta1APIResourcesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleListAdmissionregistrationV1MutatingWebhookConfigurationRequest handles listAdmissionregistrationV1MutatingWebhookConfiguration operation.
//
// List or watch objects of kind MutatingWebhookConfiguration.
//
// GET /apis/admissionregistration.k8s.io/v1/mutatingwebhookconfigurations
func (s *Server) handleListAdmissionregistrationV1MutatingWebhookConfigurationRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listAdmissionregistrationV1MutatingWebhookConfiguration"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/admissionregistration.k8s.io/v1/mutatingwebhookconfigurations"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListAdmissionregistrationV1MutatingWebhookConfiguration",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListAdmissionregistrationV1MutatingWebhookConfiguration",
			ID:   "listAdmissionregistrationV1MutatingWebhookConfiguration",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ListAdmissionregistrationV1MutatingWebhookConfiguration", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeListAdmissionregistrationV1MutatingWebhookConfigurationParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListAdmissionregistrationV1MutatingWebhookConfigurationRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ListAdmissionregistrationV1MutatingWebhookConfiguration",
			OperationSummary: "",
			OperationID:      "listAdmissionregistrationV1MutatingWebhookConfiguration",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListAdmissionregistrationV1MutatingWebhookConfigurationParams
			Response = ListAdmissionregistrationV1MutatingWebhookConfigurationRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListAdmissionregistrationV1MutatingWebhookConfigurationParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ListAdmissionregistrationV1MutatingWebhookConfiguration(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ListAdmissionregistrationV1MutatingWebhookConfiguration(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListAdmissionregistrationV1MutatingWebhookConfigurationResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleListAdmissionregistrationV1ValidatingWebhookConfigurationRequest handles listAdmissionregistrationV1ValidatingWebhookConfiguration operation.
//
// List or watch objects of kind ValidatingWebhookConfiguration.
//
// GET /apis/admissionregistration.k8s.io/v1/validatingwebhookconfigurations
func (s *Server) handleListAdmissionregistrationV1ValidatingWebhookConfigurationRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listAdmissionregistrationV1ValidatingWebhookConfiguration"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/admissionregistration.k8s.io/v1/validatingwebhookconfigurations"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListAdmissionregistrationV1ValidatingWebhookConfiguration",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListAdmissionregistrationV1ValidatingWebhookConfiguration",
			ID:   "listAdmissionregistrationV1ValidatingWebhookConfiguration",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ListAdmissionregistrationV1ValidatingWebhookConfiguration", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeListAdmissionregistrationV1ValidatingWebhookConfigurationParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListAdmissionregistrationV1ValidatingWebhookConfigurationRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ListAdmissionregistrationV1ValidatingWebhookConfiguration",
			OperationSummary: "",
			OperationID:      "listAdmissionregistrationV1ValidatingWebhookConfiguration",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListAdmissionregistrationV1ValidatingWebhookConfigurationParams
			Response = ListAdmissionregistrationV1ValidatingWebhookConfigurationRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListAdmissionregistrationV1ValidatingWebhookConfigurationParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ListAdmissionregistrationV1ValidatingWebhookConfiguration(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ListAdmissionregistrationV1ValidatingWebhookConfiguration(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListAdmissionregistrationV1ValidatingWebhookConfigurationResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleListApiextensionsV1CustomResourceDefinitionRequest handles listApiextensionsV1CustomResourceDefinition operation.
//
// List or watch objects of kind CustomResourceDefinition.
//
// GET /apis/apiextensions.k8s.io/v1/customresourcedefinitions
func (s *Server) handleListApiextensionsV1CustomResourceDefinitionRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listApiextensionsV1CustomResourceDefinition"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/apiextensions.k8s.io/v1/customresourcedefinitions"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListApiextensionsV1CustomResourceDefinition",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListApiextensionsV1CustomResourceDefinition",
			ID:   "listApiextensionsV1CustomResourceDefinition",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ListApiextensionsV1CustomResourceDefinition", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeListApiextensionsV1CustomResourceDefinitionParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListApiextensionsV1CustomResourceDefinitionRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ListApiextensionsV1CustomResourceDefinition",
			OperationSummary: "",
			OperationID:      "listApiextensionsV1CustomResourceDefinition",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListApiextensionsV1CustomResourceDefinitionParams
			Response = ListApiextensionsV1CustomResourceDefinitionRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListApiextensionsV1CustomResourceDefinitionParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ListApiextensionsV1CustomResourceDefinition(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ListApiextensionsV1CustomResourceDefinition(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListApiextensionsV1CustomResourceDefinitionResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleListApiregistrationV1APIServiceRequest handles listApiregistrationV1APIService operation.
//
// List or watch objects of kind APIService.
//
// GET /apis/apiregistration.k8s.io/v1/apiservices
func (s *Server) handleListApiregistrationV1APIServiceRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listApiregistrationV1APIService"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/apiregistration.k8s.io/v1/apiservices"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListApiregistrationV1APIService",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListApiregistrationV1APIService",
			ID:   "listApiregistrationV1APIService",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ListApiregistrationV1APIService", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeListApiregistrationV1APIServiceParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListApiregistrationV1APIServiceRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ListApiregistrationV1APIService",
			OperationSummary: "",
			OperationID:      "listApiregistrationV1APIService",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListApiregistrationV1APIServiceParams
			Response = ListApiregistrationV1APIServiceRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListApiregistrationV1APIServiceParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ListApiregistrationV1APIService(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ListApiregistrationV1APIService(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListApiregistrationV1APIServiceResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleListAppsV1ControllerRevisionForAllNamespacesRequest handles listAppsV1ControllerRevisionForAllNamespaces operation.
//
// List or watch objects of kind ControllerRevision.
//
// GET /apis/apps/v1/controllerrevisions
func (s *Server) handleListAppsV1ControllerRevisionForAllNamespacesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listAppsV1ControllerRevisionForAllNamespaces"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/apps/v1/controllerrevisions"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListAppsV1ControllerRevisionForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListAppsV1ControllerRevisionForAllNamespaces",
			ID:   "listAppsV1ControllerRevisionForAllNamespaces",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ListAppsV1ControllerRevisionForAllNamespaces", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeListAppsV1ControllerRevisionForAllNamespacesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListAppsV1ControllerRevisionForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ListAppsV1ControllerRevisionForAllNamespaces",
			OperationSummary: "",
			OperationID:      "listAppsV1ControllerRevisionForAllNamespaces",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListAppsV1ControllerRevisionForAllNamespacesParams
			Response = ListAppsV1ControllerRevisionForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListAppsV1ControllerRevisionForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ListAppsV1ControllerRevisionForAllNamespaces(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ListAppsV1ControllerRevisionForAllNamespaces(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListAppsV1ControllerRevisionForAllNamespacesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleListAppsV1DaemonSetForAllNamespacesRequest handles listAppsV1DaemonSetForAllNamespaces operation.
//
// List or watch objects of kind DaemonSet.
//
// GET /apis/apps/v1/daemonsets
func (s *Server) handleListAppsV1DaemonSetForAllNamespacesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listAppsV1DaemonSetForAllNamespaces"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/apps/v1/daemonsets"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListAppsV1DaemonSetForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListAppsV1DaemonSetForAllNamespaces",
			ID:   "listAppsV1DaemonSetForAllNamespaces",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ListAppsV1DaemonSetForAllNamespaces", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeListAppsV1DaemonSetForAllNamespacesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListAppsV1DaemonSetForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ListAppsV1DaemonSetForAllNamespaces",
			OperationSummary: "",
			OperationID:      "listAppsV1DaemonSetForAllNamespaces",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListAppsV1DaemonSetForAllNamespacesParams
			Response = ListAppsV1DaemonSetForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListAppsV1DaemonSetForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ListAppsV1DaemonSetForAllNamespaces(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ListAppsV1DaemonSetForAllNamespaces(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListAppsV1DaemonSetForAllNamespacesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleListAppsV1DeploymentForAllNamespacesRequest handles listAppsV1DeploymentForAllNamespaces operation.
//
// List or watch objects of kind Deployment.
//
// GET /apis/apps/v1/deployments
func (s *Server) handleListAppsV1DeploymentForAllNamespacesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listAppsV1DeploymentForAllNamespaces"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/apps/v1/deployments"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListAppsV1DeploymentForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListAppsV1DeploymentForAllNamespaces",
			ID:   "listAppsV1DeploymentForAllNamespaces",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ListAppsV1DeploymentForAllNamespaces", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeListAppsV1DeploymentForAllNamespacesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListAppsV1DeploymentForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ListAppsV1DeploymentForAllNamespaces",
			OperationSummary: "",
			OperationID:      "listAppsV1DeploymentForAllNamespaces",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListAppsV1DeploymentForAllNamespacesParams
			Response = ListAppsV1DeploymentForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListAppsV1DeploymentForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ListAppsV1DeploymentForAllNamespaces(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ListAppsV1DeploymentForAllNamespaces(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListAppsV1DeploymentForAllNamespacesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleListAppsV1NamespacedControllerRevisionRequest handles listAppsV1NamespacedControllerRevision operation.
//
// List or watch objects of kind ControllerRevision.
//
// GET /apis/apps/v1/namespaces/{namespace}/controllerrevisions
func (s *Server) handleListAppsV1NamespacedControllerRevisionRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listAppsV1NamespacedControllerRevision"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/apps/v1/namespaces/{namespace}/controllerrevisions"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListAppsV1NamespacedControllerRevision",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListAppsV1NamespacedControllerRevision",
			ID:   "listAppsV1NamespacedControllerRevision",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ListAppsV1NamespacedControllerRevision", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeListAppsV1NamespacedControllerRevisionParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListAppsV1NamespacedControllerRevisionRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ListAppsV1NamespacedControllerRevision",
			OperationSummary: "",
			OperationID:      "listAppsV1NamespacedControllerRevision",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListAppsV1NamespacedControllerRevisionParams
			Response = ListAppsV1NamespacedControllerRevisionRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListAppsV1NamespacedControllerRevisionParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ListAppsV1NamespacedControllerRevision(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ListAppsV1NamespacedControllerRevision(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListAppsV1NamespacedControllerRevisionResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleListAppsV1NamespacedDaemonSetRequest handles listAppsV1NamespacedDaemonSet operation.
//
// List or watch objects of kind DaemonSet.
//
// GET /apis/apps/v1/namespaces/{namespace}/daemonsets
func (s *Server) handleListAppsV1NamespacedDaemonSetRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listAppsV1NamespacedDaemonSet"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/apps/v1/namespaces/{namespace}/daemonsets"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListAppsV1NamespacedDaemonSet",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListAppsV1NamespacedDaemonSet",
			ID:   "listAppsV1NamespacedDaemonSet",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ListAppsV1NamespacedDaemonSet", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeListAppsV1NamespacedDaemonSetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListAppsV1NamespacedDaemonSetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ListAppsV1NamespacedDaemonSet",
			OperationSummary: "",
			OperationID:      "listAppsV1NamespacedDaemonSet",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListAppsV1NamespacedDaemonSetParams
			Response = ListAppsV1NamespacedDaemonSetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListAppsV1NamespacedDaemonSetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ListAppsV1NamespacedDaemonSet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ListAppsV1NamespacedDaemonSet(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListAppsV1NamespacedDaemonSetResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleListAppsV1NamespacedDeploymentRequest handles listAppsV1NamespacedDeployment operation.
//
// List or watch objects of kind Deployment.
//
// GET /apis/apps/v1/namespaces/{namespace}/deployments
func (s *Server) handleListAppsV1NamespacedDeploymentRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listAppsV1NamespacedDeployment"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/apps/v1/namespaces/{namespace}/deployments"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListAppsV1NamespacedDeployment",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListAppsV1NamespacedDeployment",
			ID:   "listAppsV1NamespacedDeployment",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ListAppsV1NamespacedDeployment", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeListAppsV1NamespacedDeploymentParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListAppsV1NamespacedDeploymentRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ListAppsV1NamespacedDeployment",
			OperationSummary: "",
			OperationID:      "listAppsV1NamespacedDeployment",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListAppsV1NamespacedDeploymentParams
			Response = ListAppsV1NamespacedDeploymentRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListAppsV1NamespacedDeploymentParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ListAppsV1NamespacedDeployment(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ListAppsV1NamespacedDeployment(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListAppsV1NamespacedDeploymentResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleListAppsV1NamespacedReplicaSetRequest handles listAppsV1NamespacedReplicaSet operation.
//
// List or watch objects of kind ReplicaSet.
//
// GET /apis/apps/v1/namespaces/{namespace}/replicasets
func (s *Server) handleListAppsV1NamespacedReplicaSetRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listAppsV1NamespacedReplicaSet"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/apps/v1/namespaces/{namespace}/replicasets"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListAppsV1NamespacedReplicaSet",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListAppsV1NamespacedReplicaSet",
			ID:   "listAppsV1NamespacedReplicaSet",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ListAppsV1NamespacedReplicaSet", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeListAppsV1NamespacedReplicaSetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListAppsV1NamespacedReplicaSetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ListAppsV1NamespacedReplicaSet",
			OperationSummary: "",
			OperationID:      "listAppsV1NamespacedReplicaSet",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListAppsV1NamespacedReplicaSetParams
			Response = ListAppsV1NamespacedReplicaSetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListAppsV1NamespacedReplicaSetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ListAppsV1NamespacedReplicaSet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ListAppsV1NamespacedReplicaSet(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListAppsV1NamespacedReplicaSetResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleListAppsV1NamespacedStatefulSetRequest handles listAppsV1NamespacedStatefulSet operation.
//
// List or watch objects of kind StatefulSet.
//
// GET /apis/apps/v1/namespaces/{namespace}/statefulsets
func (s *Server) handleListAppsV1NamespacedStatefulSetRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listAppsV1NamespacedStatefulSet"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/apps/v1/namespaces/{namespace}/statefulsets"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListAppsV1NamespacedStatefulSet",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListAppsV1NamespacedStatefulSet",
			ID:   "listAppsV1NamespacedStatefulSet",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ListAppsV1NamespacedStatefulSet", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeListAppsV1NamespacedStatefulSetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListAppsV1NamespacedStatefulSetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ListAppsV1NamespacedStatefulSet",
			OperationSummary: "",
			OperationID:      "listAppsV1NamespacedStatefulSet",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListAppsV1NamespacedStatefulSetParams
			Response = ListAppsV1NamespacedStatefulSetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListAppsV1NamespacedStatefulSetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ListAppsV1NamespacedStatefulSet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ListAppsV1NamespacedStatefulSet(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListAppsV1NamespacedStatefulSetResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleListAppsV1ReplicaSetForAllNamespacesRequest handles listAppsV1ReplicaSetForAllNamespaces operation.
//
// List or watch objects of kind ReplicaSet.
//
// GET /apis/apps/v1/replicasets
func (s *Server) handleListAppsV1ReplicaSetForAllNamespacesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listAppsV1ReplicaSetForAllNamespaces"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/apps/v1/replicasets"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListAppsV1ReplicaSetForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListAppsV1ReplicaSetForAllNamespaces",
			ID:   "listAppsV1ReplicaSetForAllNamespaces",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ListAppsV1ReplicaSetForAllNamespaces", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeListAppsV1ReplicaSetForAllNamespacesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListAppsV1ReplicaSetForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ListAppsV1ReplicaSetForAllNamespaces",
			OperationSummary: "",
			OperationID:      "listAppsV1ReplicaSetForAllNamespaces",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListAppsV1ReplicaSetForAllNamespacesParams
			Response = ListAppsV1ReplicaSetForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListAppsV1ReplicaSetForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ListAppsV1ReplicaSetForAllNamespaces(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ListAppsV1ReplicaSetForAllNamespaces(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListAppsV1ReplicaSetForAllNamespacesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleListAppsV1StatefulSetForAllNamespacesRequest handles listAppsV1StatefulSetForAllNamespaces operation.
//
// List or watch objects of kind StatefulSet.
//
// GET /apis/apps/v1/statefulsets
func (s *Server) handleListAppsV1StatefulSetForAllNamespacesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listAppsV1StatefulSetForAllNamespaces"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/apps/v1/statefulsets"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListAppsV1StatefulSetForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListAppsV1StatefulSetForAllNamespaces",
			ID:   "listAppsV1StatefulSetForAllNamespaces",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ListAppsV1StatefulSetForAllNamespaces", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeListAppsV1StatefulSetForAllNamespacesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListAppsV1StatefulSetForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ListAppsV1StatefulSetForAllNamespaces",
			OperationSummary: "",
			OperationID:      "listAppsV1StatefulSetForAllNamespaces",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListAppsV1StatefulSetForAllNamespacesParams
			Response = ListAppsV1StatefulSetForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListAppsV1StatefulSetForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ListAppsV1StatefulSetForAllNamespaces(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ListAppsV1StatefulSetForAllNamespaces(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListAppsV1StatefulSetForAllNamespacesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleListAutoscalingV1HorizontalPodAutoscalerForAllNamespacesRequest handles listAutoscalingV1HorizontalPodAutoscalerForAllNamespaces operation.
//
// List or watch objects of kind HorizontalPodAutoscaler.
//
// GET /apis/autoscaling/v1/horizontalpodautoscalers
func (s *Server) handleListAutoscalingV1HorizontalPodAutoscalerForAllNamespacesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listAutoscalingV1HorizontalPodAutoscalerForAllNamespaces"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/autoscaling/v1/horizontalpodautoscalers"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListAutoscalingV1HorizontalPodAutoscalerForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListAutoscalingV1HorizontalPodAutoscalerForAllNamespaces",
			ID:   "listAutoscalingV1HorizontalPodAutoscalerForAllNamespaces",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ListAutoscalingV1HorizontalPodAutoscalerForAllNamespaces", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeListAutoscalingV1HorizontalPodAutoscalerForAllNamespacesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListAutoscalingV1HorizontalPodAutoscalerForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ListAutoscalingV1HorizontalPodAutoscalerForAllNamespaces",
			OperationSummary: "",
			OperationID:      "listAutoscalingV1HorizontalPodAutoscalerForAllNamespaces",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListAutoscalingV1HorizontalPodAutoscalerForAllNamespacesParams
			Response = ListAutoscalingV1HorizontalPodAutoscalerForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListAutoscalingV1HorizontalPodAutoscalerForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ListAutoscalingV1HorizontalPodAutoscalerForAllNamespaces(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ListAutoscalingV1HorizontalPodAutoscalerForAllNamespaces(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListAutoscalingV1HorizontalPodAutoscalerForAllNamespacesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleListAutoscalingV1NamespacedHorizontalPodAutoscalerRequest handles listAutoscalingV1NamespacedHorizontalPodAutoscaler operation.
//
// List or watch objects of kind HorizontalPodAutoscaler.
//
// GET /apis/autoscaling/v1/namespaces/{namespace}/horizontalpodautoscalers
func (s *Server) handleListAutoscalingV1NamespacedHorizontalPodAutoscalerRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listAutoscalingV1NamespacedHorizontalPodAutoscaler"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/autoscaling/v1/namespaces/{namespace}/horizontalpodautoscalers"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListAutoscalingV1NamespacedHorizontalPodAutoscaler",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListAutoscalingV1NamespacedHorizontalPodAutoscaler",
			ID:   "listAutoscalingV1NamespacedHorizontalPodAutoscaler",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ListAutoscalingV1NamespacedHorizontalPodAutoscaler", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeListAutoscalingV1NamespacedHorizontalPodAutoscalerParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListAutoscalingV1NamespacedHorizontalPodAutoscalerRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ListAutoscalingV1NamespacedHorizontalPodAutoscaler",
			OperationSummary: "",
			OperationID:      "listAutoscalingV1NamespacedHorizontalPodAutoscaler",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListAutoscalingV1NamespacedHorizontalPodAutoscalerParams
			Response = ListAutoscalingV1NamespacedHorizontalPodAutoscalerRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListAutoscalingV1NamespacedHorizontalPodAutoscalerParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ListAutoscalingV1NamespacedHorizontalPodAutoscaler(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ListAutoscalingV1NamespacedHorizontalPodAutoscaler(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListAutoscalingV1NamespacedHorizontalPodAutoscalerResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleListAutoscalingV2beta1HorizontalPodAutoscalerForAllNamespacesRequest handles listAutoscalingV2beta1HorizontalPodAutoscalerForAllNamespaces operation.
//
// List or watch objects of kind HorizontalPodAutoscaler.
//
// GET /apis/autoscaling/v2beta1/horizontalpodautoscalers
func (s *Server) handleListAutoscalingV2beta1HorizontalPodAutoscalerForAllNamespacesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listAutoscalingV2beta1HorizontalPodAutoscalerForAllNamespaces"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/autoscaling/v2beta1/horizontalpodautoscalers"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListAutoscalingV2beta1HorizontalPodAutoscalerForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListAutoscalingV2beta1HorizontalPodAutoscalerForAllNamespaces",
			ID:   "listAutoscalingV2beta1HorizontalPodAutoscalerForAllNamespaces",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ListAutoscalingV2beta1HorizontalPodAutoscalerForAllNamespaces", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeListAutoscalingV2beta1HorizontalPodAutoscalerForAllNamespacesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListAutoscalingV2beta1HorizontalPodAutoscalerForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ListAutoscalingV2beta1HorizontalPodAutoscalerForAllNamespaces",
			OperationSummary: "",
			OperationID:      "listAutoscalingV2beta1HorizontalPodAutoscalerForAllNamespaces",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListAutoscalingV2beta1HorizontalPodAutoscalerForAllNamespacesParams
			Response = ListAutoscalingV2beta1HorizontalPodAutoscalerForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListAutoscalingV2beta1HorizontalPodAutoscalerForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ListAutoscalingV2beta1HorizontalPodAutoscalerForAllNamespaces(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ListAutoscalingV2beta1HorizontalPodAutoscalerForAllNamespaces(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListAutoscalingV2beta1HorizontalPodAutoscalerForAllNamespacesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleListAutoscalingV2beta1NamespacedHorizontalPodAutoscalerRequest handles listAutoscalingV2beta1NamespacedHorizontalPodAutoscaler operation.
//
// List or watch objects of kind HorizontalPodAutoscaler.
//
// GET /apis/autoscaling/v2beta1/namespaces/{namespace}/horizontalpodautoscalers
func (s *Server) handleListAutoscalingV2beta1NamespacedHorizontalPodAutoscalerRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listAutoscalingV2beta1NamespacedHorizontalPodAutoscaler"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/autoscaling/v2beta1/namespaces/{namespace}/horizontalpodautoscalers"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListAutoscalingV2beta1NamespacedHorizontalPodAutoscaler",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListAutoscalingV2beta1NamespacedHorizontalPodAutoscaler",
			ID:   "listAutoscalingV2beta1NamespacedHorizontalPodAutoscaler",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ListAutoscalingV2beta1NamespacedHorizontalPodAutoscaler", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeListAutoscalingV2beta1NamespacedHorizontalPodAutoscalerParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListAutoscalingV2beta1NamespacedHorizontalPodAutoscalerRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ListAutoscalingV2beta1NamespacedHorizontalPodAutoscaler",
			OperationSummary: "",
			OperationID:      "listAutoscalingV2beta1NamespacedHorizontalPodAutoscaler",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListAutoscalingV2beta1NamespacedHorizontalPodAutoscalerParams
			Response = ListAutoscalingV2beta1NamespacedHorizontalPodAutoscalerRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListAutoscalingV2beta1NamespacedHorizontalPodAutoscalerParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ListAutoscalingV2beta1NamespacedHorizontalPodAutoscaler(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ListAutoscalingV2beta1NamespacedHorizontalPodAutoscaler(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListAutoscalingV2beta1NamespacedHorizontalPodAutoscalerResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleListAutoscalingV2beta2HorizontalPodAutoscalerForAllNamespacesRequest handles listAutoscalingV2beta2HorizontalPodAutoscalerForAllNamespaces operation.
//
// List or watch objects of kind HorizontalPodAutoscaler.
//
// GET /apis/autoscaling/v2beta2/horizontalpodautoscalers
func (s *Server) handleListAutoscalingV2beta2HorizontalPodAutoscalerForAllNamespacesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listAutoscalingV2beta2HorizontalPodAutoscalerForAllNamespaces"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/autoscaling/v2beta2/horizontalpodautoscalers"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListAutoscalingV2beta2HorizontalPodAutoscalerForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListAutoscalingV2beta2HorizontalPodAutoscalerForAllNamespaces",
			ID:   "listAutoscalingV2beta2HorizontalPodAutoscalerForAllNamespaces",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ListAutoscalingV2beta2HorizontalPodAutoscalerForAllNamespaces", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeListAutoscalingV2beta2HorizontalPodAutoscalerForAllNamespacesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListAutoscalingV2beta2HorizontalPodAutoscalerForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ListAutoscalingV2beta2HorizontalPodAutoscalerForAllNamespaces",
			OperationSummary: "",
			OperationID:      "listAutoscalingV2beta2HorizontalPodAutoscalerForAllNamespaces",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListAutoscalingV2beta2HorizontalPodAutoscalerForAllNamespacesParams
			Response = ListAutoscalingV2beta2HorizontalPodAutoscalerForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListAutoscalingV2beta2HorizontalPodAutoscalerForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ListAutoscalingV2beta2HorizontalPodAutoscalerForAllNamespaces(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ListAutoscalingV2beta2HorizontalPodAutoscalerForAllNamespaces(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListAutoscalingV2beta2HorizontalPodAutoscalerForAllNamespacesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleListAutoscalingV2beta2NamespacedHorizontalPodAutoscalerRequest handles listAutoscalingV2beta2NamespacedHorizontalPodAutoscaler operation.
//
// List or watch objects of kind HorizontalPodAutoscaler.
//
// GET /apis/autoscaling/v2beta2/namespaces/{namespace}/horizontalpodautoscalers
func (s *Server) handleListAutoscalingV2beta2NamespacedHorizontalPodAutoscalerRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listAutoscalingV2beta2NamespacedHorizontalPodAutoscaler"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/autoscaling/v2beta2/namespaces/{namespace}/horizontalpodautoscalers"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListAutoscalingV2beta2NamespacedHorizontalPodAutoscaler",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListAutoscalingV2beta2NamespacedHorizontalPodAutoscaler",
			ID:   "listAutoscalingV2beta2NamespacedHorizontalPodAutoscaler",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ListAutoscalingV2beta2NamespacedHorizontalPodAutoscaler", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeListAutoscalingV2beta2NamespacedHorizontalPodAutoscalerParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListAutoscalingV2beta2NamespacedHorizontalPodAutoscalerRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ListAutoscalingV2beta2NamespacedHorizontalPodAutoscaler",
			OperationSummary: "",
			OperationID:      "listAutoscalingV2beta2NamespacedHorizontalPodAutoscaler",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListAutoscalingV2beta2NamespacedHorizontalPodAutoscalerParams
			Response = ListAutoscalingV2beta2NamespacedHorizontalPodAutoscalerRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListAutoscalingV2beta2NamespacedHorizontalPodAutoscalerParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ListAutoscalingV2beta2NamespacedHorizontalPodAutoscaler(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ListAutoscalingV2beta2NamespacedHorizontalPodAutoscaler(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListAutoscalingV2beta2NamespacedHorizontalPodAutoscalerResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleListBatchV1CronJobForAllNamespacesRequest handles listBatchV1CronJobForAllNamespaces operation.
//
// List or watch objects of kind CronJob.
//
// GET /apis/batch/v1/cronjobs
func (s *Server) handleListBatchV1CronJobForAllNamespacesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listBatchV1CronJobForAllNamespaces"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/batch/v1/cronjobs"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListBatchV1CronJobForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListBatchV1CronJobForAllNamespaces",
			ID:   "listBatchV1CronJobForAllNamespaces",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ListBatchV1CronJobForAllNamespaces", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeListBatchV1CronJobForAllNamespacesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListBatchV1CronJobForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ListBatchV1CronJobForAllNamespaces",
			OperationSummary: "",
			OperationID:      "listBatchV1CronJobForAllNamespaces",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListBatchV1CronJobForAllNamespacesParams
			Response = ListBatchV1CronJobForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListBatchV1CronJobForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ListBatchV1CronJobForAllNamespaces(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ListBatchV1CronJobForAllNamespaces(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListBatchV1CronJobForAllNamespacesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleListBatchV1JobForAllNamespacesRequest handles listBatchV1JobForAllNamespaces operation.
//
// List or watch objects of kind Job.
//
// GET /apis/batch/v1/jobs
func (s *Server) handleListBatchV1JobForAllNamespacesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listBatchV1JobForAllNamespaces"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/batch/v1/jobs"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListBatchV1JobForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListBatchV1JobForAllNamespaces",
			ID:   "listBatchV1JobForAllNamespaces",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ListBatchV1JobForAllNamespaces", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeListBatchV1JobForAllNamespacesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListBatchV1JobForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ListBatchV1JobForAllNamespaces",
			OperationSummary: "",
			OperationID:      "listBatchV1JobForAllNamespaces",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListBatchV1JobForAllNamespacesParams
			Response = ListBatchV1JobForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListBatchV1JobForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ListBatchV1JobForAllNamespaces(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ListBatchV1JobForAllNamespaces(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListBatchV1JobForAllNamespacesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleListBatchV1NamespacedCronJobRequest handles listBatchV1NamespacedCronJob operation.
//
// List or watch objects of kind CronJob.
//
// GET /apis/batch/v1/namespaces/{namespace}/cronjobs
func (s *Server) handleListBatchV1NamespacedCronJobRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listBatchV1NamespacedCronJob"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/batch/v1/namespaces/{namespace}/cronjobs"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListBatchV1NamespacedCronJob",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListBatchV1NamespacedCronJob",
			ID:   "listBatchV1NamespacedCronJob",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ListBatchV1NamespacedCronJob", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeListBatchV1NamespacedCronJobParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListBatchV1NamespacedCronJobRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ListBatchV1NamespacedCronJob",
			OperationSummary: "",
			OperationID:      "listBatchV1NamespacedCronJob",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListBatchV1NamespacedCronJobParams
			Response = ListBatchV1NamespacedCronJobRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListBatchV1NamespacedCronJobParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ListBatchV1NamespacedCronJob(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ListBatchV1NamespacedCronJob(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListBatchV1NamespacedCronJobResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleListBatchV1NamespacedJobRequest handles listBatchV1NamespacedJob operation.
//
// List or watch objects of kind Job.
//
// GET /apis/batch/v1/namespaces/{namespace}/jobs
func (s *Server) handleListBatchV1NamespacedJobRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listBatchV1NamespacedJob"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/batch/v1/namespaces/{namespace}/jobs"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListBatchV1NamespacedJob",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListBatchV1NamespacedJob",
			ID:   "listBatchV1NamespacedJob",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ListBatchV1NamespacedJob", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeListBatchV1NamespacedJobParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListBatchV1NamespacedJobRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ListBatchV1NamespacedJob",
			OperationSummary: "",
			OperationID:      "listBatchV1NamespacedJob",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListBatchV1NamespacedJobParams
			Response = ListBatchV1NamespacedJobRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListBatchV1NamespacedJobParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ListBatchV1NamespacedJob(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ListBatchV1NamespacedJob(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListBatchV1NamespacedJobResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleListBatchV1beta1CronJobForAllNamespacesRequest handles listBatchV1beta1CronJobForAllNamespaces operation.
//
// List or watch objects of kind CronJob.
//
// GET /apis/batch/v1beta1/cronjobs
func (s *Server) handleListBatchV1beta1CronJobForAllNamespacesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listBatchV1beta1CronJobForAllNamespaces"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/batch/v1beta1/cronjobs"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListBatchV1beta1CronJobForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListBatchV1beta1CronJobForAllNamespaces",
			ID:   "listBatchV1beta1CronJobForAllNamespaces",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ListBatchV1beta1CronJobForAllNamespaces", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeListBatchV1beta1CronJobForAllNamespacesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListBatchV1beta1CronJobForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ListBatchV1beta1CronJobForAllNamespaces",
			OperationSummary: "",
			OperationID:      "listBatchV1beta1CronJobForAllNamespaces",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListBatchV1beta1CronJobForAllNamespacesParams
			Response = ListBatchV1beta1CronJobForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListBatchV1beta1CronJobForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ListBatchV1beta1CronJobForAllNamespaces(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ListBatchV1beta1CronJobForAllNamespaces(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListBatchV1beta1CronJobForAllNamespacesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleListBatchV1beta1NamespacedCronJobRequest handles listBatchV1beta1NamespacedCronJob operation.
//
// List or watch objects of kind CronJob.
//
// GET /apis/batch/v1beta1/namespaces/{namespace}/cronjobs
func (s *Server) handleListBatchV1beta1NamespacedCronJobRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listBatchV1beta1NamespacedCronJob"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/batch/v1beta1/namespaces/{namespace}/cronjobs"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListBatchV1beta1NamespacedCronJob",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListBatchV1beta1NamespacedCronJob",
			ID:   "listBatchV1beta1NamespacedCronJob",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ListBatchV1beta1NamespacedCronJob", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeListBatchV1beta1NamespacedCronJobParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListBatchV1beta1NamespacedCronJobRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ListBatchV1beta1NamespacedCronJob",
			OperationSummary: "",
			OperationID:      "listBatchV1beta1NamespacedCronJob",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListBatchV1beta1NamespacedCronJobParams
			Response = ListBatchV1beta1NamespacedCronJobRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListBatchV1beta1NamespacedCronJobParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ListBatchV1beta1NamespacedCronJob(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ListBatchV1beta1NamespacedCronJob(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListBatchV1beta1NamespacedCronJobResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleListCertificatesV1CertificateSigningRequestRequest handles listCertificatesV1CertificateSigningRequest operation.
//
// List or watch objects of kind CertificateSigningRequest.
//
// GET /apis/certificates.k8s.io/v1/certificatesigningrequests
func (s *Server) handleListCertificatesV1CertificateSigningRequestRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listCertificatesV1CertificateSigningRequest"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/certificates.k8s.io/v1/certificatesigningrequests"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListCertificatesV1CertificateSigningRequest",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListCertificatesV1CertificateSigningRequest",
			ID:   "listCertificatesV1CertificateSigningRequest",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ListCertificatesV1CertificateSigningRequest", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeListCertificatesV1CertificateSigningRequestParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListCertificatesV1CertificateSigningRequestRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ListCertificatesV1CertificateSigningRequest",
			OperationSummary: "",
			OperationID:      "listCertificatesV1CertificateSigningRequest",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListCertificatesV1CertificateSigningRequestParams
			Response = ListCertificatesV1CertificateSigningRequestRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListCertificatesV1CertificateSigningRequestParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ListCertificatesV1CertificateSigningRequest(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ListCertificatesV1CertificateSigningRequest(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListCertificatesV1CertificateSigningRequestResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleListCoordinationV1LeaseForAllNamespacesRequest handles listCoordinationV1LeaseForAllNamespaces operation.
//
// List or watch objects of kind Lease.
//
// GET /apis/coordination.k8s.io/v1/leases
func (s *Server) handleListCoordinationV1LeaseForAllNamespacesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listCoordinationV1LeaseForAllNamespaces"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/coordination.k8s.io/v1/leases"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListCoordinationV1LeaseForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListCoordinationV1LeaseForAllNamespaces",
			ID:   "listCoordinationV1LeaseForAllNamespaces",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ListCoordinationV1LeaseForAllNamespaces", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeListCoordinationV1LeaseForAllNamespacesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListCoordinationV1LeaseForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ListCoordinationV1LeaseForAllNamespaces",
			OperationSummary: "",
			OperationID:      "listCoordinationV1LeaseForAllNamespaces",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListCoordinationV1LeaseForAllNamespacesParams
			Response = ListCoordinationV1LeaseForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListCoordinationV1LeaseForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ListCoordinationV1LeaseForAllNamespaces(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ListCoordinationV1LeaseForAllNamespaces(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListCoordinationV1LeaseForAllNamespacesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleListCoordinationV1NamespacedLeaseRequest handles listCoordinationV1NamespacedLease operation.
//
// List or watch objects of kind Lease.
//
// GET /apis/coordination.k8s.io/v1/namespaces/{namespace}/leases
func (s *Server) handleListCoordinationV1NamespacedLeaseRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listCoordinationV1NamespacedLease"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/coordination.k8s.io/v1/namespaces/{namespace}/leases"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListCoordinationV1NamespacedLease",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListCoordinationV1NamespacedLease",
			ID:   "listCoordinationV1NamespacedLease",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ListCoordinationV1NamespacedLease", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeListCoordinationV1NamespacedLeaseParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListCoordinationV1NamespacedLeaseRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ListCoordinationV1NamespacedLease",
			OperationSummary: "",
			OperationID:      "listCoordinationV1NamespacedLease",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListCoordinationV1NamespacedLeaseParams
			Response = ListCoordinationV1NamespacedLeaseRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListCoordinationV1NamespacedLeaseParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ListCoordinationV1NamespacedLease(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ListCoordinationV1NamespacedLease(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListCoordinationV1NamespacedLeaseResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleListCoreV1ComponentStatusRequest handles listCoreV1ComponentStatus operation.
//
// List objects of kind ComponentStatus.
//
// GET /api/v1/componentstatuses
func (s *Server) handleListCoreV1ComponentStatusRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listCoreV1ComponentStatus"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/v1/componentstatuses"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListCoreV1ComponentStatus",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListCoreV1ComponentStatus",
			ID:   "listCoreV1ComponentStatus",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ListCoreV1ComponentStatus", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeListCoreV1ComponentStatusParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListCoreV1ComponentStatusRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ListCoreV1ComponentStatus",
			OperationSummary: "",
			OperationID:      "listCoreV1ComponentStatus",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListCoreV1ComponentStatusParams
			Response = ListCoreV1ComponentStatusRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListCoreV1ComponentStatusParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ListCoreV1ComponentStatus(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ListCoreV1ComponentStatus(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListCoreV1ComponentStatusResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleListCoreV1ConfigMapForAllNamespacesRequest handles listCoreV1ConfigMapForAllNamespaces operation.
//
// List or watch objects of kind ConfigMap.
//
// GET /api/v1/configmaps
func (s *Server) handleListCoreV1ConfigMapForAllNamespacesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listCoreV1ConfigMapForAllNamespaces"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/v1/configmaps"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListCoreV1ConfigMapForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListCoreV1ConfigMapForAllNamespaces",
			ID:   "listCoreV1ConfigMapForAllNamespaces",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ListCoreV1ConfigMapForAllNamespaces", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeListCoreV1ConfigMapForAllNamespacesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListCoreV1ConfigMapForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ListCoreV1ConfigMapForAllNamespaces",
			OperationSummary: "",
			OperationID:      "listCoreV1ConfigMapForAllNamespaces",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListCoreV1ConfigMapForAllNamespacesParams
			Response = ListCoreV1ConfigMapForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListCoreV1ConfigMapForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ListCoreV1ConfigMapForAllNamespaces(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ListCoreV1ConfigMapForAllNamespaces(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListCoreV1ConfigMapForAllNamespacesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleListCoreV1EndpointsForAllNamespacesRequest handles listCoreV1EndpointsForAllNamespaces operation.
//
// List or watch objects of kind Endpoints.
//
// GET /api/v1/endpoints
func (s *Server) handleListCoreV1EndpointsForAllNamespacesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listCoreV1EndpointsForAllNamespaces"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/v1/endpoints"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListCoreV1EndpointsForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListCoreV1EndpointsForAllNamespaces",
			ID:   "listCoreV1EndpointsForAllNamespaces",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ListCoreV1EndpointsForAllNamespaces", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeListCoreV1EndpointsForAllNamespacesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListCoreV1EndpointsForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ListCoreV1EndpointsForAllNamespaces",
			OperationSummary: "",
			OperationID:      "listCoreV1EndpointsForAllNamespaces",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListCoreV1EndpointsForAllNamespacesParams
			Response = ListCoreV1EndpointsForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListCoreV1EndpointsForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ListCoreV1EndpointsForAllNamespaces(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ListCoreV1EndpointsForAllNamespaces(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListCoreV1EndpointsForAllNamespacesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleListCoreV1EventForAllNamespacesRequest handles listCoreV1EventForAllNamespaces operation.
//
// List or watch objects of kind Event.
//
// GET /api/v1/events
func (s *Server) handleListCoreV1EventForAllNamespacesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listCoreV1EventForAllNamespaces"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/v1/events"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListCoreV1EventForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListCoreV1EventForAllNamespaces",
			ID:   "listCoreV1EventForAllNamespaces",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ListCoreV1EventForAllNamespaces", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeListCoreV1EventForAllNamespacesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListCoreV1EventForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ListCoreV1EventForAllNamespaces",
			OperationSummary: "",
			OperationID:      "listCoreV1EventForAllNamespaces",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListCoreV1EventForAllNamespacesParams
			Response = ListCoreV1EventForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListCoreV1EventForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ListCoreV1EventForAllNamespaces(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ListCoreV1EventForAllNamespaces(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListCoreV1EventForAllNamespacesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleListCoreV1LimitRangeForAllNamespacesRequest handles listCoreV1LimitRangeForAllNamespaces operation.
//
// List or watch objects of kind LimitRange.
//
// GET /api/v1/limitranges
func (s *Server) handleListCoreV1LimitRangeForAllNamespacesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listCoreV1LimitRangeForAllNamespaces"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/v1/limitranges"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListCoreV1LimitRangeForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListCoreV1LimitRangeForAllNamespaces",
			ID:   "listCoreV1LimitRangeForAllNamespaces",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ListCoreV1LimitRangeForAllNamespaces", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeListCoreV1LimitRangeForAllNamespacesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListCoreV1LimitRangeForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ListCoreV1LimitRangeForAllNamespaces",
			OperationSummary: "",
			OperationID:      "listCoreV1LimitRangeForAllNamespaces",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListCoreV1LimitRangeForAllNamespacesParams
			Response = ListCoreV1LimitRangeForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListCoreV1LimitRangeForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ListCoreV1LimitRangeForAllNamespaces(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ListCoreV1LimitRangeForAllNamespaces(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListCoreV1LimitRangeForAllNamespacesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleListCoreV1NamespaceRequest handles listCoreV1Namespace operation.
//
// List or watch objects of kind Namespace.
//
// GET /api/v1/namespaces
func (s *Server) handleListCoreV1NamespaceRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listCoreV1Namespace"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/v1/namespaces"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListCoreV1Namespace",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListCoreV1Namespace",
			ID:   "listCoreV1Namespace",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ListCoreV1Namespace", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeListCoreV1NamespaceParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListCoreV1NamespaceRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ListCoreV1Namespace",
			OperationSummary: "",
			OperationID:      "listCoreV1Namespace",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListCoreV1NamespaceParams
			Response = ListCoreV1NamespaceRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListCoreV1NamespaceParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ListCoreV1Namespace(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ListCoreV1Namespace(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListCoreV1NamespaceResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleListCoreV1NamespacedConfigMapRequest handles listCoreV1NamespacedConfigMap operation.
//
// List or watch objects of kind ConfigMap.
//
// GET /api/v1/namespaces/{namespace}/configmaps
func (s *Server) handleListCoreV1NamespacedConfigMapRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listCoreV1NamespacedConfigMap"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/v1/namespaces/{namespace}/configmaps"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListCoreV1NamespacedConfigMap",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListCoreV1NamespacedConfigMap",
			ID:   "listCoreV1NamespacedConfigMap",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ListCoreV1NamespacedConfigMap", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeListCoreV1NamespacedConfigMapParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListCoreV1NamespacedConfigMapRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ListCoreV1NamespacedConfigMap",
			OperationSummary: "",
			OperationID:      "listCoreV1NamespacedConfigMap",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListCoreV1NamespacedConfigMapParams
			Response = ListCoreV1NamespacedConfigMapRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListCoreV1NamespacedConfigMapParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ListCoreV1NamespacedConfigMap(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ListCoreV1NamespacedConfigMap(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListCoreV1NamespacedConfigMapResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleListCoreV1NamespacedEndpointsRequest handles listCoreV1NamespacedEndpoints operation.
//
// List or watch objects of kind Endpoints.
//
// GET /api/v1/namespaces/{namespace}/endpoints
func (s *Server) handleListCoreV1NamespacedEndpointsRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listCoreV1NamespacedEndpoints"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/v1/namespaces/{namespace}/endpoints"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListCoreV1NamespacedEndpoints",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListCoreV1NamespacedEndpoints",
			ID:   "listCoreV1NamespacedEndpoints",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ListCoreV1NamespacedEndpoints", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeListCoreV1NamespacedEndpointsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListCoreV1NamespacedEndpointsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ListCoreV1NamespacedEndpoints",
			OperationSummary: "",
			OperationID:      "listCoreV1NamespacedEndpoints",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListCoreV1NamespacedEndpointsParams
			Response = ListCoreV1NamespacedEndpointsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListCoreV1NamespacedEndpointsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ListCoreV1NamespacedEndpoints(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ListCoreV1NamespacedEndpoints(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListCoreV1NamespacedEndpointsResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleListCoreV1NamespacedEventRequest handles listCoreV1NamespacedEvent operation.
//
// List or watch objects of kind Event.
//
// GET /api/v1/namespaces/{namespace}/events
func (s *Server) handleListCoreV1NamespacedEventRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listCoreV1NamespacedEvent"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/v1/namespaces/{namespace}/events"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListCoreV1NamespacedEvent",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListCoreV1NamespacedEvent",
			ID:   "listCoreV1NamespacedEvent",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ListCoreV1NamespacedEvent", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeListCoreV1NamespacedEventParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListCoreV1NamespacedEventRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ListCoreV1NamespacedEvent",
			OperationSummary: "",
			OperationID:      "listCoreV1NamespacedEvent",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListCoreV1NamespacedEventParams
			Response = ListCoreV1NamespacedEventRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListCoreV1NamespacedEventParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ListCoreV1NamespacedEvent(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ListCoreV1NamespacedEvent(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListCoreV1NamespacedEventResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleListCoreV1NamespacedLimitRangeRequest handles listCoreV1NamespacedLimitRange operation.
//
// List or watch objects of kind LimitRange.
//
// GET /api/v1/namespaces/{namespace}/limitranges
func (s *Server) handleListCoreV1NamespacedLimitRangeRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listCoreV1NamespacedLimitRange"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/v1/namespaces/{namespace}/limitranges"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListCoreV1NamespacedLimitRange",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListCoreV1NamespacedLimitRange",
			ID:   "listCoreV1NamespacedLimitRange",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ListCoreV1NamespacedLimitRange", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeListCoreV1NamespacedLimitRangeParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListCoreV1NamespacedLimitRangeRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ListCoreV1NamespacedLimitRange",
			OperationSummary: "",
			OperationID:      "listCoreV1NamespacedLimitRange",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListCoreV1NamespacedLimitRangeParams
			Response = ListCoreV1NamespacedLimitRangeRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListCoreV1NamespacedLimitRangeParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ListCoreV1NamespacedLimitRange(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ListCoreV1NamespacedLimitRange(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListCoreV1NamespacedLimitRangeResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleListCoreV1NamespacedPersistentVolumeClaimRequest handles listCoreV1NamespacedPersistentVolumeClaim operation.
//
// List or watch objects of kind PersistentVolumeClaim.
//
// GET /api/v1/namespaces/{namespace}/persistentvolumeclaims
func (s *Server) handleListCoreV1NamespacedPersistentVolumeClaimRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listCoreV1NamespacedPersistentVolumeClaim"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/v1/namespaces/{namespace}/persistentvolumeclaims"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListCoreV1NamespacedPersistentVolumeClaim",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListCoreV1NamespacedPersistentVolumeClaim",
			ID:   "listCoreV1NamespacedPersistentVolumeClaim",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ListCoreV1NamespacedPersistentVolumeClaim", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeListCoreV1NamespacedPersistentVolumeClaimParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListCoreV1NamespacedPersistentVolumeClaimRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ListCoreV1NamespacedPersistentVolumeClaim",
			OperationSummary: "",
			OperationID:      "listCoreV1NamespacedPersistentVolumeClaim",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListCoreV1NamespacedPersistentVolumeClaimParams
			Response = ListCoreV1NamespacedPersistentVolumeClaimRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListCoreV1NamespacedPersistentVolumeClaimParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ListCoreV1NamespacedPersistentVolumeClaim(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ListCoreV1NamespacedPersistentVolumeClaim(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListCoreV1NamespacedPersistentVolumeClaimResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleListCoreV1NamespacedPodRequest handles listCoreV1NamespacedPod operation.
//
// List or watch objects of kind Pod.
//
// GET /api/v1/namespaces/{namespace}/pods
func (s *Server) handleListCoreV1NamespacedPodRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listCoreV1NamespacedPod"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/v1/namespaces/{namespace}/pods"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListCoreV1NamespacedPod",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListCoreV1NamespacedPod",
			ID:   "listCoreV1NamespacedPod",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ListCoreV1NamespacedPod", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeListCoreV1NamespacedPodParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListCoreV1NamespacedPodRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ListCoreV1NamespacedPod",
			OperationSummary: "",
			OperationID:      "listCoreV1NamespacedPod",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListCoreV1NamespacedPodParams
			Response = ListCoreV1NamespacedPodRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListCoreV1NamespacedPodParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ListCoreV1NamespacedPod(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ListCoreV1NamespacedPod(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListCoreV1NamespacedPodResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleListCoreV1NamespacedPodTemplateRequest handles listCoreV1NamespacedPodTemplate operation.
//
// List or watch objects of kind PodTemplate.
//
// GET /api/v1/namespaces/{namespace}/podtemplates
func (s *Server) handleListCoreV1NamespacedPodTemplateRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listCoreV1NamespacedPodTemplate"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/v1/namespaces/{namespace}/podtemplates"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListCoreV1NamespacedPodTemplate",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListCoreV1NamespacedPodTemplate",
			ID:   "listCoreV1NamespacedPodTemplate",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ListCoreV1NamespacedPodTemplate", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeListCoreV1NamespacedPodTemplateParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListCoreV1NamespacedPodTemplateRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ListCoreV1NamespacedPodTemplate",
			OperationSummary: "",
			OperationID:      "listCoreV1NamespacedPodTemplate",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListCoreV1NamespacedPodTemplateParams
			Response = ListCoreV1NamespacedPodTemplateRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListCoreV1NamespacedPodTemplateParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ListCoreV1NamespacedPodTemplate(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ListCoreV1NamespacedPodTemplate(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListCoreV1NamespacedPodTemplateResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleListCoreV1NamespacedReplicationControllerRequest handles listCoreV1NamespacedReplicationController operation.
//
// List or watch objects of kind ReplicationController.
//
// GET /api/v1/namespaces/{namespace}/replicationcontrollers
func (s *Server) handleListCoreV1NamespacedReplicationControllerRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listCoreV1NamespacedReplicationController"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/v1/namespaces/{namespace}/replicationcontrollers"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListCoreV1NamespacedReplicationController",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListCoreV1NamespacedReplicationController",
			ID:   "listCoreV1NamespacedReplicationController",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ListCoreV1NamespacedReplicationController", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeListCoreV1NamespacedReplicationControllerParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListCoreV1NamespacedReplicationControllerRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ListCoreV1NamespacedReplicationController",
			OperationSummary: "",
			OperationID:      "listCoreV1NamespacedReplicationController",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListCoreV1NamespacedReplicationControllerParams
			Response = ListCoreV1NamespacedReplicationControllerRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListCoreV1NamespacedReplicationControllerParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ListCoreV1NamespacedReplicationController(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ListCoreV1NamespacedReplicationController(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListCoreV1NamespacedReplicationControllerResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleListCoreV1NamespacedResourceQuotaRequest handles listCoreV1NamespacedResourceQuota operation.
//
// List or watch objects of kind ResourceQuota.
//
// GET /api/v1/namespaces/{namespace}/resourcequotas
func (s *Server) handleListCoreV1NamespacedResourceQuotaRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listCoreV1NamespacedResourceQuota"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/v1/namespaces/{namespace}/resourcequotas"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListCoreV1NamespacedResourceQuota",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListCoreV1NamespacedResourceQuota",
			ID:   "listCoreV1NamespacedResourceQuota",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ListCoreV1NamespacedResourceQuota", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeListCoreV1NamespacedResourceQuotaParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListCoreV1NamespacedResourceQuotaRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ListCoreV1NamespacedResourceQuota",
			OperationSummary: "",
			OperationID:      "listCoreV1NamespacedResourceQuota",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListCoreV1NamespacedResourceQuotaParams
			Response = ListCoreV1NamespacedResourceQuotaRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListCoreV1NamespacedResourceQuotaParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ListCoreV1NamespacedResourceQuota(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ListCoreV1NamespacedResourceQuota(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListCoreV1NamespacedResourceQuotaResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleListCoreV1NamespacedSecretRequest handles listCoreV1NamespacedSecret operation.
//
// List or watch objects of kind Secret.
//
// GET /api/v1/namespaces/{namespace}/secrets
func (s *Server) handleListCoreV1NamespacedSecretRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listCoreV1NamespacedSecret"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/v1/namespaces/{namespace}/secrets"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListCoreV1NamespacedSecret",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListCoreV1NamespacedSecret",
			ID:   "listCoreV1NamespacedSecret",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ListCoreV1NamespacedSecret", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeListCoreV1NamespacedSecretParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListCoreV1NamespacedSecretRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ListCoreV1NamespacedSecret",
			OperationSummary: "",
			OperationID:      "listCoreV1NamespacedSecret",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListCoreV1NamespacedSecretParams
			Response = ListCoreV1NamespacedSecretRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListCoreV1NamespacedSecretParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ListCoreV1NamespacedSecret(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ListCoreV1NamespacedSecret(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListCoreV1NamespacedSecretResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleListCoreV1NamespacedServiceRequest handles listCoreV1NamespacedService operation.
//
// List or watch objects of kind Service.
//
// GET /api/v1/namespaces/{namespace}/services
func (s *Server) handleListCoreV1NamespacedServiceRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listCoreV1NamespacedService"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/v1/namespaces/{namespace}/services"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListCoreV1NamespacedService",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListCoreV1NamespacedService",
			ID:   "listCoreV1NamespacedService",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ListCoreV1NamespacedService", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeListCoreV1NamespacedServiceParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListCoreV1NamespacedServiceRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ListCoreV1NamespacedService",
			OperationSummary: "",
			OperationID:      "listCoreV1NamespacedService",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListCoreV1NamespacedServiceParams
			Response = ListCoreV1NamespacedServiceRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListCoreV1NamespacedServiceParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ListCoreV1NamespacedService(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ListCoreV1NamespacedService(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListCoreV1NamespacedServiceResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleListCoreV1NamespacedServiceAccountRequest handles listCoreV1NamespacedServiceAccount operation.
//
// List or watch objects of kind ServiceAccount.
//
// GET /api/v1/namespaces/{namespace}/serviceaccounts
func (s *Server) handleListCoreV1NamespacedServiceAccountRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listCoreV1NamespacedServiceAccount"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/v1/namespaces/{namespace}/serviceaccounts"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListCoreV1NamespacedServiceAccount",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListCoreV1NamespacedServiceAccount",
			ID:   "listCoreV1NamespacedServiceAccount",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ListCoreV1NamespacedServiceAccount", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeListCoreV1NamespacedServiceAccountParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListCoreV1NamespacedServiceAccountRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ListCoreV1NamespacedServiceAccount",
			OperationSummary: "",
			OperationID:      "listCoreV1NamespacedServiceAccount",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListCoreV1NamespacedServiceAccountParams
			Response = ListCoreV1NamespacedServiceAccountRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListCoreV1NamespacedServiceAccountParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ListCoreV1NamespacedServiceAccount(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ListCoreV1NamespacedServiceAccount(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListCoreV1NamespacedServiceAccountResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleListCoreV1NodeRequest handles listCoreV1Node operation.
//
// List or watch objects of kind Node.
//
// GET /api/v1/nodes
func (s *Server) handleListCoreV1NodeRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listCoreV1Node"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/v1/nodes"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListCoreV1Node",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListCoreV1Node",
			ID:   "listCoreV1Node",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ListCoreV1Node", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeListCoreV1NodeParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListCoreV1NodeRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ListCoreV1Node",
			OperationSummary: "",
			OperationID:      "listCoreV1Node",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListCoreV1NodeParams
			Response = ListCoreV1NodeRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListCoreV1NodeParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ListCoreV1Node(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ListCoreV1Node(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListCoreV1NodeResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleListCoreV1PersistentVolumeRequest handles listCoreV1PersistentVolume operation.
//
// List or watch objects of kind PersistentVolume.
//
// GET /api/v1/persistentvolumes
func (s *Server) handleListCoreV1PersistentVolumeRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listCoreV1PersistentVolume"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/v1/persistentvolumes"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListCoreV1PersistentVolume",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListCoreV1PersistentVolume",
			ID:   "listCoreV1PersistentVolume",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ListCoreV1PersistentVolume", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeListCoreV1PersistentVolumeParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListCoreV1PersistentVolumeRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ListCoreV1PersistentVolume",
			OperationSummary: "",
			OperationID:      "listCoreV1PersistentVolume",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListCoreV1PersistentVolumeParams
			Response = ListCoreV1PersistentVolumeRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListCoreV1PersistentVolumeParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ListCoreV1PersistentVolume(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ListCoreV1PersistentVolume(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListCoreV1PersistentVolumeResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleListCoreV1PersistentVolumeClaimForAllNamespacesRequest handles listCoreV1PersistentVolumeClaimForAllNamespaces operation.
//
// List or watch objects of kind PersistentVolumeClaim.
//
// GET /api/v1/persistentvolumeclaims
func (s *Server) handleListCoreV1PersistentVolumeClaimForAllNamespacesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listCoreV1PersistentVolumeClaimForAllNamespaces"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/v1/persistentvolumeclaims"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListCoreV1PersistentVolumeClaimForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListCoreV1PersistentVolumeClaimForAllNamespaces",
			ID:   "listCoreV1PersistentVolumeClaimForAllNamespaces",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ListCoreV1PersistentVolumeClaimForAllNamespaces", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeListCoreV1PersistentVolumeClaimForAllNamespacesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListCoreV1PersistentVolumeClaimForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ListCoreV1PersistentVolumeClaimForAllNamespaces",
			OperationSummary: "",
			OperationID:      "listCoreV1PersistentVolumeClaimForAllNamespaces",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListCoreV1PersistentVolumeClaimForAllNamespacesParams
			Response = ListCoreV1PersistentVolumeClaimForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListCoreV1PersistentVolumeClaimForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ListCoreV1PersistentVolumeClaimForAllNamespaces(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ListCoreV1PersistentVolumeClaimForAllNamespaces(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListCoreV1PersistentVolumeClaimForAllNamespacesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleListCoreV1PodForAllNamespacesRequest handles listCoreV1PodForAllNamespaces operation.
//
// List or watch objects of kind Pod.
//
// GET /api/v1/pods
func (s *Server) handleListCoreV1PodForAllNamespacesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listCoreV1PodForAllNamespaces"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/v1/pods"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListCoreV1PodForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListCoreV1PodForAllNamespaces",
			ID:   "listCoreV1PodForAllNamespaces",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ListCoreV1PodForAllNamespaces", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeListCoreV1PodForAllNamespacesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListCoreV1PodForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ListCoreV1PodForAllNamespaces",
			OperationSummary: "",
			OperationID:      "listCoreV1PodForAllNamespaces",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListCoreV1PodForAllNamespacesParams
			Response = ListCoreV1PodForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListCoreV1PodForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ListCoreV1PodForAllNamespaces(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ListCoreV1PodForAllNamespaces(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListCoreV1PodForAllNamespacesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleListCoreV1PodTemplateForAllNamespacesRequest handles listCoreV1PodTemplateForAllNamespaces operation.
//
// List or watch objects of kind PodTemplate.
//
// GET /api/v1/podtemplates
func (s *Server) handleListCoreV1PodTemplateForAllNamespacesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listCoreV1PodTemplateForAllNamespaces"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/v1/podtemplates"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListCoreV1PodTemplateForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListCoreV1PodTemplateForAllNamespaces",
			ID:   "listCoreV1PodTemplateForAllNamespaces",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ListCoreV1PodTemplateForAllNamespaces", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeListCoreV1PodTemplateForAllNamespacesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListCoreV1PodTemplateForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ListCoreV1PodTemplateForAllNamespaces",
			OperationSummary: "",
			OperationID:      "listCoreV1PodTemplateForAllNamespaces",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListCoreV1PodTemplateForAllNamespacesParams
			Response = ListCoreV1PodTemplateForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListCoreV1PodTemplateForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ListCoreV1PodTemplateForAllNamespaces(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ListCoreV1PodTemplateForAllNamespaces(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListCoreV1PodTemplateForAllNamespacesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleListCoreV1ReplicationControllerForAllNamespacesRequest handles listCoreV1ReplicationControllerForAllNamespaces operation.
//
// List or watch objects of kind ReplicationController.
//
// GET /api/v1/replicationcontrollers
func (s *Server) handleListCoreV1ReplicationControllerForAllNamespacesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listCoreV1ReplicationControllerForAllNamespaces"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/v1/replicationcontrollers"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListCoreV1ReplicationControllerForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListCoreV1ReplicationControllerForAllNamespaces",
			ID:   "listCoreV1ReplicationControllerForAllNamespaces",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ListCoreV1ReplicationControllerForAllNamespaces", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeListCoreV1ReplicationControllerForAllNamespacesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListCoreV1ReplicationControllerForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ListCoreV1ReplicationControllerForAllNamespaces",
			OperationSummary: "",
			OperationID:      "listCoreV1ReplicationControllerForAllNamespaces",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListCoreV1ReplicationControllerForAllNamespacesParams
			Response = ListCoreV1ReplicationControllerForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListCoreV1ReplicationControllerForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ListCoreV1ReplicationControllerForAllNamespaces(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ListCoreV1ReplicationControllerForAllNamespaces(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListCoreV1ReplicationControllerForAllNamespacesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleListCoreV1ResourceQuotaForAllNamespacesRequest handles listCoreV1ResourceQuotaForAllNamespaces operation.
//
// List or watch objects of kind ResourceQuota.
//
// GET /api/v1/resourcequotas
func (s *Server) handleListCoreV1ResourceQuotaForAllNamespacesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listCoreV1ResourceQuotaForAllNamespaces"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/v1/resourcequotas"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListCoreV1ResourceQuotaForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListCoreV1ResourceQuotaForAllNamespaces",
			ID:   "listCoreV1ResourceQuotaForAllNamespaces",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ListCoreV1ResourceQuotaForAllNamespaces", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeListCoreV1ResourceQuotaForAllNamespacesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListCoreV1ResourceQuotaForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ListCoreV1ResourceQuotaForAllNamespaces",
			OperationSummary: "",
			OperationID:      "listCoreV1ResourceQuotaForAllNamespaces",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListCoreV1ResourceQuotaForAllNamespacesParams
			Response = ListCoreV1ResourceQuotaForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListCoreV1ResourceQuotaForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ListCoreV1ResourceQuotaForAllNamespaces(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ListCoreV1ResourceQuotaForAllNamespaces(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListCoreV1ResourceQuotaForAllNamespacesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleListCoreV1SecretForAllNamespacesRequest handles listCoreV1SecretForAllNamespaces operation.
//
// List or watch objects of kind Secret.
//
// GET /api/v1/secrets
func (s *Server) handleListCoreV1SecretForAllNamespacesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listCoreV1SecretForAllNamespaces"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/v1/secrets"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListCoreV1SecretForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListCoreV1SecretForAllNamespaces",
			ID:   "listCoreV1SecretForAllNamespaces",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ListCoreV1SecretForAllNamespaces", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeListCoreV1SecretForAllNamespacesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListCoreV1SecretForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ListCoreV1SecretForAllNamespaces",
			OperationSummary: "",
			OperationID:      "listCoreV1SecretForAllNamespaces",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListCoreV1SecretForAllNamespacesParams
			Response = ListCoreV1SecretForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListCoreV1SecretForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ListCoreV1SecretForAllNamespaces(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ListCoreV1SecretForAllNamespaces(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListCoreV1SecretForAllNamespacesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleListCoreV1ServiceAccountForAllNamespacesRequest handles listCoreV1ServiceAccountForAllNamespaces operation.
//
// List or watch objects of kind ServiceAccount.
//
// GET /api/v1/serviceaccounts
func (s *Server) handleListCoreV1ServiceAccountForAllNamespacesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listCoreV1ServiceAccountForAllNamespaces"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/v1/serviceaccounts"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListCoreV1ServiceAccountForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListCoreV1ServiceAccountForAllNamespaces",
			ID:   "listCoreV1ServiceAccountForAllNamespaces",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ListCoreV1ServiceAccountForAllNamespaces", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeListCoreV1ServiceAccountForAllNamespacesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListCoreV1ServiceAccountForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ListCoreV1ServiceAccountForAllNamespaces",
			OperationSummary: "",
			OperationID:      "listCoreV1ServiceAccountForAllNamespaces",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListCoreV1ServiceAccountForAllNamespacesParams
			Response = ListCoreV1ServiceAccountForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListCoreV1ServiceAccountForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ListCoreV1ServiceAccountForAllNamespaces(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ListCoreV1ServiceAccountForAllNamespaces(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListCoreV1ServiceAccountForAllNamespacesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleListCoreV1ServiceForAllNamespacesRequest handles listCoreV1ServiceForAllNamespaces operation.
//
// List or watch objects of kind Service.
//
// GET /api/v1/services
func (s *Server) handleListCoreV1ServiceForAllNamespacesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listCoreV1ServiceForAllNamespaces"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/v1/services"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListCoreV1ServiceForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListCoreV1ServiceForAllNamespaces",
			ID:   "listCoreV1ServiceForAllNamespaces",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ListCoreV1ServiceForAllNamespaces", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeListCoreV1ServiceForAllNamespacesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListCoreV1ServiceForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ListCoreV1ServiceForAllNamespaces",
			OperationSummary: "",
			OperationID:      "listCoreV1ServiceForAllNamespaces",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListCoreV1ServiceForAllNamespacesParams
			Response = ListCoreV1ServiceForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListCoreV1ServiceForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ListCoreV1ServiceForAllNamespaces(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ListCoreV1ServiceForAllNamespaces(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListCoreV1ServiceForAllNamespacesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleListDiscoveryV1EndpointSliceForAllNamespacesRequest handles listDiscoveryV1EndpointSliceForAllNamespaces operation.
//
// List or watch objects of kind EndpointSlice.
//
// GET /apis/discovery.k8s.io/v1/endpointslices
func (s *Server) handleListDiscoveryV1EndpointSliceForAllNamespacesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listDiscoveryV1EndpointSliceForAllNamespaces"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/discovery.k8s.io/v1/endpointslices"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListDiscoveryV1EndpointSliceForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListDiscoveryV1EndpointSliceForAllNamespaces",
			ID:   "listDiscoveryV1EndpointSliceForAllNamespaces",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ListDiscoveryV1EndpointSliceForAllNamespaces", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeListDiscoveryV1EndpointSliceForAllNamespacesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListDiscoveryV1EndpointSliceForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ListDiscoveryV1EndpointSliceForAllNamespaces",
			OperationSummary: "",
			OperationID:      "listDiscoveryV1EndpointSliceForAllNamespaces",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListDiscoveryV1EndpointSliceForAllNamespacesParams
			Response = ListDiscoveryV1EndpointSliceForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListDiscoveryV1EndpointSliceForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ListDiscoveryV1EndpointSliceForAllNamespaces(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ListDiscoveryV1EndpointSliceForAllNamespaces(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListDiscoveryV1EndpointSliceForAllNamespacesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleListDiscoveryV1NamespacedEndpointSliceRequest handles listDiscoveryV1NamespacedEndpointSlice operation.
//
// List or watch objects of kind EndpointSlice.
//
// GET /apis/discovery.k8s.io/v1/namespaces/{namespace}/endpointslices
func (s *Server) handleListDiscoveryV1NamespacedEndpointSliceRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listDiscoveryV1NamespacedEndpointSlice"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/discovery.k8s.io/v1/namespaces/{namespace}/endpointslices"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListDiscoveryV1NamespacedEndpointSlice",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListDiscoveryV1NamespacedEndpointSlice",
			ID:   "listDiscoveryV1NamespacedEndpointSlice",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ListDiscoveryV1NamespacedEndpointSlice", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeListDiscoveryV1NamespacedEndpointSliceParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListDiscoveryV1NamespacedEndpointSliceRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ListDiscoveryV1NamespacedEndpointSlice",
			OperationSummary: "",
			OperationID:      "listDiscoveryV1NamespacedEndpointSlice",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListDiscoveryV1NamespacedEndpointSliceParams
			Response = ListDiscoveryV1NamespacedEndpointSliceRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListDiscoveryV1NamespacedEndpointSliceParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ListDiscoveryV1NamespacedEndpointSlice(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ListDiscoveryV1NamespacedEndpointSlice(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListDiscoveryV1NamespacedEndpointSliceResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleListDiscoveryV1beta1EndpointSliceForAllNamespacesRequest handles listDiscoveryV1beta1EndpointSliceForAllNamespaces operation.
//
// List or watch objects of kind EndpointSlice.
//
// GET /apis/discovery.k8s.io/v1beta1/endpointslices
func (s *Server) handleListDiscoveryV1beta1EndpointSliceForAllNamespacesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listDiscoveryV1beta1EndpointSliceForAllNamespaces"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/discovery.k8s.io/v1beta1/endpointslices"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListDiscoveryV1beta1EndpointSliceForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListDiscoveryV1beta1EndpointSliceForAllNamespaces",
			ID:   "listDiscoveryV1beta1EndpointSliceForAllNamespaces",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ListDiscoveryV1beta1EndpointSliceForAllNamespaces", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeListDiscoveryV1beta1EndpointSliceForAllNamespacesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListDiscoveryV1beta1EndpointSliceForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ListDiscoveryV1beta1EndpointSliceForAllNamespaces",
			OperationSummary: "",
			OperationID:      "listDiscoveryV1beta1EndpointSliceForAllNamespaces",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListDiscoveryV1beta1EndpointSliceForAllNamespacesParams
			Response = ListDiscoveryV1beta1EndpointSliceForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListDiscoveryV1beta1EndpointSliceForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ListDiscoveryV1beta1EndpointSliceForAllNamespaces(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ListDiscoveryV1beta1EndpointSliceForAllNamespaces(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListDiscoveryV1beta1EndpointSliceForAllNamespacesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleListDiscoveryV1beta1NamespacedEndpointSliceRequest handles listDiscoveryV1beta1NamespacedEndpointSlice operation.
//
// List or watch objects of kind EndpointSlice.
//
// GET /apis/discovery.k8s.io/v1beta1/namespaces/{namespace}/endpointslices
func (s *Server) handleListDiscoveryV1beta1NamespacedEndpointSliceRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listDiscoveryV1beta1NamespacedEndpointSlice"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/discovery.k8s.io/v1beta1/namespaces/{namespace}/endpointslices"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListDiscoveryV1beta1NamespacedEndpointSlice",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListDiscoveryV1beta1NamespacedEndpointSlice",
			ID:   "listDiscoveryV1beta1NamespacedEndpointSlice",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ListDiscoveryV1beta1NamespacedEndpointSlice", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeListDiscoveryV1beta1NamespacedEndpointSliceParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListDiscoveryV1beta1NamespacedEndpointSliceRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ListDiscoveryV1beta1NamespacedEndpointSlice",
			OperationSummary: "",
			OperationID:      "listDiscoveryV1beta1NamespacedEndpointSlice",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListDiscoveryV1beta1NamespacedEndpointSliceParams
			Response = ListDiscoveryV1beta1NamespacedEndpointSliceRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListDiscoveryV1beta1NamespacedEndpointSliceParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ListDiscoveryV1beta1NamespacedEndpointSlice(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ListDiscoveryV1beta1NamespacedEndpointSlice(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListDiscoveryV1beta1NamespacedEndpointSliceResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleListEventsV1EventForAllNamespacesRequest handles listEventsV1EventForAllNamespaces operation.
//
// List or watch objects of kind Event.
//
// GET /apis/events.k8s.io/v1/events
func (s *Server) handleListEventsV1EventForAllNamespacesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listEventsV1EventForAllNamespaces"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/events.k8s.io/v1/events"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListEventsV1EventForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListEventsV1EventForAllNamespaces",
			ID:   "listEventsV1EventForAllNamespaces",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ListEventsV1EventForAllNamespaces", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeListEventsV1EventForAllNamespacesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListEventsV1EventForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ListEventsV1EventForAllNamespaces",
			OperationSummary: "",
			OperationID:      "listEventsV1EventForAllNamespaces",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListEventsV1EventForAllNamespacesParams
			Response = ListEventsV1EventForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListEventsV1EventForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ListEventsV1EventForAllNamespaces(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ListEventsV1EventForAllNamespaces(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListEventsV1EventForAllNamespacesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleListEventsV1NamespacedEventRequest handles listEventsV1NamespacedEvent operation.
//
// List or watch objects of kind Event.
//
// GET /apis/events.k8s.io/v1/namespaces/{namespace}/events
func (s *Server) handleListEventsV1NamespacedEventRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listEventsV1NamespacedEvent"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/events.k8s.io/v1/namespaces/{namespace}/events"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListEventsV1NamespacedEvent",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListEventsV1NamespacedEvent",
			ID:   "listEventsV1NamespacedEvent",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ListEventsV1NamespacedEvent", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeListEventsV1NamespacedEventParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListEventsV1NamespacedEventRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ListEventsV1NamespacedEvent",
			OperationSummary: "",
			OperationID:      "listEventsV1NamespacedEvent",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListEventsV1NamespacedEventParams
			Response = ListEventsV1NamespacedEventRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListEventsV1NamespacedEventParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ListEventsV1NamespacedEvent(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ListEventsV1NamespacedEvent(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListEventsV1NamespacedEventResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleListEventsV1beta1EventForAllNamespacesRequest handles listEventsV1beta1EventForAllNamespaces operation.
//
// List or watch objects of kind Event.
//
// GET /apis/events.k8s.io/v1beta1/events
func (s *Server) handleListEventsV1beta1EventForAllNamespacesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listEventsV1beta1EventForAllNamespaces"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/events.k8s.io/v1beta1/events"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListEventsV1beta1EventForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListEventsV1beta1EventForAllNamespaces",
			ID:   "listEventsV1beta1EventForAllNamespaces",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ListEventsV1beta1EventForAllNamespaces", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeListEventsV1beta1EventForAllNamespacesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListEventsV1beta1EventForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ListEventsV1beta1EventForAllNamespaces",
			OperationSummary: "",
			OperationID:      "listEventsV1beta1EventForAllNamespaces",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListEventsV1beta1EventForAllNamespacesParams
			Response = ListEventsV1beta1EventForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListEventsV1beta1EventForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ListEventsV1beta1EventForAllNamespaces(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ListEventsV1beta1EventForAllNamespaces(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListEventsV1beta1EventForAllNamespacesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleListEventsV1beta1NamespacedEventRequest handles listEventsV1beta1NamespacedEvent operation.
//
// List or watch objects of kind Event.
//
// GET /apis/events.k8s.io/v1beta1/namespaces/{namespace}/events
func (s *Server) handleListEventsV1beta1NamespacedEventRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listEventsV1beta1NamespacedEvent"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/events.k8s.io/v1beta1/namespaces/{namespace}/events"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListEventsV1beta1NamespacedEvent",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListEventsV1beta1NamespacedEvent",
			ID:   "listEventsV1beta1NamespacedEvent",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ListEventsV1beta1NamespacedEvent", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeListEventsV1beta1NamespacedEventParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListEventsV1beta1NamespacedEventRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ListEventsV1beta1NamespacedEvent",
			OperationSummary: "",
			OperationID:      "listEventsV1beta1NamespacedEvent",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListEventsV1beta1NamespacedEventParams
			Response = ListEventsV1beta1NamespacedEventRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListEventsV1beta1NamespacedEventParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ListEventsV1beta1NamespacedEvent(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ListEventsV1beta1NamespacedEvent(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListEventsV1beta1NamespacedEventResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleListFlowcontrolApiserverV1beta1FlowSchemaRequest handles listFlowcontrolApiserverV1beta1FlowSchema operation.
//
// List or watch objects of kind FlowSchema.
//
// GET /apis/flowcontrol.apiserver.k8s.io/v1beta1/flowschemas
func (s *Server) handleListFlowcontrolApiserverV1beta1FlowSchemaRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listFlowcontrolApiserverV1beta1FlowSchema"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/flowcontrol.apiserver.k8s.io/v1beta1/flowschemas"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListFlowcontrolApiserverV1beta1FlowSchema",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListFlowcontrolApiserverV1beta1FlowSchema",
			ID:   "listFlowcontrolApiserverV1beta1FlowSchema",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ListFlowcontrolApiserverV1beta1FlowSchema", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeListFlowcontrolApiserverV1beta1FlowSchemaParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListFlowcontrolApiserverV1beta1FlowSchemaRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ListFlowcontrolApiserverV1beta1FlowSchema",
			OperationSummary: "",
			OperationID:      "listFlowcontrolApiserverV1beta1FlowSchema",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListFlowcontrolApiserverV1beta1FlowSchemaParams
			Response = ListFlowcontrolApiserverV1beta1FlowSchemaRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListFlowcontrolApiserverV1beta1FlowSchemaParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ListFlowcontrolApiserverV1beta1FlowSchema(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ListFlowcontrolApiserverV1beta1FlowSchema(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListFlowcontrolApiserverV1beta1FlowSchemaResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleListFlowcontrolApiserverV1beta1PriorityLevelConfigurationRequest handles listFlowcontrolApiserverV1beta1PriorityLevelConfiguration operation.
//
// List or watch objects of kind PriorityLevelConfiguration.
//
// GET /apis/flowcontrol.apiserver.k8s.io/v1beta1/prioritylevelconfigurations
func (s *Server) handleListFlowcontrolApiserverV1beta1PriorityLevelConfigurationRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listFlowcontrolApiserverV1beta1PriorityLevelConfiguration"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/flowcontrol.apiserver.k8s.io/v1beta1/prioritylevelconfigurations"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListFlowcontrolApiserverV1beta1PriorityLevelConfiguration",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListFlowcontrolApiserverV1beta1PriorityLevelConfiguration",
			ID:   "listFlowcontrolApiserverV1beta1PriorityLevelConfiguration",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ListFlowcontrolApiserverV1beta1PriorityLevelConfiguration", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeListFlowcontrolApiserverV1beta1PriorityLevelConfigurationParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListFlowcontrolApiserverV1beta1PriorityLevelConfigurationRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ListFlowcontrolApiserverV1beta1PriorityLevelConfiguration",
			OperationSummary: "",
			OperationID:      "listFlowcontrolApiserverV1beta1PriorityLevelConfiguration",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListFlowcontrolApiserverV1beta1PriorityLevelConfigurationParams
			Response = ListFlowcontrolApiserverV1beta1PriorityLevelConfigurationRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListFlowcontrolApiserverV1beta1PriorityLevelConfigurationParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ListFlowcontrolApiserverV1beta1PriorityLevelConfiguration(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ListFlowcontrolApiserverV1beta1PriorityLevelConfiguration(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListFlowcontrolApiserverV1beta1PriorityLevelConfigurationResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleListFlowcontrolApiserverV1beta2FlowSchemaRequest handles listFlowcontrolApiserverV1beta2FlowSchema operation.
//
// List or watch objects of kind FlowSchema.
//
// GET /apis/flowcontrol.apiserver.k8s.io/v1beta2/flowschemas
func (s *Server) handleListFlowcontrolApiserverV1beta2FlowSchemaRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listFlowcontrolApiserverV1beta2FlowSchema"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/flowcontrol.apiserver.k8s.io/v1beta2/flowschemas"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListFlowcontrolApiserverV1beta2FlowSchema",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListFlowcontrolApiserverV1beta2FlowSchema",
			ID:   "listFlowcontrolApiserverV1beta2FlowSchema",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ListFlowcontrolApiserverV1beta2FlowSchema", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeListFlowcontrolApiserverV1beta2FlowSchemaParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListFlowcontrolApiserverV1beta2FlowSchemaRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ListFlowcontrolApiserverV1beta2FlowSchema",
			OperationSummary: "",
			OperationID:      "listFlowcontrolApiserverV1beta2FlowSchema",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListFlowcontrolApiserverV1beta2FlowSchemaParams
			Response = ListFlowcontrolApiserverV1beta2FlowSchemaRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListFlowcontrolApiserverV1beta2FlowSchemaParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ListFlowcontrolApiserverV1beta2FlowSchema(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ListFlowcontrolApiserverV1beta2FlowSchema(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListFlowcontrolApiserverV1beta2FlowSchemaResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleListFlowcontrolApiserverV1beta2PriorityLevelConfigurationRequest handles listFlowcontrolApiserverV1beta2PriorityLevelConfiguration operation.
//
// List or watch objects of kind PriorityLevelConfiguration.
//
// GET /apis/flowcontrol.apiserver.k8s.io/v1beta2/prioritylevelconfigurations
func (s *Server) handleListFlowcontrolApiserverV1beta2PriorityLevelConfigurationRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listFlowcontrolApiserverV1beta2PriorityLevelConfiguration"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/flowcontrol.apiserver.k8s.io/v1beta2/prioritylevelconfigurations"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListFlowcontrolApiserverV1beta2PriorityLevelConfiguration",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListFlowcontrolApiserverV1beta2PriorityLevelConfiguration",
			ID:   "listFlowcontrolApiserverV1beta2PriorityLevelConfiguration",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ListFlowcontrolApiserverV1beta2PriorityLevelConfiguration", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeListFlowcontrolApiserverV1beta2PriorityLevelConfigurationParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListFlowcontrolApiserverV1beta2PriorityLevelConfigurationRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ListFlowcontrolApiserverV1beta2PriorityLevelConfiguration",
			OperationSummary: "",
			OperationID:      "listFlowcontrolApiserverV1beta2PriorityLevelConfiguration",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListFlowcontrolApiserverV1beta2PriorityLevelConfigurationParams
			Response = ListFlowcontrolApiserverV1beta2PriorityLevelConfigurationRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListFlowcontrolApiserverV1beta2PriorityLevelConfigurationParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ListFlowcontrolApiserverV1beta2PriorityLevelConfiguration(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ListFlowcontrolApiserverV1beta2PriorityLevelConfiguration(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListFlowcontrolApiserverV1beta2PriorityLevelConfigurationResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleListInternalApiserverV1alpha1StorageVersionRequest handles listInternalApiserverV1alpha1StorageVersion operation.
//
// List or watch objects of kind StorageVersion.
//
// GET /apis/internal.apiserver.k8s.io/v1alpha1/storageversions
func (s *Server) handleListInternalApiserverV1alpha1StorageVersionRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listInternalApiserverV1alpha1StorageVersion"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/internal.apiserver.k8s.io/v1alpha1/storageversions"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListInternalApiserverV1alpha1StorageVersion",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListInternalApiserverV1alpha1StorageVersion",
			ID:   "listInternalApiserverV1alpha1StorageVersion",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ListInternalApiserverV1alpha1StorageVersion", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeListInternalApiserverV1alpha1StorageVersionParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListInternalApiserverV1alpha1StorageVersionRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ListInternalApiserverV1alpha1StorageVersion",
			OperationSummary: "",
			OperationID:      "listInternalApiserverV1alpha1StorageVersion",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListInternalApiserverV1alpha1StorageVersionParams
			Response = ListInternalApiserverV1alpha1StorageVersionRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListInternalApiserverV1alpha1StorageVersionParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ListInternalApiserverV1alpha1StorageVersion(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ListInternalApiserverV1alpha1StorageVersion(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListInternalApiserverV1alpha1StorageVersionResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleListNetworkingV1IngressClassRequest handles listNetworkingV1IngressClass operation.
//
// List or watch objects of kind IngressClass.
//
// GET /apis/networking.k8s.io/v1/ingressclasses
func (s *Server) handleListNetworkingV1IngressClassRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listNetworkingV1IngressClass"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/networking.k8s.io/v1/ingressclasses"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListNetworkingV1IngressClass",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListNetworkingV1IngressClass",
			ID:   "listNetworkingV1IngressClass",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ListNetworkingV1IngressClass", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeListNetworkingV1IngressClassParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListNetworkingV1IngressClassRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ListNetworkingV1IngressClass",
			OperationSummary: "",
			OperationID:      "listNetworkingV1IngressClass",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListNetworkingV1IngressClassParams
			Response = ListNetworkingV1IngressClassRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListNetworkingV1IngressClassParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ListNetworkingV1IngressClass(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ListNetworkingV1IngressClass(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListNetworkingV1IngressClassResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleListNetworkingV1IngressForAllNamespacesRequest handles listNetworkingV1IngressForAllNamespaces operation.
//
// List or watch objects of kind Ingress.
//
// GET /apis/networking.k8s.io/v1/ingresses
func (s *Server) handleListNetworkingV1IngressForAllNamespacesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listNetworkingV1IngressForAllNamespaces"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/networking.k8s.io/v1/ingresses"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListNetworkingV1IngressForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListNetworkingV1IngressForAllNamespaces",
			ID:   "listNetworkingV1IngressForAllNamespaces",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ListNetworkingV1IngressForAllNamespaces", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeListNetworkingV1IngressForAllNamespacesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListNetworkingV1IngressForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ListNetworkingV1IngressForAllNamespaces",
			OperationSummary: "",
			OperationID:      "listNetworkingV1IngressForAllNamespaces",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListNetworkingV1IngressForAllNamespacesParams
			Response = ListNetworkingV1IngressForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListNetworkingV1IngressForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ListNetworkingV1IngressForAllNamespaces(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ListNetworkingV1IngressForAllNamespaces(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListNetworkingV1IngressForAllNamespacesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleListNetworkingV1NamespacedIngressRequest handles listNetworkingV1NamespacedIngress operation.
//
// List or watch objects of kind Ingress.
//
// GET /apis/networking.k8s.io/v1/namespaces/{namespace}/ingresses
func (s *Server) handleListNetworkingV1NamespacedIngressRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listNetworkingV1NamespacedIngress"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/networking.k8s.io/v1/namespaces/{namespace}/ingresses"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListNetworkingV1NamespacedIngress",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListNetworkingV1NamespacedIngress",
			ID:   "listNetworkingV1NamespacedIngress",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ListNetworkingV1NamespacedIngress", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeListNetworkingV1NamespacedIngressParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListNetworkingV1NamespacedIngressRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ListNetworkingV1NamespacedIngress",
			OperationSummary: "",
			OperationID:      "listNetworkingV1NamespacedIngress",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListNetworkingV1NamespacedIngressParams
			Response = ListNetworkingV1NamespacedIngressRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListNetworkingV1NamespacedIngressParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ListNetworkingV1NamespacedIngress(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ListNetworkingV1NamespacedIngress(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListNetworkingV1NamespacedIngressResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleListNetworkingV1NamespacedNetworkPolicyRequest handles listNetworkingV1NamespacedNetworkPolicy operation.
//
// List or watch objects of kind NetworkPolicy.
//
// GET /apis/networking.k8s.io/v1/namespaces/{namespace}/networkpolicies
func (s *Server) handleListNetworkingV1NamespacedNetworkPolicyRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listNetworkingV1NamespacedNetworkPolicy"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/networking.k8s.io/v1/namespaces/{namespace}/networkpolicies"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListNetworkingV1NamespacedNetworkPolicy",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListNetworkingV1NamespacedNetworkPolicy",
			ID:   "listNetworkingV1NamespacedNetworkPolicy",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ListNetworkingV1NamespacedNetworkPolicy", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeListNetworkingV1NamespacedNetworkPolicyParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListNetworkingV1NamespacedNetworkPolicyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ListNetworkingV1NamespacedNetworkPolicy",
			OperationSummary: "",
			OperationID:      "listNetworkingV1NamespacedNetworkPolicy",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListNetworkingV1NamespacedNetworkPolicyParams
			Response = ListNetworkingV1NamespacedNetworkPolicyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListNetworkingV1NamespacedNetworkPolicyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ListNetworkingV1NamespacedNetworkPolicy(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ListNetworkingV1NamespacedNetworkPolicy(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListNetworkingV1NamespacedNetworkPolicyResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleListNetworkingV1NetworkPolicyForAllNamespacesRequest handles listNetworkingV1NetworkPolicyForAllNamespaces operation.
//
// List or watch objects of kind NetworkPolicy.
//
// GET /apis/networking.k8s.io/v1/networkpolicies
func (s *Server) handleListNetworkingV1NetworkPolicyForAllNamespacesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listNetworkingV1NetworkPolicyForAllNamespaces"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/networking.k8s.io/v1/networkpolicies"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListNetworkingV1NetworkPolicyForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListNetworkingV1NetworkPolicyForAllNamespaces",
			ID:   "listNetworkingV1NetworkPolicyForAllNamespaces",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ListNetworkingV1NetworkPolicyForAllNamespaces", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeListNetworkingV1NetworkPolicyForAllNamespacesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListNetworkingV1NetworkPolicyForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ListNetworkingV1NetworkPolicyForAllNamespaces",
			OperationSummary: "",
			OperationID:      "listNetworkingV1NetworkPolicyForAllNamespaces",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListNetworkingV1NetworkPolicyForAllNamespacesParams
			Response = ListNetworkingV1NetworkPolicyForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListNetworkingV1NetworkPolicyForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ListNetworkingV1NetworkPolicyForAllNamespaces(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ListNetworkingV1NetworkPolicyForAllNamespaces(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListNetworkingV1NetworkPolicyForAllNamespacesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleListNodeV1RuntimeClassRequest handles listNodeV1RuntimeClass operation.
//
// List or watch objects of kind RuntimeClass.
//
// GET /apis/node.k8s.io/v1/runtimeclasses
func (s *Server) handleListNodeV1RuntimeClassRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listNodeV1RuntimeClass"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/node.k8s.io/v1/runtimeclasses"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListNodeV1RuntimeClass",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListNodeV1RuntimeClass",
			ID:   "listNodeV1RuntimeClass",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ListNodeV1RuntimeClass", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeListNodeV1RuntimeClassParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListNodeV1RuntimeClassRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ListNodeV1RuntimeClass",
			OperationSummary: "",
			OperationID:      "listNodeV1RuntimeClass",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListNodeV1RuntimeClassParams
			Response = ListNodeV1RuntimeClassRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListNodeV1RuntimeClassParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ListNodeV1RuntimeClass(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ListNodeV1RuntimeClass(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListNodeV1RuntimeClassResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleListNodeV1alpha1RuntimeClassRequest handles listNodeV1alpha1RuntimeClass operation.
//
// List or watch objects of kind RuntimeClass.
//
// GET /apis/node.k8s.io/v1alpha1/runtimeclasses
func (s *Server) handleListNodeV1alpha1RuntimeClassRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listNodeV1alpha1RuntimeClass"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/node.k8s.io/v1alpha1/runtimeclasses"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListNodeV1alpha1RuntimeClass",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListNodeV1alpha1RuntimeClass",
			ID:   "listNodeV1alpha1RuntimeClass",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ListNodeV1alpha1RuntimeClass", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeListNodeV1alpha1RuntimeClassParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListNodeV1alpha1RuntimeClassRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ListNodeV1alpha1RuntimeClass",
			OperationSummary: "",
			OperationID:      "listNodeV1alpha1RuntimeClass",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListNodeV1alpha1RuntimeClassParams
			Response = ListNodeV1alpha1RuntimeClassRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListNodeV1alpha1RuntimeClassParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ListNodeV1alpha1RuntimeClass(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ListNodeV1alpha1RuntimeClass(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListNodeV1alpha1RuntimeClassResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleListNodeV1beta1RuntimeClassRequest handles listNodeV1beta1RuntimeClass operation.
//
// List or watch objects of kind RuntimeClass.
//
// GET /apis/node.k8s.io/v1beta1/runtimeclasses
func (s *Server) handleListNodeV1beta1RuntimeClassRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listNodeV1beta1RuntimeClass"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/node.k8s.io/v1beta1/runtimeclasses"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListNodeV1beta1RuntimeClass",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListNodeV1beta1RuntimeClass",
			ID:   "listNodeV1beta1RuntimeClass",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ListNodeV1beta1RuntimeClass", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeListNodeV1beta1RuntimeClassParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListNodeV1beta1RuntimeClassRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ListNodeV1beta1RuntimeClass",
			OperationSummary: "",
			OperationID:      "listNodeV1beta1RuntimeClass",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListNodeV1beta1RuntimeClassParams
			Response = ListNodeV1beta1RuntimeClassRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListNodeV1beta1RuntimeClassParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ListNodeV1beta1RuntimeClass(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ListNodeV1beta1RuntimeClass(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListNodeV1beta1RuntimeClassResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleListPolicyV1NamespacedPodDisruptionBudgetRequest handles listPolicyV1NamespacedPodDisruptionBudget operation.
//
// List or watch objects of kind PodDisruptionBudget.
//
// GET /apis/policy/v1/namespaces/{namespace}/poddisruptionbudgets
func (s *Server) handleListPolicyV1NamespacedPodDisruptionBudgetRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listPolicyV1NamespacedPodDisruptionBudget"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/policy/v1/namespaces/{namespace}/poddisruptionbudgets"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListPolicyV1NamespacedPodDisruptionBudget",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListPolicyV1NamespacedPodDisruptionBudget",
			ID:   "listPolicyV1NamespacedPodDisruptionBudget",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ListPolicyV1NamespacedPodDisruptionBudget", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeListPolicyV1NamespacedPodDisruptionBudgetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListPolicyV1NamespacedPodDisruptionBudgetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ListPolicyV1NamespacedPodDisruptionBudget",
			OperationSummary: "",
			OperationID:      "listPolicyV1NamespacedPodDisruptionBudget",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListPolicyV1NamespacedPodDisruptionBudgetParams
			Response = ListPolicyV1NamespacedPodDisruptionBudgetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListPolicyV1NamespacedPodDisruptionBudgetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ListPolicyV1NamespacedPodDisruptionBudget(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ListPolicyV1NamespacedPodDisruptionBudget(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListPolicyV1NamespacedPodDisruptionBudgetResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleListPolicyV1PodDisruptionBudgetForAllNamespacesRequest handles listPolicyV1PodDisruptionBudgetForAllNamespaces operation.
//
// List or watch objects of kind PodDisruptionBudget.
//
// GET /apis/policy/v1/poddisruptionbudgets
func (s *Server) handleListPolicyV1PodDisruptionBudgetForAllNamespacesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listPolicyV1PodDisruptionBudgetForAllNamespaces"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/policy/v1/poddisruptionbudgets"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListPolicyV1PodDisruptionBudgetForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListPolicyV1PodDisruptionBudgetForAllNamespaces",
			ID:   "listPolicyV1PodDisruptionBudgetForAllNamespaces",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ListPolicyV1PodDisruptionBudgetForAllNamespaces", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeListPolicyV1PodDisruptionBudgetForAllNamespacesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListPolicyV1PodDisruptionBudgetForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ListPolicyV1PodDisruptionBudgetForAllNamespaces",
			OperationSummary: "",
			OperationID:      "listPolicyV1PodDisruptionBudgetForAllNamespaces",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListPolicyV1PodDisruptionBudgetForAllNamespacesParams
			Response = ListPolicyV1PodDisruptionBudgetForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListPolicyV1PodDisruptionBudgetForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ListPolicyV1PodDisruptionBudgetForAllNamespaces(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ListPolicyV1PodDisruptionBudgetForAllNamespaces(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListPolicyV1PodDisruptionBudgetForAllNamespacesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleListPolicyV1beta1NamespacedPodDisruptionBudgetRequest handles listPolicyV1beta1NamespacedPodDisruptionBudget operation.
//
// List or watch objects of kind PodDisruptionBudget.
//
// GET /apis/policy/v1beta1/namespaces/{namespace}/poddisruptionbudgets
func (s *Server) handleListPolicyV1beta1NamespacedPodDisruptionBudgetRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listPolicyV1beta1NamespacedPodDisruptionBudget"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/policy/v1beta1/namespaces/{namespace}/poddisruptionbudgets"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListPolicyV1beta1NamespacedPodDisruptionBudget",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListPolicyV1beta1NamespacedPodDisruptionBudget",
			ID:   "listPolicyV1beta1NamespacedPodDisruptionBudget",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ListPolicyV1beta1NamespacedPodDisruptionBudget", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeListPolicyV1beta1NamespacedPodDisruptionBudgetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListPolicyV1beta1NamespacedPodDisruptionBudgetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ListPolicyV1beta1NamespacedPodDisruptionBudget",
			OperationSummary: "",
			OperationID:      "listPolicyV1beta1NamespacedPodDisruptionBudget",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListPolicyV1beta1NamespacedPodDisruptionBudgetParams
			Response = ListPolicyV1beta1NamespacedPodDisruptionBudgetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListPolicyV1beta1NamespacedPodDisruptionBudgetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ListPolicyV1beta1NamespacedPodDisruptionBudget(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ListPolicyV1beta1NamespacedPodDisruptionBudget(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListPolicyV1beta1NamespacedPodDisruptionBudgetResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleListPolicyV1beta1PodDisruptionBudgetForAllNamespacesRequest handles listPolicyV1beta1PodDisruptionBudgetForAllNamespaces operation.
//
// List or watch objects of kind PodDisruptionBudget.
//
// GET /apis/policy/v1beta1/poddisruptionbudgets
func (s *Server) handleListPolicyV1beta1PodDisruptionBudgetForAllNamespacesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listPolicyV1beta1PodDisruptionBudgetForAllNamespaces"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/policy/v1beta1/poddisruptionbudgets"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListPolicyV1beta1PodDisruptionBudgetForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListPolicyV1beta1PodDisruptionBudgetForAllNamespaces",
			ID:   "listPolicyV1beta1PodDisruptionBudgetForAllNamespaces",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ListPolicyV1beta1PodDisruptionBudgetForAllNamespaces", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeListPolicyV1beta1PodDisruptionBudgetForAllNamespacesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListPolicyV1beta1PodDisruptionBudgetForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ListPolicyV1beta1PodDisruptionBudgetForAllNamespaces",
			OperationSummary: "",
			OperationID:      "listPolicyV1beta1PodDisruptionBudgetForAllNamespaces",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListPolicyV1beta1PodDisruptionBudgetForAllNamespacesParams
			Response = ListPolicyV1beta1PodDisruptionBudgetForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListPolicyV1beta1PodDisruptionBudgetForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ListPolicyV1beta1PodDisruptionBudgetForAllNamespaces(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ListPolicyV1beta1PodDisruptionBudgetForAllNamespaces(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListPolicyV1beta1PodDisruptionBudgetForAllNamespacesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleListPolicyV1beta1PodSecurityPolicyRequest handles listPolicyV1beta1PodSecurityPolicy operation.
//
// List or watch objects of kind PodSecurityPolicy.
//
// GET /apis/policy/v1beta1/podsecuritypolicies
func (s *Server) handleListPolicyV1beta1PodSecurityPolicyRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listPolicyV1beta1PodSecurityPolicy"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/policy/v1beta1/podsecuritypolicies"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListPolicyV1beta1PodSecurityPolicy",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListPolicyV1beta1PodSecurityPolicy",
			ID:   "listPolicyV1beta1PodSecurityPolicy",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ListPolicyV1beta1PodSecurityPolicy", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeListPolicyV1beta1PodSecurityPolicyParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListPolicyV1beta1PodSecurityPolicyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ListPolicyV1beta1PodSecurityPolicy",
			OperationSummary: "",
			OperationID:      "listPolicyV1beta1PodSecurityPolicy",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListPolicyV1beta1PodSecurityPolicyParams
			Response = ListPolicyV1beta1PodSecurityPolicyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListPolicyV1beta1PodSecurityPolicyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ListPolicyV1beta1PodSecurityPolicy(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ListPolicyV1beta1PodSecurityPolicy(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListPolicyV1beta1PodSecurityPolicyResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleListRbacAuthorizationV1ClusterRoleRequest handles listRbacAuthorizationV1ClusterRole operation.
//
// List or watch objects of kind ClusterRole.
//
// GET /apis/rbac.authorization.k8s.io/v1/clusterroles
func (s *Server) handleListRbacAuthorizationV1ClusterRoleRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listRbacAuthorizationV1ClusterRole"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/rbac.authorization.k8s.io/v1/clusterroles"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListRbacAuthorizationV1ClusterRole",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListRbacAuthorizationV1ClusterRole",
			ID:   "listRbacAuthorizationV1ClusterRole",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ListRbacAuthorizationV1ClusterRole", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeListRbacAuthorizationV1ClusterRoleParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListRbacAuthorizationV1ClusterRoleRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ListRbacAuthorizationV1ClusterRole",
			OperationSummary: "",
			OperationID:      "listRbacAuthorizationV1ClusterRole",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListRbacAuthorizationV1ClusterRoleParams
			Response = ListRbacAuthorizationV1ClusterRoleRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListRbacAuthorizationV1ClusterRoleParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ListRbacAuthorizationV1ClusterRole(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ListRbacAuthorizationV1ClusterRole(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListRbacAuthorizationV1ClusterRoleResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleListRbacAuthorizationV1ClusterRoleBindingRequest handles listRbacAuthorizationV1ClusterRoleBinding operation.
//
// List or watch objects of kind ClusterRoleBinding.
//
// GET /apis/rbac.authorization.k8s.io/v1/clusterrolebindings
func (s *Server) handleListRbacAuthorizationV1ClusterRoleBindingRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listRbacAuthorizationV1ClusterRoleBinding"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/rbac.authorization.k8s.io/v1/clusterrolebindings"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListRbacAuthorizationV1ClusterRoleBinding",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListRbacAuthorizationV1ClusterRoleBinding",
			ID:   "listRbacAuthorizationV1ClusterRoleBinding",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ListRbacAuthorizationV1ClusterRoleBinding", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeListRbacAuthorizationV1ClusterRoleBindingParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListRbacAuthorizationV1ClusterRoleBindingRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ListRbacAuthorizationV1ClusterRoleBinding",
			OperationSummary: "",
			OperationID:      "listRbacAuthorizationV1ClusterRoleBinding",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListRbacAuthorizationV1ClusterRoleBindingParams
			Response = ListRbacAuthorizationV1ClusterRoleBindingRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListRbacAuthorizationV1ClusterRoleBindingParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ListRbacAuthorizationV1ClusterRoleBinding(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ListRbacAuthorizationV1ClusterRoleBinding(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListRbacAuthorizationV1ClusterRoleBindingResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleListRbacAuthorizationV1NamespacedRoleRequest handles listRbacAuthorizationV1NamespacedRole operation.
//
// List or watch objects of kind Role.
//
// GET /apis/rbac.authorization.k8s.io/v1/namespaces/{namespace}/roles
func (s *Server) handleListRbacAuthorizationV1NamespacedRoleRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listRbacAuthorizationV1NamespacedRole"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/rbac.authorization.k8s.io/v1/namespaces/{namespace}/roles"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListRbacAuthorizationV1NamespacedRole",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListRbacAuthorizationV1NamespacedRole",
			ID:   "listRbacAuthorizationV1NamespacedRole",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ListRbacAuthorizationV1NamespacedRole", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeListRbacAuthorizationV1NamespacedRoleParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListRbacAuthorizationV1NamespacedRoleRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ListRbacAuthorizationV1NamespacedRole",
			OperationSummary: "",
			OperationID:      "listRbacAuthorizationV1NamespacedRole",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListRbacAuthorizationV1NamespacedRoleParams
			Response = ListRbacAuthorizationV1NamespacedRoleRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListRbacAuthorizationV1NamespacedRoleParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ListRbacAuthorizationV1NamespacedRole(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ListRbacAuthorizationV1NamespacedRole(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListRbacAuthorizationV1NamespacedRoleResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleListRbacAuthorizationV1NamespacedRoleBindingRequest handles listRbacAuthorizationV1NamespacedRoleBinding operation.
//
// List or watch objects of kind RoleBinding.
//
// GET /apis/rbac.authorization.k8s.io/v1/namespaces/{namespace}/rolebindings
func (s *Server) handleListRbacAuthorizationV1NamespacedRoleBindingRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listRbacAuthorizationV1NamespacedRoleBinding"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/rbac.authorization.k8s.io/v1/namespaces/{namespace}/rolebindings"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListRbacAuthorizationV1NamespacedRoleBinding",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListRbacAuthorizationV1NamespacedRoleBinding",
			ID:   "listRbacAuthorizationV1NamespacedRoleBinding",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ListRbacAuthorizationV1NamespacedRoleBinding", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeListRbacAuthorizationV1NamespacedRoleBindingParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListRbacAuthorizationV1NamespacedRoleBindingRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ListRbacAuthorizationV1NamespacedRoleBinding",
			OperationSummary: "",
			OperationID:      "listRbacAuthorizationV1NamespacedRoleBinding",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListRbacAuthorizationV1NamespacedRoleBindingParams
			Response = ListRbacAuthorizationV1NamespacedRoleBindingRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListRbacAuthorizationV1NamespacedRoleBindingParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ListRbacAuthorizationV1NamespacedRoleBinding(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ListRbacAuthorizationV1NamespacedRoleBinding(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListRbacAuthorizationV1NamespacedRoleBindingResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleListRbacAuthorizationV1RoleBindingForAllNamespacesRequest handles listRbacAuthorizationV1RoleBindingForAllNamespaces operation.
//
// List or watch objects of kind RoleBinding.
//
// GET /apis/rbac.authorization.k8s.io/v1/rolebindings
func (s *Server) handleListRbacAuthorizationV1RoleBindingForAllNamespacesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listRbacAuthorizationV1RoleBindingForAllNamespaces"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/rbac.authorization.k8s.io/v1/rolebindings"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListRbacAuthorizationV1RoleBindingForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListRbacAuthorizationV1RoleBindingForAllNamespaces",
			ID:   "listRbacAuthorizationV1RoleBindingForAllNamespaces",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ListRbacAuthorizationV1RoleBindingForAllNamespaces", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeListRbacAuthorizationV1RoleBindingForAllNamespacesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListRbacAuthorizationV1RoleBindingForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ListRbacAuthorizationV1RoleBindingForAllNamespaces",
			OperationSummary: "",
			OperationID:      "listRbacAuthorizationV1RoleBindingForAllNamespaces",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListRbacAuthorizationV1RoleBindingForAllNamespacesParams
			Response = ListRbacAuthorizationV1RoleBindingForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListRbacAuthorizationV1RoleBindingForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ListRbacAuthorizationV1RoleBindingForAllNamespaces(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ListRbacAuthorizationV1RoleBindingForAllNamespaces(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListRbacAuthorizationV1RoleBindingForAllNamespacesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleListRbacAuthorizationV1RoleForAllNamespacesRequest handles listRbacAuthorizationV1RoleForAllNamespaces operation.
//
// List or watch objects of kind Role.
//
// GET /apis/rbac.authorization.k8s.io/v1/roles
func (s *Server) handleListRbacAuthorizationV1RoleForAllNamespacesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listRbacAuthorizationV1RoleForAllNamespaces"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/rbac.authorization.k8s.io/v1/roles"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListRbacAuthorizationV1RoleForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListRbacAuthorizationV1RoleForAllNamespaces",
			ID:   "listRbacAuthorizationV1RoleForAllNamespaces",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ListRbacAuthorizationV1RoleForAllNamespaces", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeListRbacAuthorizationV1RoleForAllNamespacesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListRbacAuthorizationV1RoleForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ListRbacAuthorizationV1RoleForAllNamespaces",
			OperationSummary: "",
			OperationID:      "listRbacAuthorizationV1RoleForAllNamespaces",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListRbacAuthorizationV1RoleForAllNamespacesParams
			Response = ListRbacAuthorizationV1RoleForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListRbacAuthorizationV1RoleForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ListRbacAuthorizationV1RoleForAllNamespaces(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ListRbacAuthorizationV1RoleForAllNamespaces(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListRbacAuthorizationV1RoleForAllNamespacesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleListSchedulingV1PriorityClassRequest handles listSchedulingV1PriorityClass operation.
//
// List or watch objects of kind PriorityClass.
//
// GET /apis/scheduling.k8s.io/v1/priorityclasses
func (s *Server) handleListSchedulingV1PriorityClassRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listSchedulingV1PriorityClass"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/scheduling.k8s.io/v1/priorityclasses"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListSchedulingV1PriorityClass",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListSchedulingV1PriorityClass",
			ID:   "listSchedulingV1PriorityClass",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ListSchedulingV1PriorityClass", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeListSchedulingV1PriorityClassParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListSchedulingV1PriorityClassRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ListSchedulingV1PriorityClass",
			OperationSummary: "",
			OperationID:      "listSchedulingV1PriorityClass",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListSchedulingV1PriorityClassParams
			Response = ListSchedulingV1PriorityClassRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListSchedulingV1PriorityClassParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ListSchedulingV1PriorityClass(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ListSchedulingV1PriorityClass(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListSchedulingV1PriorityClassResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleListStorageV1CSIDriverRequest handles listStorageV1CSIDriver operation.
//
// List or watch objects of kind CSIDriver.
//
// GET /apis/storage.k8s.io/v1/csidrivers
func (s *Server) handleListStorageV1CSIDriverRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listStorageV1CSIDriver"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/storage.k8s.io/v1/csidrivers"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListStorageV1CSIDriver",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListStorageV1CSIDriver",
			ID:   "listStorageV1CSIDriver",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ListStorageV1CSIDriver", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeListStorageV1CSIDriverParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListStorageV1CSIDriverRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ListStorageV1CSIDriver",
			OperationSummary: "",
			OperationID:      "listStorageV1CSIDriver",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListStorageV1CSIDriverParams
			Response = ListStorageV1CSIDriverRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListStorageV1CSIDriverParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ListStorageV1CSIDriver(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ListStorageV1CSIDriver(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListStorageV1CSIDriverResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleListStorageV1CSINodeRequest handles listStorageV1CSINode operation.
//
// List or watch objects of kind CSINode.
//
// GET /apis/storage.k8s.io/v1/csinodes
func (s *Server) handleListStorageV1CSINodeRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listStorageV1CSINode"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/storage.k8s.io/v1/csinodes"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListStorageV1CSINode",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListStorageV1CSINode",
			ID:   "listStorageV1CSINode",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ListStorageV1CSINode", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeListStorageV1CSINodeParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListStorageV1CSINodeRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ListStorageV1CSINode",
			OperationSummary: "",
			OperationID:      "listStorageV1CSINode",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListStorageV1CSINodeParams
			Response = ListStorageV1CSINodeRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListStorageV1CSINodeParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ListStorageV1CSINode(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ListStorageV1CSINode(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListStorageV1CSINodeResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleListStorageV1StorageClassRequest handles listStorageV1StorageClass operation.
//
// List or watch objects of kind StorageClass.
//
// GET /apis/storage.k8s.io/v1/storageclasses
func (s *Server) handleListStorageV1StorageClassRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listStorageV1StorageClass"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/storage.k8s.io/v1/storageclasses"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListStorageV1StorageClass",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListStorageV1StorageClass",
			ID:   "listStorageV1StorageClass",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ListStorageV1StorageClass", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeListStorageV1StorageClassParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListStorageV1StorageClassRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ListStorageV1StorageClass",
			OperationSummary: "",
			OperationID:      "listStorageV1StorageClass",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListStorageV1StorageClassParams
			Response = ListStorageV1StorageClassRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListStorageV1StorageClassParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ListStorageV1StorageClass(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ListStorageV1StorageClass(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListStorageV1StorageClassResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleListStorageV1VolumeAttachmentRequest handles listStorageV1VolumeAttachment operation.
//
// List or watch objects of kind VolumeAttachment.
//
// GET /apis/storage.k8s.io/v1/volumeattachments
func (s *Server) handleListStorageV1VolumeAttachmentRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listStorageV1VolumeAttachment"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/storage.k8s.io/v1/volumeattachments"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListStorageV1VolumeAttachment",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListStorageV1VolumeAttachment",
			ID:   "listStorageV1VolumeAttachment",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ListStorageV1VolumeAttachment", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeListStorageV1VolumeAttachmentParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListStorageV1VolumeAttachmentRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ListStorageV1VolumeAttachment",
			OperationSummary: "",
			OperationID:      "listStorageV1VolumeAttachment",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListStorageV1VolumeAttachmentParams
			Response = ListStorageV1VolumeAttachmentRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListStorageV1VolumeAttachmentParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ListStorageV1VolumeAttachment(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ListStorageV1VolumeAttachment(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListStorageV1VolumeAttachmentResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleListStorageV1alpha1CSIStorageCapacityForAllNamespacesRequest handles listStorageV1alpha1CSIStorageCapacityForAllNamespaces operation.
//
// List or watch objects of kind CSIStorageCapacity.
//
// GET /apis/storage.k8s.io/v1alpha1/csistoragecapacities
func (s *Server) handleListStorageV1alpha1CSIStorageCapacityForAllNamespacesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listStorageV1alpha1CSIStorageCapacityForAllNamespaces"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/storage.k8s.io/v1alpha1/csistoragecapacities"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListStorageV1alpha1CSIStorageCapacityForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListStorageV1alpha1CSIStorageCapacityForAllNamespaces",
			ID:   "listStorageV1alpha1CSIStorageCapacityForAllNamespaces",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ListStorageV1alpha1CSIStorageCapacityForAllNamespaces", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeListStorageV1alpha1CSIStorageCapacityForAllNamespacesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListStorageV1alpha1CSIStorageCapacityForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ListStorageV1alpha1CSIStorageCapacityForAllNamespaces",
			OperationSummary: "",
			OperationID:      "listStorageV1alpha1CSIStorageCapacityForAllNamespaces",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListStorageV1alpha1CSIStorageCapacityForAllNamespacesParams
			Response = ListStorageV1alpha1CSIStorageCapacityForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListStorageV1alpha1CSIStorageCapacityForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ListStorageV1alpha1CSIStorageCapacityForAllNamespaces(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ListStorageV1alpha1CSIStorageCapacityForAllNamespaces(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListStorageV1alpha1CSIStorageCapacityForAllNamespacesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleListStorageV1alpha1NamespacedCSIStorageCapacityRequest handles listStorageV1alpha1NamespacedCSIStorageCapacity operation.
//
// List or watch objects of kind CSIStorageCapacity.
//
// GET /apis/storage.k8s.io/v1alpha1/namespaces/{namespace}/csistoragecapacities
func (s *Server) handleListStorageV1alpha1NamespacedCSIStorageCapacityRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listStorageV1alpha1NamespacedCSIStorageCapacity"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/storage.k8s.io/v1alpha1/namespaces/{namespace}/csistoragecapacities"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListStorageV1alpha1NamespacedCSIStorageCapacity",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListStorageV1alpha1NamespacedCSIStorageCapacity",
			ID:   "listStorageV1alpha1NamespacedCSIStorageCapacity",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ListStorageV1alpha1NamespacedCSIStorageCapacity", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeListStorageV1alpha1NamespacedCSIStorageCapacityParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListStorageV1alpha1NamespacedCSIStorageCapacityRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ListStorageV1alpha1NamespacedCSIStorageCapacity",
			OperationSummary: "",
			OperationID:      "listStorageV1alpha1NamespacedCSIStorageCapacity",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListStorageV1alpha1NamespacedCSIStorageCapacityParams
			Response = ListStorageV1alpha1NamespacedCSIStorageCapacityRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListStorageV1alpha1NamespacedCSIStorageCapacityParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ListStorageV1alpha1NamespacedCSIStorageCapacity(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ListStorageV1alpha1NamespacedCSIStorageCapacity(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListStorageV1alpha1NamespacedCSIStorageCapacityResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleListStorageV1beta1CSIStorageCapacityForAllNamespacesRequest handles listStorageV1beta1CSIStorageCapacityForAllNamespaces operation.
//
// List or watch objects of kind CSIStorageCapacity.
//
// GET /apis/storage.k8s.io/v1beta1/csistoragecapacities
func (s *Server) handleListStorageV1beta1CSIStorageCapacityForAllNamespacesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listStorageV1beta1CSIStorageCapacityForAllNamespaces"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/storage.k8s.io/v1beta1/csistoragecapacities"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListStorageV1beta1CSIStorageCapacityForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListStorageV1beta1CSIStorageCapacityForAllNamespaces",
			ID:   "listStorageV1beta1CSIStorageCapacityForAllNamespaces",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ListStorageV1beta1CSIStorageCapacityForAllNamespaces", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeListStorageV1beta1CSIStorageCapacityForAllNamespacesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListStorageV1beta1CSIStorageCapacityForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ListStorageV1beta1CSIStorageCapacityForAllNamespaces",
			OperationSummary: "",
			OperationID:      "listStorageV1beta1CSIStorageCapacityForAllNamespaces",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListStorageV1beta1CSIStorageCapacityForAllNamespacesParams
			Response = ListStorageV1beta1CSIStorageCapacityForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListStorageV1beta1CSIStorageCapacityForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ListStorageV1beta1CSIStorageCapacityForAllNamespaces(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ListStorageV1beta1CSIStorageCapacityForAllNamespaces(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListStorageV1beta1CSIStorageCapacityForAllNamespacesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleListStorageV1beta1NamespacedCSIStorageCapacityRequest handles listStorageV1beta1NamespacedCSIStorageCapacity operation.
//
// List or watch objects of kind CSIStorageCapacity.
//
// GET /apis/storage.k8s.io/v1beta1/namespaces/{namespace}/csistoragecapacities
func (s *Server) handleListStorageV1beta1NamespacedCSIStorageCapacityRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listStorageV1beta1NamespacedCSIStorageCapacity"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/storage.k8s.io/v1beta1/namespaces/{namespace}/csistoragecapacities"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListStorageV1beta1NamespacedCSIStorageCapacity",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListStorageV1beta1NamespacedCSIStorageCapacity",
			ID:   "listStorageV1beta1NamespacedCSIStorageCapacity",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ListStorageV1beta1NamespacedCSIStorageCapacity", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeListStorageV1beta1NamespacedCSIStorageCapacityParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListStorageV1beta1NamespacedCSIStorageCapacityRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ListStorageV1beta1NamespacedCSIStorageCapacity",
			OperationSummary: "",
			OperationID:      "listStorageV1beta1NamespacedCSIStorageCapacity",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListStorageV1beta1NamespacedCSIStorageCapacityParams
			Response = ListStorageV1beta1NamespacedCSIStorageCapacityRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListStorageV1beta1NamespacedCSIStorageCapacityParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ListStorageV1beta1NamespacedCSIStorageCapacity(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ListStorageV1beta1NamespacedCSIStorageCapacity(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListStorageV1beta1NamespacedCSIStorageCapacityResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleLogFileHandlerRequest handles logFileHandler operation.
//
// GET /logs/{logpath}
func (s *Server) handleLogFileHandlerRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("logFileHandler"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/logs/{logpath}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "LogFileHandler",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "LogFileHandler",
			ID:   "logFileHandler",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "LogFileHandler", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeLogFileHandlerParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *LogFileHandlerUnauthorized
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "LogFileHandler",
			OperationSummary: "",
			OperationID:      "logFileHandler",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "logpath",
					In:   "path",
				}: params.Logpath,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = LogFileHandlerParams
			Response = *LogFileHandlerUnauthorized
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackLogFileHandlerParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.LogFileHandler(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.LogFileHandler(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeLogFileHandlerResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleLogFileListHandlerRequest handles logFileListHandler operation.
//
// GET /logs/
func (s *Server) handleLogFileListHandlerRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("logFileListHandler"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/logs/"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "LogFileListHandler",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "LogFileListHandler",
			ID:   "logFileListHandler",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "LogFileListHandler", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}

	var response *LogFileListHandlerUnauthorized
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "LogFileListHandler",
			OperationSummary: "",
			OperationID:      "logFileListHandler",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = *LogFileListHandlerUnauthorized
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.LogFileListHandler(ctx)
				return response, err
			},
		)
	} else {
		err = s.h.LogFileListHandler(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeLogFileListHandlerResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReadAdmissionregistrationV1MutatingWebhookConfigurationRequest handles readAdmissionregistrationV1MutatingWebhookConfiguration operation.
//
// Read the specified MutatingWebhookConfiguration.
//
// GET /apis/admissionregistration.k8s.io/v1/mutatingwebhookconfigurations/{name}
func (s *Server) handleReadAdmissionregistrationV1MutatingWebhookConfigurationRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readAdmissionregistrationV1MutatingWebhookConfiguration"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/admissionregistration.k8s.io/v1/mutatingwebhookconfigurations/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadAdmissionregistrationV1MutatingWebhookConfiguration",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadAdmissionregistrationV1MutatingWebhookConfiguration",
			ID:   "readAdmissionregistrationV1MutatingWebhookConfiguration",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ReadAdmissionregistrationV1MutatingWebhookConfiguration", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeReadAdmissionregistrationV1MutatingWebhookConfigurationParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadAdmissionregistrationV1MutatingWebhookConfigurationRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ReadAdmissionregistrationV1MutatingWebhookConfiguration",
			OperationSummary: "",
			OperationID:      "readAdmissionregistrationV1MutatingWebhookConfiguration",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadAdmissionregistrationV1MutatingWebhookConfigurationParams
			Response = ReadAdmissionregistrationV1MutatingWebhookConfigurationRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadAdmissionregistrationV1MutatingWebhookConfigurationParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReadAdmissionregistrationV1MutatingWebhookConfiguration(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReadAdmissionregistrationV1MutatingWebhookConfiguration(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadAdmissionregistrationV1MutatingWebhookConfigurationResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReadAdmissionregistrationV1ValidatingWebhookConfigurationRequest handles readAdmissionregistrationV1ValidatingWebhookConfiguration operation.
//
// Read the specified ValidatingWebhookConfiguration.
//
// GET /apis/admissionregistration.k8s.io/v1/validatingwebhookconfigurations/{name}
func (s *Server) handleReadAdmissionregistrationV1ValidatingWebhookConfigurationRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readAdmissionregistrationV1ValidatingWebhookConfiguration"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/admissionregistration.k8s.io/v1/validatingwebhookconfigurations/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadAdmissionregistrationV1ValidatingWebhookConfiguration",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadAdmissionregistrationV1ValidatingWebhookConfiguration",
			ID:   "readAdmissionregistrationV1ValidatingWebhookConfiguration",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ReadAdmissionregistrationV1ValidatingWebhookConfiguration", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeReadAdmissionregistrationV1ValidatingWebhookConfigurationParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadAdmissionregistrationV1ValidatingWebhookConfigurationRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ReadAdmissionregistrationV1ValidatingWebhookConfiguration",
			OperationSummary: "",
			OperationID:      "readAdmissionregistrationV1ValidatingWebhookConfiguration",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadAdmissionregistrationV1ValidatingWebhookConfigurationParams
			Response = ReadAdmissionregistrationV1ValidatingWebhookConfigurationRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadAdmissionregistrationV1ValidatingWebhookConfigurationParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReadAdmissionregistrationV1ValidatingWebhookConfiguration(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReadAdmissionregistrationV1ValidatingWebhookConfiguration(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadAdmissionregistrationV1ValidatingWebhookConfigurationResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReadApiextensionsV1CustomResourceDefinitionRequest handles readApiextensionsV1CustomResourceDefinition operation.
//
// Read the specified CustomResourceDefinition.
//
// GET /apis/apiextensions.k8s.io/v1/customresourcedefinitions/{name}
func (s *Server) handleReadApiextensionsV1CustomResourceDefinitionRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readApiextensionsV1CustomResourceDefinition"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/apiextensions.k8s.io/v1/customresourcedefinitions/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadApiextensionsV1CustomResourceDefinition",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadApiextensionsV1CustomResourceDefinition",
			ID:   "readApiextensionsV1CustomResourceDefinition",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ReadApiextensionsV1CustomResourceDefinition", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeReadApiextensionsV1CustomResourceDefinitionParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadApiextensionsV1CustomResourceDefinitionRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ReadApiextensionsV1CustomResourceDefinition",
			OperationSummary: "",
			OperationID:      "readApiextensionsV1CustomResourceDefinition",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadApiextensionsV1CustomResourceDefinitionParams
			Response = ReadApiextensionsV1CustomResourceDefinitionRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadApiextensionsV1CustomResourceDefinitionParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReadApiextensionsV1CustomResourceDefinition(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReadApiextensionsV1CustomResourceDefinition(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadApiextensionsV1CustomResourceDefinitionResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReadApiextensionsV1CustomResourceDefinitionStatusRequest handles readApiextensionsV1CustomResourceDefinitionStatus operation.
//
// Read status of the specified CustomResourceDefinition.
//
// GET /apis/apiextensions.k8s.io/v1/customresourcedefinitions/{name}/status
func (s *Server) handleReadApiextensionsV1CustomResourceDefinitionStatusRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readApiextensionsV1CustomResourceDefinitionStatus"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/apiextensions.k8s.io/v1/customresourcedefinitions/{name}/status"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadApiextensionsV1CustomResourceDefinitionStatus",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadApiextensionsV1CustomResourceDefinitionStatus",
			ID:   "readApiextensionsV1CustomResourceDefinitionStatus",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ReadApiextensionsV1CustomResourceDefinitionStatus", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeReadApiextensionsV1CustomResourceDefinitionStatusParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadApiextensionsV1CustomResourceDefinitionStatusRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ReadApiextensionsV1CustomResourceDefinitionStatus",
			OperationSummary: "",
			OperationID:      "readApiextensionsV1CustomResourceDefinitionStatus",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadApiextensionsV1CustomResourceDefinitionStatusParams
			Response = ReadApiextensionsV1CustomResourceDefinitionStatusRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadApiextensionsV1CustomResourceDefinitionStatusParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReadApiextensionsV1CustomResourceDefinitionStatus(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReadApiextensionsV1CustomResourceDefinitionStatus(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadApiextensionsV1CustomResourceDefinitionStatusResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReadApiregistrationV1APIServiceRequest handles readApiregistrationV1APIService operation.
//
// Read the specified APIService.
//
// GET /apis/apiregistration.k8s.io/v1/apiservices/{name}
func (s *Server) handleReadApiregistrationV1APIServiceRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readApiregistrationV1APIService"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/apiregistration.k8s.io/v1/apiservices/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadApiregistrationV1APIService",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadApiregistrationV1APIService",
			ID:   "readApiregistrationV1APIService",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ReadApiregistrationV1APIService", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeReadApiregistrationV1APIServiceParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadApiregistrationV1APIServiceRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ReadApiregistrationV1APIService",
			OperationSummary: "",
			OperationID:      "readApiregistrationV1APIService",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadApiregistrationV1APIServiceParams
			Response = ReadApiregistrationV1APIServiceRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadApiregistrationV1APIServiceParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReadApiregistrationV1APIService(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReadApiregistrationV1APIService(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadApiregistrationV1APIServiceResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReadApiregistrationV1APIServiceStatusRequest handles readApiregistrationV1APIServiceStatus operation.
//
// Read status of the specified APIService.
//
// GET /apis/apiregistration.k8s.io/v1/apiservices/{name}/status
func (s *Server) handleReadApiregistrationV1APIServiceStatusRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readApiregistrationV1APIServiceStatus"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/apiregistration.k8s.io/v1/apiservices/{name}/status"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadApiregistrationV1APIServiceStatus",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadApiregistrationV1APIServiceStatus",
			ID:   "readApiregistrationV1APIServiceStatus",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ReadApiregistrationV1APIServiceStatus", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeReadApiregistrationV1APIServiceStatusParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadApiregistrationV1APIServiceStatusRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ReadApiregistrationV1APIServiceStatus",
			OperationSummary: "",
			OperationID:      "readApiregistrationV1APIServiceStatus",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadApiregistrationV1APIServiceStatusParams
			Response = ReadApiregistrationV1APIServiceStatusRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadApiregistrationV1APIServiceStatusParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReadApiregistrationV1APIServiceStatus(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReadApiregistrationV1APIServiceStatus(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadApiregistrationV1APIServiceStatusResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReadAppsV1NamespacedControllerRevisionRequest handles readAppsV1NamespacedControllerRevision operation.
//
// Read the specified ControllerRevision.
//
// GET /apis/apps/v1/namespaces/{namespace}/controllerrevisions/{name}
func (s *Server) handleReadAppsV1NamespacedControllerRevisionRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readAppsV1NamespacedControllerRevision"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/apps/v1/namespaces/{namespace}/controllerrevisions/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadAppsV1NamespacedControllerRevision",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadAppsV1NamespacedControllerRevision",
			ID:   "readAppsV1NamespacedControllerRevision",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ReadAppsV1NamespacedControllerRevision", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeReadAppsV1NamespacedControllerRevisionParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadAppsV1NamespacedControllerRevisionRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ReadAppsV1NamespacedControllerRevision",
			OperationSummary: "",
			OperationID:      "readAppsV1NamespacedControllerRevision",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadAppsV1NamespacedControllerRevisionParams
			Response = ReadAppsV1NamespacedControllerRevisionRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadAppsV1NamespacedControllerRevisionParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReadAppsV1NamespacedControllerRevision(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReadAppsV1NamespacedControllerRevision(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadAppsV1NamespacedControllerRevisionResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReadAppsV1NamespacedDaemonSetRequest handles readAppsV1NamespacedDaemonSet operation.
//
// Read the specified DaemonSet.
//
// GET /apis/apps/v1/namespaces/{namespace}/daemonsets/{name}
func (s *Server) handleReadAppsV1NamespacedDaemonSetRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readAppsV1NamespacedDaemonSet"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/apps/v1/namespaces/{namespace}/daemonsets/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadAppsV1NamespacedDaemonSet",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadAppsV1NamespacedDaemonSet",
			ID:   "readAppsV1NamespacedDaemonSet",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ReadAppsV1NamespacedDaemonSet", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeReadAppsV1NamespacedDaemonSetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadAppsV1NamespacedDaemonSetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ReadAppsV1NamespacedDaemonSet",
			OperationSummary: "",
			OperationID:      "readAppsV1NamespacedDaemonSet",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadAppsV1NamespacedDaemonSetParams
			Response = ReadAppsV1NamespacedDaemonSetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadAppsV1NamespacedDaemonSetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReadAppsV1NamespacedDaemonSet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReadAppsV1NamespacedDaemonSet(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadAppsV1NamespacedDaemonSetResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReadAppsV1NamespacedDaemonSetStatusRequest handles readAppsV1NamespacedDaemonSetStatus operation.
//
// Read status of the specified DaemonSet.
//
// GET /apis/apps/v1/namespaces/{namespace}/daemonsets/{name}/status
func (s *Server) handleReadAppsV1NamespacedDaemonSetStatusRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readAppsV1NamespacedDaemonSetStatus"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/apps/v1/namespaces/{namespace}/daemonsets/{name}/status"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadAppsV1NamespacedDaemonSetStatus",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadAppsV1NamespacedDaemonSetStatus",
			ID:   "readAppsV1NamespacedDaemonSetStatus",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ReadAppsV1NamespacedDaemonSetStatus", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeReadAppsV1NamespacedDaemonSetStatusParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadAppsV1NamespacedDaemonSetStatusRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ReadAppsV1NamespacedDaemonSetStatus",
			OperationSummary: "",
			OperationID:      "readAppsV1NamespacedDaemonSetStatus",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadAppsV1NamespacedDaemonSetStatusParams
			Response = ReadAppsV1NamespacedDaemonSetStatusRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadAppsV1NamespacedDaemonSetStatusParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReadAppsV1NamespacedDaemonSetStatus(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReadAppsV1NamespacedDaemonSetStatus(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadAppsV1NamespacedDaemonSetStatusResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReadAppsV1NamespacedDeploymentRequest handles readAppsV1NamespacedDeployment operation.
//
// Read the specified Deployment.
//
// GET /apis/apps/v1/namespaces/{namespace}/deployments/{name}
func (s *Server) handleReadAppsV1NamespacedDeploymentRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readAppsV1NamespacedDeployment"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/apps/v1/namespaces/{namespace}/deployments/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadAppsV1NamespacedDeployment",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadAppsV1NamespacedDeployment",
			ID:   "readAppsV1NamespacedDeployment",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ReadAppsV1NamespacedDeployment", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeReadAppsV1NamespacedDeploymentParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadAppsV1NamespacedDeploymentRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ReadAppsV1NamespacedDeployment",
			OperationSummary: "",
			OperationID:      "readAppsV1NamespacedDeployment",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadAppsV1NamespacedDeploymentParams
			Response = ReadAppsV1NamespacedDeploymentRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadAppsV1NamespacedDeploymentParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReadAppsV1NamespacedDeployment(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReadAppsV1NamespacedDeployment(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadAppsV1NamespacedDeploymentResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReadAppsV1NamespacedDeploymentScaleRequest handles readAppsV1NamespacedDeploymentScale operation.
//
// Read scale of the specified Deployment.
//
// GET /apis/apps/v1/namespaces/{namespace}/deployments/{name}/scale
func (s *Server) handleReadAppsV1NamespacedDeploymentScaleRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readAppsV1NamespacedDeploymentScale"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/apps/v1/namespaces/{namespace}/deployments/{name}/scale"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadAppsV1NamespacedDeploymentScale",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadAppsV1NamespacedDeploymentScale",
			ID:   "readAppsV1NamespacedDeploymentScale",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ReadAppsV1NamespacedDeploymentScale", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeReadAppsV1NamespacedDeploymentScaleParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadAppsV1NamespacedDeploymentScaleRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ReadAppsV1NamespacedDeploymentScale",
			OperationSummary: "",
			OperationID:      "readAppsV1NamespacedDeploymentScale",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadAppsV1NamespacedDeploymentScaleParams
			Response = ReadAppsV1NamespacedDeploymentScaleRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadAppsV1NamespacedDeploymentScaleParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReadAppsV1NamespacedDeploymentScale(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReadAppsV1NamespacedDeploymentScale(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadAppsV1NamespacedDeploymentScaleResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReadAppsV1NamespacedDeploymentStatusRequest handles readAppsV1NamespacedDeploymentStatus operation.
//
// Read status of the specified Deployment.
//
// GET /apis/apps/v1/namespaces/{namespace}/deployments/{name}/status
func (s *Server) handleReadAppsV1NamespacedDeploymentStatusRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readAppsV1NamespacedDeploymentStatus"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/apps/v1/namespaces/{namespace}/deployments/{name}/status"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadAppsV1NamespacedDeploymentStatus",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadAppsV1NamespacedDeploymentStatus",
			ID:   "readAppsV1NamespacedDeploymentStatus",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ReadAppsV1NamespacedDeploymentStatus", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeReadAppsV1NamespacedDeploymentStatusParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadAppsV1NamespacedDeploymentStatusRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ReadAppsV1NamespacedDeploymentStatus",
			OperationSummary: "",
			OperationID:      "readAppsV1NamespacedDeploymentStatus",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadAppsV1NamespacedDeploymentStatusParams
			Response = ReadAppsV1NamespacedDeploymentStatusRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadAppsV1NamespacedDeploymentStatusParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReadAppsV1NamespacedDeploymentStatus(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReadAppsV1NamespacedDeploymentStatus(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadAppsV1NamespacedDeploymentStatusResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReadAppsV1NamespacedReplicaSetRequest handles readAppsV1NamespacedReplicaSet operation.
//
// Read the specified ReplicaSet.
//
// GET /apis/apps/v1/namespaces/{namespace}/replicasets/{name}
func (s *Server) handleReadAppsV1NamespacedReplicaSetRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readAppsV1NamespacedReplicaSet"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/apps/v1/namespaces/{namespace}/replicasets/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadAppsV1NamespacedReplicaSet",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadAppsV1NamespacedReplicaSet",
			ID:   "readAppsV1NamespacedReplicaSet",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ReadAppsV1NamespacedReplicaSet", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeReadAppsV1NamespacedReplicaSetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadAppsV1NamespacedReplicaSetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ReadAppsV1NamespacedReplicaSet",
			OperationSummary: "",
			OperationID:      "readAppsV1NamespacedReplicaSet",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadAppsV1NamespacedReplicaSetParams
			Response = ReadAppsV1NamespacedReplicaSetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadAppsV1NamespacedReplicaSetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReadAppsV1NamespacedReplicaSet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReadAppsV1NamespacedReplicaSet(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadAppsV1NamespacedReplicaSetResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReadAppsV1NamespacedReplicaSetScaleRequest handles readAppsV1NamespacedReplicaSetScale operation.
//
// Read scale of the specified ReplicaSet.
//
// GET /apis/apps/v1/namespaces/{namespace}/replicasets/{name}/scale
func (s *Server) handleReadAppsV1NamespacedReplicaSetScaleRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readAppsV1NamespacedReplicaSetScale"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/apps/v1/namespaces/{namespace}/replicasets/{name}/scale"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadAppsV1NamespacedReplicaSetScale",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadAppsV1NamespacedReplicaSetScale",
			ID:   "readAppsV1NamespacedReplicaSetScale",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ReadAppsV1NamespacedReplicaSetScale", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeReadAppsV1NamespacedReplicaSetScaleParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadAppsV1NamespacedReplicaSetScaleRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ReadAppsV1NamespacedReplicaSetScale",
			OperationSummary: "",
			OperationID:      "readAppsV1NamespacedReplicaSetScale",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadAppsV1NamespacedReplicaSetScaleParams
			Response = ReadAppsV1NamespacedReplicaSetScaleRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadAppsV1NamespacedReplicaSetScaleParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReadAppsV1NamespacedReplicaSetScale(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReadAppsV1NamespacedReplicaSetScale(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadAppsV1NamespacedReplicaSetScaleResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReadAppsV1NamespacedReplicaSetStatusRequest handles readAppsV1NamespacedReplicaSetStatus operation.
//
// Read status of the specified ReplicaSet.
//
// GET /apis/apps/v1/namespaces/{namespace}/replicasets/{name}/status
func (s *Server) handleReadAppsV1NamespacedReplicaSetStatusRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readAppsV1NamespacedReplicaSetStatus"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/apps/v1/namespaces/{namespace}/replicasets/{name}/status"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadAppsV1NamespacedReplicaSetStatus",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadAppsV1NamespacedReplicaSetStatus",
			ID:   "readAppsV1NamespacedReplicaSetStatus",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ReadAppsV1NamespacedReplicaSetStatus", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeReadAppsV1NamespacedReplicaSetStatusParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadAppsV1NamespacedReplicaSetStatusRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ReadAppsV1NamespacedReplicaSetStatus",
			OperationSummary: "",
			OperationID:      "readAppsV1NamespacedReplicaSetStatus",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadAppsV1NamespacedReplicaSetStatusParams
			Response = ReadAppsV1NamespacedReplicaSetStatusRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadAppsV1NamespacedReplicaSetStatusParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReadAppsV1NamespacedReplicaSetStatus(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReadAppsV1NamespacedReplicaSetStatus(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadAppsV1NamespacedReplicaSetStatusResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReadAppsV1NamespacedStatefulSetRequest handles readAppsV1NamespacedStatefulSet operation.
//
// Read the specified StatefulSet.
//
// GET /apis/apps/v1/namespaces/{namespace}/statefulsets/{name}
func (s *Server) handleReadAppsV1NamespacedStatefulSetRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readAppsV1NamespacedStatefulSet"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/apps/v1/namespaces/{namespace}/statefulsets/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadAppsV1NamespacedStatefulSet",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadAppsV1NamespacedStatefulSet",
			ID:   "readAppsV1NamespacedStatefulSet",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ReadAppsV1NamespacedStatefulSet", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeReadAppsV1NamespacedStatefulSetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadAppsV1NamespacedStatefulSetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ReadAppsV1NamespacedStatefulSet",
			OperationSummary: "",
			OperationID:      "readAppsV1NamespacedStatefulSet",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadAppsV1NamespacedStatefulSetParams
			Response = ReadAppsV1NamespacedStatefulSetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadAppsV1NamespacedStatefulSetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReadAppsV1NamespacedStatefulSet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReadAppsV1NamespacedStatefulSet(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadAppsV1NamespacedStatefulSetResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReadAppsV1NamespacedStatefulSetScaleRequest handles readAppsV1NamespacedStatefulSetScale operation.
//
// Read scale of the specified StatefulSet.
//
// GET /apis/apps/v1/namespaces/{namespace}/statefulsets/{name}/scale
func (s *Server) handleReadAppsV1NamespacedStatefulSetScaleRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readAppsV1NamespacedStatefulSetScale"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/apps/v1/namespaces/{namespace}/statefulsets/{name}/scale"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadAppsV1NamespacedStatefulSetScale",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadAppsV1NamespacedStatefulSetScale",
			ID:   "readAppsV1NamespacedStatefulSetScale",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ReadAppsV1NamespacedStatefulSetScale", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeReadAppsV1NamespacedStatefulSetScaleParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadAppsV1NamespacedStatefulSetScaleRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ReadAppsV1NamespacedStatefulSetScale",
			OperationSummary: "",
			OperationID:      "readAppsV1NamespacedStatefulSetScale",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadAppsV1NamespacedStatefulSetScaleParams
			Response = ReadAppsV1NamespacedStatefulSetScaleRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadAppsV1NamespacedStatefulSetScaleParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReadAppsV1NamespacedStatefulSetScale(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReadAppsV1NamespacedStatefulSetScale(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadAppsV1NamespacedStatefulSetScaleResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReadAppsV1NamespacedStatefulSetStatusRequest handles readAppsV1NamespacedStatefulSetStatus operation.
//
// Read status of the specified StatefulSet.
//
// GET /apis/apps/v1/namespaces/{namespace}/statefulsets/{name}/status
func (s *Server) handleReadAppsV1NamespacedStatefulSetStatusRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readAppsV1NamespacedStatefulSetStatus"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/apps/v1/namespaces/{namespace}/statefulsets/{name}/status"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadAppsV1NamespacedStatefulSetStatus",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadAppsV1NamespacedStatefulSetStatus",
			ID:   "readAppsV1NamespacedStatefulSetStatus",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ReadAppsV1NamespacedStatefulSetStatus", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeReadAppsV1NamespacedStatefulSetStatusParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadAppsV1NamespacedStatefulSetStatusRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ReadAppsV1NamespacedStatefulSetStatus",
			OperationSummary: "",
			OperationID:      "readAppsV1NamespacedStatefulSetStatus",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadAppsV1NamespacedStatefulSetStatusParams
			Response = ReadAppsV1NamespacedStatefulSetStatusRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadAppsV1NamespacedStatefulSetStatusParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReadAppsV1NamespacedStatefulSetStatus(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReadAppsV1NamespacedStatefulSetStatus(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadAppsV1NamespacedStatefulSetStatusResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReadAutoscalingV1NamespacedHorizontalPodAutoscalerRequest handles readAutoscalingV1NamespacedHorizontalPodAutoscaler operation.
//
// Read the specified HorizontalPodAutoscaler.
//
// GET /apis/autoscaling/v1/namespaces/{namespace}/horizontalpodautoscalers/{name}
func (s *Server) handleReadAutoscalingV1NamespacedHorizontalPodAutoscalerRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readAutoscalingV1NamespacedHorizontalPodAutoscaler"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/autoscaling/v1/namespaces/{namespace}/horizontalpodautoscalers/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadAutoscalingV1NamespacedHorizontalPodAutoscaler",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadAutoscalingV1NamespacedHorizontalPodAutoscaler",
			ID:   "readAutoscalingV1NamespacedHorizontalPodAutoscaler",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ReadAutoscalingV1NamespacedHorizontalPodAutoscaler", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeReadAutoscalingV1NamespacedHorizontalPodAutoscalerParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadAutoscalingV1NamespacedHorizontalPodAutoscalerRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ReadAutoscalingV1NamespacedHorizontalPodAutoscaler",
			OperationSummary: "",
			OperationID:      "readAutoscalingV1NamespacedHorizontalPodAutoscaler",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadAutoscalingV1NamespacedHorizontalPodAutoscalerParams
			Response = ReadAutoscalingV1NamespacedHorizontalPodAutoscalerRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadAutoscalingV1NamespacedHorizontalPodAutoscalerParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReadAutoscalingV1NamespacedHorizontalPodAutoscaler(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReadAutoscalingV1NamespacedHorizontalPodAutoscaler(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadAutoscalingV1NamespacedHorizontalPodAutoscalerResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReadAutoscalingV1NamespacedHorizontalPodAutoscalerStatusRequest handles readAutoscalingV1NamespacedHorizontalPodAutoscalerStatus operation.
//
// Read status of the specified HorizontalPodAutoscaler.
//
// GET /apis/autoscaling/v1/namespaces/{namespace}/horizontalpodautoscalers/{name}/status
func (s *Server) handleReadAutoscalingV1NamespacedHorizontalPodAutoscalerStatusRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readAutoscalingV1NamespacedHorizontalPodAutoscalerStatus"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/autoscaling/v1/namespaces/{namespace}/horizontalpodautoscalers/{name}/status"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadAutoscalingV1NamespacedHorizontalPodAutoscalerStatus",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadAutoscalingV1NamespacedHorizontalPodAutoscalerStatus",
			ID:   "readAutoscalingV1NamespacedHorizontalPodAutoscalerStatus",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ReadAutoscalingV1NamespacedHorizontalPodAutoscalerStatus", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeReadAutoscalingV1NamespacedHorizontalPodAutoscalerStatusParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadAutoscalingV1NamespacedHorizontalPodAutoscalerStatusRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ReadAutoscalingV1NamespacedHorizontalPodAutoscalerStatus",
			OperationSummary: "",
			OperationID:      "readAutoscalingV1NamespacedHorizontalPodAutoscalerStatus",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadAutoscalingV1NamespacedHorizontalPodAutoscalerStatusParams
			Response = ReadAutoscalingV1NamespacedHorizontalPodAutoscalerStatusRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadAutoscalingV1NamespacedHorizontalPodAutoscalerStatusParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReadAutoscalingV1NamespacedHorizontalPodAutoscalerStatus(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReadAutoscalingV1NamespacedHorizontalPodAutoscalerStatus(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadAutoscalingV1NamespacedHorizontalPodAutoscalerStatusResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReadAutoscalingV2beta1NamespacedHorizontalPodAutoscalerRequest handles readAutoscalingV2beta1NamespacedHorizontalPodAutoscaler operation.
//
// Read the specified HorizontalPodAutoscaler.
//
// GET /apis/autoscaling/v2beta1/namespaces/{namespace}/horizontalpodautoscalers/{name}
func (s *Server) handleReadAutoscalingV2beta1NamespacedHorizontalPodAutoscalerRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readAutoscalingV2beta1NamespacedHorizontalPodAutoscaler"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/autoscaling/v2beta1/namespaces/{namespace}/horizontalpodautoscalers/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadAutoscalingV2beta1NamespacedHorizontalPodAutoscaler",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadAutoscalingV2beta1NamespacedHorizontalPodAutoscaler",
			ID:   "readAutoscalingV2beta1NamespacedHorizontalPodAutoscaler",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ReadAutoscalingV2beta1NamespacedHorizontalPodAutoscaler", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeReadAutoscalingV2beta1NamespacedHorizontalPodAutoscalerParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadAutoscalingV2beta1NamespacedHorizontalPodAutoscalerRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ReadAutoscalingV2beta1NamespacedHorizontalPodAutoscaler",
			OperationSummary: "",
			OperationID:      "readAutoscalingV2beta1NamespacedHorizontalPodAutoscaler",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadAutoscalingV2beta1NamespacedHorizontalPodAutoscalerParams
			Response = ReadAutoscalingV2beta1NamespacedHorizontalPodAutoscalerRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadAutoscalingV2beta1NamespacedHorizontalPodAutoscalerParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReadAutoscalingV2beta1NamespacedHorizontalPodAutoscaler(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReadAutoscalingV2beta1NamespacedHorizontalPodAutoscaler(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadAutoscalingV2beta1NamespacedHorizontalPodAutoscalerResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReadAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatusRequest handles readAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatus operation.
//
// Read status of the specified HorizontalPodAutoscaler.
//
// GET /apis/autoscaling/v2beta1/namespaces/{namespace}/horizontalpodautoscalers/{name}/status
func (s *Server) handleReadAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatusRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatus"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/autoscaling/v2beta1/namespaces/{namespace}/horizontalpodautoscalers/{name}/status"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatus",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatus",
			ID:   "readAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatus",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ReadAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatus", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeReadAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatusParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatusRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ReadAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatus",
			OperationSummary: "",
			OperationID:      "readAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatus",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatusParams
			Response = ReadAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatusRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatusParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReadAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatus(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReadAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatus(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatusResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReadAutoscalingV2beta2NamespacedHorizontalPodAutoscalerRequest handles readAutoscalingV2beta2NamespacedHorizontalPodAutoscaler operation.
//
// Read the specified HorizontalPodAutoscaler.
//
// GET /apis/autoscaling/v2beta2/namespaces/{namespace}/horizontalpodautoscalers/{name}
func (s *Server) handleReadAutoscalingV2beta2NamespacedHorizontalPodAutoscalerRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readAutoscalingV2beta2NamespacedHorizontalPodAutoscaler"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/autoscaling/v2beta2/namespaces/{namespace}/horizontalpodautoscalers/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadAutoscalingV2beta2NamespacedHorizontalPodAutoscaler",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadAutoscalingV2beta2NamespacedHorizontalPodAutoscaler",
			ID:   "readAutoscalingV2beta2NamespacedHorizontalPodAutoscaler",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ReadAutoscalingV2beta2NamespacedHorizontalPodAutoscaler", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeReadAutoscalingV2beta2NamespacedHorizontalPodAutoscalerParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadAutoscalingV2beta2NamespacedHorizontalPodAutoscalerRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ReadAutoscalingV2beta2NamespacedHorizontalPodAutoscaler",
			OperationSummary: "",
			OperationID:      "readAutoscalingV2beta2NamespacedHorizontalPodAutoscaler",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadAutoscalingV2beta2NamespacedHorizontalPodAutoscalerParams
			Response = ReadAutoscalingV2beta2NamespacedHorizontalPodAutoscalerRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadAutoscalingV2beta2NamespacedHorizontalPodAutoscalerParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReadAutoscalingV2beta2NamespacedHorizontalPodAutoscaler(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReadAutoscalingV2beta2NamespacedHorizontalPodAutoscaler(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadAutoscalingV2beta2NamespacedHorizontalPodAutoscalerResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReadAutoscalingV2beta2NamespacedHorizontalPodAutoscalerStatusRequest handles readAutoscalingV2beta2NamespacedHorizontalPodAutoscalerStatus operation.
//
// Read status of the specified HorizontalPodAutoscaler.
//
// GET /apis/autoscaling/v2beta2/namespaces/{namespace}/horizontalpodautoscalers/{name}/status
func (s *Server) handleReadAutoscalingV2beta2NamespacedHorizontalPodAutoscalerStatusRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readAutoscalingV2beta2NamespacedHorizontalPodAutoscalerStatus"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/autoscaling/v2beta2/namespaces/{namespace}/horizontalpodautoscalers/{name}/status"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadAutoscalingV2beta2NamespacedHorizontalPodAutoscalerStatus",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadAutoscalingV2beta2NamespacedHorizontalPodAutoscalerStatus",
			ID:   "readAutoscalingV2beta2NamespacedHorizontalPodAutoscalerStatus",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ReadAutoscalingV2beta2NamespacedHorizontalPodAutoscalerStatus", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeReadAutoscalingV2beta2NamespacedHorizontalPodAutoscalerStatusParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadAutoscalingV2beta2NamespacedHorizontalPodAutoscalerStatusRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ReadAutoscalingV2beta2NamespacedHorizontalPodAutoscalerStatus",
			OperationSummary: "",
			OperationID:      "readAutoscalingV2beta2NamespacedHorizontalPodAutoscalerStatus",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadAutoscalingV2beta2NamespacedHorizontalPodAutoscalerStatusParams
			Response = ReadAutoscalingV2beta2NamespacedHorizontalPodAutoscalerStatusRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadAutoscalingV2beta2NamespacedHorizontalPodAutoscalerStatusParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReadAutoscalingV2beta2NamespacedHorizontalPodAutoscalerStatus(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReadAutoscalingV2beta2NamespacedHorizontalPodAutoscalerStatus(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadAutoscalingV2beta2NamespacedHorizontalPodAutoscalerStatusResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReadBatchV1NamespacedCronJobRequest handles readBatchV1NamespacedCronJob operation.
//
// Read the specified CronJob.
//
// GET /apis/batch/v1/namespaces/{namespace}/cronjobs/{name}
func (s *Server) handleReadBatchV1NamespacedCronJobRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readBatchV1NamespacedCronJob"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/batch/v1/namespaces/{namespace}/cronjobs/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadBatchV1NamespacedCronJob",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadBatchV1NamespacedCronJob",
			ID:   "readBatchV1NamespacedCronJob",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ReadBatchV1NamespacedCronJob", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeReadBatchV1NamespacedCronJobParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadBatchV1NamespacedCronJobRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ReadBatchV1NamespacedCronJob",
			OperationSummary: "",
			OperationID:      "readBatchV1NamespacedCronJob",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadBatchV1NamespacedCronJobParams
			Response = ReadBatchV1NamespacedCronJobRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadBatchV1NamespacedCronJobParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReadBatchV1NamespacedCronJob(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReadBatchV1NamespacedCronJob(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadBatchV1NamespacedCronJobResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReadBatchV1NamespacedCronJobStatusRequest handles readBatchV1NamespacedCronJobStatus operation.
//
// Read status of the specified CronJob.
//
// GET /apis/batch/v1/namespaces/{namespace}/cronjobs/{name}/status
func (s *Server) handleReadBatchV1NamespacedCronJobStatusRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readBatchV1NamespacedCronJobStatus"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/batch/v1/namespaces/{namespace}/cronjobs/{name}/status"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadBatchV1NamespacedCronJobStatus",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadBatchV1NamespacedCronJobStatus",
			ID:   "readBatchV1NamespacedCronJobStatus",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ReadBatchV1NamespacedCronJobStatus", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeReadBatchV1NamespacedCronJobStatusParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadBatchV1NamespacedCronJobStatusRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ReadBatchV1NamespacedCronJobStatus",
			OperationSummary: "",
			OperationID:      "readBatchV1NamespacedCronJobStatus",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadBatchV1NamespacedCronJobStatusParams
			Response = ReadBatchV1NamespacedCronJobStatusRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadBatchV1NamespacedCronJobStatusParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReadBatchV1NamespacedCronJobStatus(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReadBatchV1NamespacedCronJobStatus(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadBatchV1NamespacedCronJobStatusResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReadBatchV1NamespacedJobRequest handles readBatchV1NamespacedJob operation.
//
// Read the specified Job.
//
// GET /apis/batch/v1/namespaces/{namespace}/jobs/{name}
func (s *Server) handleReadBatchV1NamespacedJobRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readBatchV1NamespacedJob"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/batch/v1/namespaces/{namespace}/jobs/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadBatchV1NamespacedJob",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadBatchV1NamespacedJob",
			ID:   "readBatchV1NamespacedJob",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ReadBatchV1NamespacedJob", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeReadBatchV1NamespacedJobParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadBatchV1NamespacedJobRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ReadBatchV1NamespacedJob",
			OperationSummary: "",
			OperationID:      "readBatchV1NamespacedJob",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadBatchV1NamespacedJobParams
			Response = ReadBatchV1NamespacedJobRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadBatchV1NamespacedJobParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReadBatchV1NamespacedJob(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReadBatchV1NamespacedJob(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadBatchV1NamespacedJobResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReadBatchV1NamespacedJobStatusRequest handles readBatchV1NamespacedJobStatus operation.
//
// Read status of the specified Job.
//
// GET /apis/batch/v1/namespaces/{namespace}/jobs/{name}/status
func (s *Server) handleReadBatchV1NamespacedJobStatusRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readBatchV1NamespacedJobStatus"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/batch/v1/namespaces/{namespace}/jobs/{name}/status"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadBatchV1NamespacedJobStatus",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadBatchV1NamespacedJobStatus",
			ID:   "readBatchV1NamespacedJobStatus",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ReadBatchV1NamespacedJobStatus", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeReadBatchV1NamespacedJobStatusParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadBatchV1NamespacedJobStatusRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ReadBatchV1NamespacedJobStatus",
			OperationSummary: "",
			OperationID:      "readBatchV1NamespacedJobStatus",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadBatchV1NamespacedJobStatusParams
			Response = ReadBatchV1NamespacedJobStatusRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadBatchV1NamespacedJobStatusParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReadBatchV1NamespacedJobStatus(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReadBatchV1NamespacedJobStatus(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadBatchV1NamespacedJobStatusResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReadBatchV1beta1NamespacedCronJobRequest handles readBatchV1beta1NamespacedCronJob operation.
//
// Read the specified CronJob.
//
// GET /apis/batch/v1beta1/namespaces/{namespace}/cronjobs/{name}
func (s *Server) handleReadBatchV1beta1NamespacedCronJobRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readBatchV1beta1NamespacedCronJob"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/batch/v1beta1/namespaces/{namespace}/cronjobs/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadBatchV1beta1NamespacedCronJob",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadBatchV1beta1NamespacedCronJob",
			ID:   "readBatchV1beta1NamespacedCronJob",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ReadBatchV1beta1NamespacedCronJob", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeReadBatchV1beta1NamespacedCronJobParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadBatchV1beta1NamespacedCronJobRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ReadBatchV1beta1NamespacedCronJob",
			OperationSummary: "",
			OperationID:      "readBatchV1beta1NamespacedCronJob",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadBatchV1beta1NamespacedCronJobParams
			Response = ReadBatchV1beta1NamespacedCronJobRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadBatchV1beta1NamespacedCronJobParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReadBatchV1beta1NamespacedCronJob(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReadBatchV1beta1NamespacedCronJob(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadBatchV1beta1NamespacedCronJobResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReadBatchV1beta1NamespacedCronJobStatusRequest handles readBatchV1beta1NamespacedCronJobStatus operation.
//
// Read status of the specified CronJob.
//
// GET /apis/batch/v1beta1/namespaces/{namespace}/cronjobs/{name}/status
func (s *Server) handleReadBatchV1beta1NamespacedCronJobStatusRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readBatchV1beta1NamespacedCronJobStatus"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/batch/v1beta1/namespaces/{namespace}/cronjobs/{name}/status"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadBatchV1beta1NamespacedCronJobStatus",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadBatchV1beta1NamespacedCronJobStatus",
			ID:   "readBatchV1beta1NamespacedCronJobStatus",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ReadBatchV1beta1NamespacedCronJobStatus", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeReadBatchV1beta1NamespacedCronJobStatusParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadBatchV1beta1NamespacedCronJobStatusRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ReadBatchV1beta1NamespacedCronJobStatus",
			OperationSummary: "",
			OperationID:      "readBatchV1beta1NamespacedCronJobStatus",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadBatchV1beta1NamespacedCronJobStatusParams
			Response = ReadBatchV1beta1NamespacedCronJobStatusRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadBatchV1beta1NamespacedCronJobStatusParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReadBatchV1beta1NamespacedCronJobStatus(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReadBatchV1beta1NamespacedCronJobStatus(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadBatchV1beta1NamespacedCronJobStatusResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReadCertificatesV1CertificateSigningRequestRequest handles readCertificatesV1CertificateSigningRequest operation.
//
// Read the specified CertificateSigningRequest.
//
// GET /apis/certificates.k8s.io/v1/certificatesigningrequests/{name}
func (s *Server) handleReadCertificatesV1CertificateSigningRequestRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readCertificatesV1CertificateSigningRequest"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/certificates.k8s.io/v1/certificatesigningrequests/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadCertificatesV1CertificateSigningRequest",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadCertificatesV1CertificateSigningRequest",
			ID:   "readCertificatesV1CertificateSigningRequest",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ReadCertificatesV1CertificateSigningRequest", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeReadCertificatesV1CertificateSigningRequestParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadCertificatesV1CertificateSigningRequestRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ReadCertificatesV1CertificateSigningRequest",
			OperationSummary: "",
			OperationID:      "readCertificatesV1CertificateSigningRequest",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadCertificatesV1CertificateSigningRequestParams
			Response = ReadCertificatesV1CertificateSigningRequestRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadCertificatesV1CertificateSigningRequestParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReadCertificatesV1CertificateSigningRequest(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReadCertificatesV1CertificateSigningRequest(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadCertificatesV1CertificateSigningRequestResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReadCertificatesV1CertificateSigningRequestApprovalRequest handles readCertificatesV1CertificateSigningRequestApproval operation.
//
// Read approval of the specified CertificateSigningRequest.
//
// GET /apis/certificates.k8s.io/v1/certificatesigningrequests/{name}/approval
func (s *Server) handleReadCertificatesV1CertificateSigningRequestApprovalRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readCertificatesV1CertificateSigningRequestApproval"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/certificates.k8s.io/v1/certificatesigningrequests/{name}/approval"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadCertificatesV1CertificateSigningRequestApproval",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadCertificatesV1CertificateSigningRequestApproval",
			ID:   "readCertificatesV1CertificateSigningRequestApproval",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ReadCertificatesV1CertificateSigningRequestApproval", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeReadCertificatesV1CertificateSigningRequestApprovalParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadCertificatesV1CertificateSigningRequestApprovalRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ReadCertificatesV1CertificateSigningRequestApproval",
			OperationSummary: "",
			OperationID:      "readCertificatesV1CertificateSigningRequestApproval",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadCertificatesV1CertificateSigningRequestApprovalParams
			Response = ReadCertificatesV1CertificateSigningRequestApprovalRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadCertificatesV1CertificateSigningRequestApprovalParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReadCertificatesV1CertificateSigningRequestApproval(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReadCertificatesV1CertificateSigningRequestApproval(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadCertificatesV1CertificateSigningRequestApprovalResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReadCertificatesV1CertificateSigningRequestStatusRequest handles readCertificatesV1CertificateSigningRequestStatus operation.
//
// Read status of the specified CertificateSigningRequest.
//
// GET /apis/certificates.k8s.io/v1/certificatesigningrequests/{name}/status
func (s *Server) handleReadCertificatesV1CertificateSigningRequestStatusRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readCertificatesV1CertificateSigningRequestStatus"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/certificates.k8s.io/v1/certificatesigningrequests/{name}/status"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadCertificatesV1CertificateSigningRequestStatus",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadCertificatesV1CertificateSigningRequestStatus",
			ID:   "readCertificatesV1CertificateSigningRequestStatus",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ReadCertificatesV1CertificateSigningRequestStatus", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeReadCertificatesV1CertificateSigningRequestStatusParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadCertificatesV1CertificateSigningRequestStatusRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ReadCertificatesV1CertificateSigningRequestStatus",
			OperationSummary: "",
			OperationID:      "readCertificatesV1CertificateSigningRequestStatus",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadCertificatesV1CertificateSigningRequestStatusParams
			Response = ReadCertificatesV1CertificateSigningRequestStatusRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadCertificatesV1CertificateSigningRequestStatusParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReadCertificatesV1CertificateSigningRequestStatus(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReadCertificatesV1CertificateSigningRequestStatus(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadCertificatesV1CertificateSigningRequestStatusResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReadCoordinationV1NamespacedLeaseRequest handles readCoordinationV1NamespacedLease operation.
//
// Read the specified Lease.
//
// GET /apis/coordination.k8s.io/v1/namespaces/{namespace}/leases/{name}
func (s *Server) handleReadCoordinationV1NamespacedLeaseRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readCoordinationV1NamespacedLease"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/coordination.k8s.io/v1/namespaces/{namespace}/leases/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadCoordinationV1NamespacedLease",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadCoordinationV1NamespacedLease",
			ID:   "readCoordinationV1NamespacedLease",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ReadCoordinationV1NamespacedLease", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeReadCoordinationV1NamespacedLeaseParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadCoordinationV1NamespacedLeaseRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ReadCoordinationV1NamespacedLease",
			OperationSummary: "",
			OperationID:      "readCoordinationV1NamespacedLease",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadCoordinationV1NamespacedLeaseParams
			Response = ReadCoordinationV1NamespacedLeaseRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadCoordinationV1NamespacedLeaseParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReadCoordinationV1NamespacedLease(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReadCoordinationV1NamespacedLease(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadCoordinationV1NamespacedLeaseResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReadCoreV1ComponentStatusRequest handles readCoreV1ComponentStatus operation.
//
// Read the specified ComponentStatus.
//
// GET /api/v1/componentstatuses/{name}
func (s *Server) handleReadCoreV1ComponentStatusRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readCoreV1ComponentStatus"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/v1/componentstatuses/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadCoreV1ComponentStatus",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadCoreV1ComponentStatus",
			ID:   "readCoreV1ComponentStatus",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ReadCoreV1ComponentStatus", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeReadCoreV1ComponentStatusParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadCoreV1ComponentStatusRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ReadCoreV1ComponentStatus",
			OperationSummary: "",
			OperationID:      "readCoreV1ComponentStatus",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadCoreV1ComponentStatusParams
			Response = ReadCoreV1ComponentStatusRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadCoreV1ComponentStatusParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReadCoreV1ComponentStatus(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReadCoreV1ComponentStatus(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadCoreV1ComponentStatusResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReadCoreV1NamespaceRequest handles readCoreV1Namespace operation.
//
// Read the specified Namespace.
//
// GET /api/v1/namespaces/{name}
func (s *Server) handleReadCoreV1NamespaceRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readCoreV1Namespace"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/v1/namespaces/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadCoreV1Namespace",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadCoreV1Namespace",
			ID:   "readCoreV1Namespace",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ReadCoreV1Namespace", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeReadCoreV1NamespaceParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadCoreV1NamespaceRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ReadCoreV1Namespace",
			OperationSummary: "",
			OperationID:      "readCoreV1Namespace",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadCoreV1NamespaceParams
			Response = ReadCoreV1NamespaceRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadCoreV1NamespaceParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReadCoreV1Namespace(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReadCoreV1Namespace(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadCoreV1NamespaceResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReadCoreV1NamespaceStatusRequest handles readCoreV1NamespaceStatus operation.
//
// Read status of the specified Namespace.
//
// GET /api/v1/namespaces/{name}/status
func (s *Server) handleReadCoreV1NamespaceStatusRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readCoreV1NamespaceStatus"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/v1/namespaces/{name}/status"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadCoreV1NamespaceStatus",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadCoreV1NamespaceStatus",
			ID:   "readCoreV1NamespaceStatus",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ReadCoreV1NamespaceStatus", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeReadCoreV1NamespaceStatusParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadCoreV1NamespaceStatusRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ReadCoreV1NamespaceStatus",
			OperationSummary: "",
			OperationID:      "readCoreV1NamespaceStatus",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadCoreV1NamespaceStatusParams
			Response = ReadCoreV1NamespaceStatusRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadCoreV1NamespaceStatusParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReadCoreV1NamespaceStatus(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReadCoreV1NamespaceStatus(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadCoreV1NamespaceStatusResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReadCoreV1NamespacedConfigMapRequest handles readCoreV1NamespacedConfigMap operation.
//
// Read the specified ConfigMap.
//
// GET /api/v1/namespaces/{namespace}/configmaps/{name}
func (s *Server) handleReadCoreV1NamespacedConfigMapRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readCoreV1NamespacedConfigMap"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/v1/namespaces/{namespace}/configmaps/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadCoreV1NamespacedConfigMap",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadCoreV1NamespacedConfigMap",
			ID:   "readCoreV1NamespacedConfigMap",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ReadCoreV1NamespacedConfigMap", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeReadCoreV1NamespacedConfigMapParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadCoreV1NamespacedConfigMapRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ReadCoreV1NamespacedConfigMap",
			OperationSummary: "",
			OperationID:      "readCoreV1NamespacedConfigMap",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadCoreV1NamespacedConfigMapParams
			Response = ReadCoreV1NamespacedConfigMapRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadCoreV1NamespacedConfigMapParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReadCoreV1NamespacedConfigMap(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReadCoreV1NamespacedConfigMap(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadCoreV1NamespacedConfigMapResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReadCoreV1NamespacedEndpointsRequest handles readCoreV1NamespacedEndpoints operation.
//
// Read the specified Endpoints.
//
// GET /api/v1/namespaces/{namespace}/endpoints/{name}
func (s *Server) handleReadCoreV1NamespacedEndpointsRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readCoreV1NamespacedEndpoints"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/v1/namespaces/{namespace}/endpoints/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadCoreV1NamespacedEndpoints",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadCoreV1NamespacedEndpoints",
			ID:   "readCoreV1NamespacedEndpoints",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ReadCoreV1NamespacedEndpoints", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeReadCoreV1NamespacedEndpointsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadCoreV1NamespacedEndpointsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ReadCoreV1NamespacedEndpoints",
			OperationSummary: "",
			OperationID:      "readCoreV1NamespacedEndpoints",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadCoreV1NamespacedEndpointsParams
			Response = ReadCoreV1NamespacedEndpointsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadCoreV1NamespacedEndpointsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReadCoreV1NamespacedEndpoints(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReadCoreV1NamespacedEndpoints(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadCoreV1NamespacedEndpointsResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReadCoreV1NamespacedEventRequest handles readCoreV1NamespacedEvent operation.
//
// Read the specified Event.
//
// GET /api/v1/namespaces/{namespace}/events/{name}
func (s *Server) handleReadCoreV1NamespacedEventRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readCoreV1NamespacedEvent"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/v1/namespaces/{namespace}/events/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadCoreV1NamespacedEvent",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadCoreV1NamespacedEvent",
			ID:   "readCoreV1NamespacedEvent",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ReadCoreV1NamespacedEvent", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeReadCoreV1NamespacedEventParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadCoreV1NamespacedEventRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ReadCoreV1NamespacedEvent",
			OperationSummary: "",
			OperationID:      "readCoreV1NamespacedEvent",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadCoreV1NamespacedEventParams
			Response = ReadCoreV1NamespacedEventRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadCoreV1NamespacedEventParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReadCoreV1NamespacedEvent(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReadCoreV1NamespacedEvent(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadCoreV1NamespacedEventResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReadCoreV1NamespacedLimitRangeRequest handles readCoreV1NamespacedLimitRange operation.
//
// Read the specified LimitRange.
//
// GET /api/v1/namespaces/{namespace}/limitranges/{name}
func (s *Server) handleReadCoreV1NamespacedLimitRangeRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readCoreV1NamespacedLimitRange"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/v1/namespaces/{namespace}/limitranges/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadCoreV1NamespacedLimitRange",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadCoreV1NamespacedLimitRange",
			ID:   "readCoreV1NamespacedLimitRange",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ReadCoreV1NamespacedLimitRange", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeReadCoreV1NamespacedLimitRangeParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadCoreV1NamespacedLimitRangeRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ReadCoreV1NamespacedLimitRange",
			OperationSummary: "",
			OperationID:      "readCoreV1NamespacedLimitRange",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadCoreV1NamespacedLimitRangeParams
			Response = ReadCoreV1NamespacedLimitRangeRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadCoreV1NamespacedLimitRangeParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReadCoreV1NamespacedLimitRange(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReadCoreV1NamespacedLimitRange(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadCoreV1NamespacedLimitRangeResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReadCoreV1NamespacedPersistentVolumeClaimRequest handles readCoreV1NamespacedPersistentVolumeClaim operation.
//
// Read the specified PersistentVolumeClaim.
//
// GET /api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}
func (s *Server) handleReadCoreV1NamespacedPersistentVolumeClaimRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readCoreV1NamespacedPersistentVolumeClaim"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadCoreV1NamespacedPersistentVolumeClaim",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadCoreV1NamespacedPersistentVolumeClaim",
			ID:   "readCoreV1NamespacedPersistentVolumeClaim",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ReadCoreV1NamespacedPersistentVolumeClaim", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeReadCoreV1NamespacedPersistentVolumeClaimParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadCoreV1NamespacedPersistentVolumeClaimRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ReadCoreV1NamespacedPersistentVolumeClaim",
			OperationSummary: "",
			OperationID:      "readCoreV1NamespacedPersistentVolumeClaim",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadCoreV1NamespacedPersistentVolumeClaimParams
			Response = ReadCoreV1NamespacedPersistentVolumeClaimRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadCoreV1NamespacedPersistentVolumeClaimParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReadCoreV1NamespacedPersistentVolumeClaim(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReadCoreV1NamespacedPersistentVolumeClaim(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadCoreV1NamespacedPersistentVolumeClaimResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReadCoreV1NamespacedPersistentVolumeClaimStatusRequest handles readCoreV1NamespacedPersistentVolumeClaimStatus operation.
//
// Read status of the specified PersistentVolumeClaim.
//
// GET /api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}/status
func (s *Server) handleReadCoreV1NamespacedPersistentVolumeClaimStatusRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readCoreV1NamespacedPersistentVolumeClaimStatus"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}/status"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadCoreV1NamespacedPersistentVolumeClaimStatus",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadCoreV1NamespacedPersistentVolumeClaimStatus",
			ID:   "readCoreV1NamespacedPersistentVolumeClaimStatus",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ReadCoreV1NamespacedPersistentVolumeClaimStatus", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeReadCoreV1NamespacedPersistentVolumeClaimStatusParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadCoreV1NamespacedPersistentVolumeClaimStatusRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ReadCoreV1NamespacedPersistentVolumeClaimStatus",
			OperationSummary: "",
			OperationID:      "readCoreV1NamespacedPersistentVolumeClaimStatus",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadCoreV1NamespacedPersistentVolumeClaimStatusParams
			Response = ReadCoreV1NamespacedPersistentVolumeClaimStatusRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadCoreV1NamespacedPersistentVolumeClaimStatusParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReadCoreV1NamespacedPersistentVolumeClaimStatus(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReadCoreV1NamespacedPersistentVolumeClaimStatus(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadCoreV1NamespacedPersistentVolumeClaimStatusResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReadCoreV1NamespacedPodRequest handles readCoreV1NamespacedPod operation.
//
// Read the specified Pod.
//
// GET /api/v1/namespaces/{namespace}/pods/{name}
func (s *Server) handleReadCoreV1NamespacedPodRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readCoreV1NamespacedPod"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/v1/namespaces/{namespace}/pods/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadCoreV1NamespacedPod",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadCoreV1NamespacedPod",
			ID:   "readCoreV1NamespacedPod",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ReadCoreV1NamespacedPod", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeReadCoreV1NamespacedPodParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadCoreV1NamespacedPodRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ReadCoreV1NamespacedPod",
			OperationSummary: "",
			OperationID:      "readCoreV1NamespacedPod",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadCoreV1NamespacedPodParams
			Response = ReadCoreV1NamespacedPodRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadCoreV1NamespacedPodParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReadCoreV1NamespacedPod(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReadCoreV1NamespacedPod(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadCoreV1NamespacedPodResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReadCoreV1NamespacedPodEphemeralcontainersRequest handles readCoreV1NamespacedPodEphemeralcontainers operation.
//
// Read ephemeralcontainers of the specified Pod.
//
// GET /api/v1/namespaces/{namespace}/pods/{name}/ephemeralcontainers
func (s *Server) handleReadCoreV1NamespacedPodEphemeralcontainersRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readCoreV1NamespacedPodEphemeralcontainers"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/v1/namespaces/{namespace}/pods/{name}/ephemeralcontainers"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadCoreV1NamespacedPodEphemeralcontainers",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadCoreV1NamespacedPodEphemeralcontainers",
			ID:   "readCoreV1NamespacedPodEphemeralcontainers",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ReadCoreV1NamespacedPodEphemeralcontainers", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeReadCoreV1NamespacedPodEphemeralcontainersParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadCoreV1NamespacedPodEphemeralcontainersRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ReadCoreV1NamespacedPodEphemeralcontainers",
			OperationSummary: "",
			OperationID:      "readCoreV1NamespacedPodEphemeralcontainers",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadCoreV1NamespacedPodEphemeralcontainersParams
			Response = ReadCoreV1NamespacedPodEphemeralcontainersRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadCoreV1NamespacedPodEphemeralcontainersParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReadCoreV1NamespacedPodEphemeralcontainers(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReadCoreV1NamespacedPodEphemeralcontainers(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadCoreV1NamespacedPodEphemeralcontainersResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReadCoreV1NamespacedPodLogRequest handles readCoreV1NamespacedPodLog operation.
//
// Read log of the specified Pod.
//
// GET /api/v1/namespaces/{namespace}/pods/{name}/log
func (s *Server) handleReadCoreV1NamespacedPodLogRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readCoreV1NamespacedPodLog"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/v1/namespaces/{namespace}/pods/{name}/log"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadCoreV1NamespacedPodLog",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadCoreV1NamespacedPodLog",
			ID:   "readCoreV1NamespacedPodLog",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ReadCoreV1NamespacedPodLog", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeReadCoreV1NamespacedPodLogParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadCoreV1NamespacedPodLogRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ReadCoreV1NamespacedPodLog",
			OperationSummary: "",
			OperationID:      "readCoreV1NamespacedPodLog",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "container",
					In:   "query",
				}: params.Container,
				{
					Name: "follow",
					In:   "query",
				}: params.Follow,
				{
					Name: "insecureSkipTLSVerifyBackend",
					In:   "query",
				}: params.InsecureSkipTLSVerifyBackend,
				{
					Name: "limitBytes",
					In:   "query",
				}: params.LimitBytes,
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "previous",
					In:   "query",
				}: params.Previous,
				{
					Name: "sinceSeconds",
					In:   "query",
				}: params.SinceSeconds,
				{
					Name: "tailLines",
					In:   "query",
				}: params.TailLines,
				{
					Name: "timestamps",
					In:   "query",
				}: params.Timestamps,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadCoreV1NamespacedPodLogParams
			Response = ReadCoreV1NamespacedPodLogRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadCoreV1NamespacedPodLogParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReadCoreV1NamespacedPodLog(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReadCoreV1NamespacedPodLog(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadCoreV1NamespacedPodLogResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReadCoreV1NamespacedPodStatusRequest handles readCoreV1NamespacedPodStatus operation.
//
// Read status of the specified Pod.
//
// GET /api/v1/namespaces/{namespace}/pods/{name}/status
func (s *Server) handleReadCoreV1NamespacedPodStatusRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readCoreV1NamespacedPodStatus"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/v1/namespaces/{namespace}/pods/{name}/status"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadCoreV1NamespacedPodStatus",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadCoreV1NamespacedPodStatus",
			ID:   "readCoreV1NamespacedPodStatus",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ReadCoreV1NamespacedPodStatus", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeReadCoreV1NamespacedPodStatusParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadCoreV1NamespacedPodStatusRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ReadCoreV1NamespacedPodStatus",
			OperationSummary: "",
			OperationID:      "readCoreV1NamespacedPodStatus",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadCoreV1NamespacedPodStatusParams
			Response = ReadCoreV1NamespacedPodStatusRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadCoreV1NamespacedPodStatusParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReadCoreV1NamespacedPodStatus(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReadCoreV1NamespacedPodStatus(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadCoreV1NamespacedPodStatusResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReadCoreV1NamespacedPodTemplateRequest handles readCoreV1NamespacedPodTemplate operation.
//
// Read the specified PodTemplate.
//
// GET /api/v1/namespaces/{namespace}/podtemplates/{name}
func (s *Server) handleReadCoreV1NamespacedPodTemplateRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readCoreV1NamespacedPodTemplate"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/v1/namespaces/{namespace}/podtemplates/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadCoreV1NamespacedPodTemplate",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadCoreV1NamespacedPodTemplate",
			ID:   "readCoreV1NamespacedPodTemplate",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ReadCoreV1NamespacedPodTemplate", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeReadCoreV1NamespacedPodTemplateParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadCoreV1NamespacedPodTemplateRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ReadCoreV1NamespacedPodTemplate",
			OperationSummary: "",
			OperationID:      "readCoreV1NamespacedPodTemplate",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadCoreV1NamespacedPodTemplateParams
			Response = ReadCoreV1NamespacedPodTemplateRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadCoreV1NamespacedPodTemplateParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReadCoreV1NamespacedPodTemplate(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReadCoreV1NamespacedPodTemplate(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadCoreV1NamespacedPodTemplateResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReadCoreV1NamespacedReplicationControllerRequest handles readCoreV1NamespacedReplicationController operation.
//
// Read the specified ReplicationController.
//
// GET /api/v1/namespaces/{namespace}/replicationcontrollers/{name}
func (s *Server) handleReadCoreV1NamespacedReplicationControllerRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readCoreV1NamespacedReplicationController"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/v1/namespaces/{namespace}/replicationcontrollers/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadCoreV1NamespacedReplicationController",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadCoreV1NamespacedReplicationController",
			ID:   "readCoreV1NamespacedReplicationController",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ReadCoreV1NamespacedReplicationController", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeReadCoreV1NamespacedReplicationControllerParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadCoreV1NamespacedReplicationControllerRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ReadCoreV1NamespacedReplicationController",
			OperationSummary: "",
			OperationID:      "readCoreV1NamespacedReplicationController",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadCoreV1NamespacedReplicationControllerParams
			Response = ReadCoreV1NamespacedReplicationControllerRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadCoreV1NamespacedReplicationControllerParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReadCoreV1NamespacedReplicationController(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReadCoreV1NamespacedReplicationController(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadCoreV1NamespacedReplicationControllerResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReadCoreV1NamespacedReplicationControllerScaleRequest handles readCoreV1NamespacedReplicationControllerScale operation.
//
// Read scale of the specified ReplicationController.
//
// GET /api/v1/namespaces/{namespace}/replicationcontrollers/{name}/scale
func (s *Server) handleReadCoreV1NamespacedReplicationControllerScaleRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readCoreV1NamespacedReplicationControllerScale"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/scale"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadCoreV1NamespacedReplicationControllerScale",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadCoreV1NamespacedReplicationControllerScale",
			ID:   "readCoreV1NamespacedReplicationControllerScale",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ReadCoreV1NamespacedReplicationControllerScale", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeReadCoreV1NamespacedReplicationControllerScaleParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadCoreV1NamespacedReplicationControllerScaleRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ReadCoreV1NamespacedReplicationControllerScale",
			OperationSummary: "",
			OperationID:      "readCoreV1NamespacedReplicationControllerScale",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadCoreV1NamespacedReplicationControllerScaleParams
			Response = ReadCoreV1NamespacedReplicationControllerScaleRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadCoreV1NamespacedReplicationControllerScaleParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReadCoreV1NamespacedReplicationControllerScale(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReadCoreV1NamespacedReplicationControllerScale(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadCoreV1NamespacedReplicationControllerScaleResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReadCoreV1NamespacedReplicationControllerStatusRequest handles readCoreV1NamespacedReplicationControllerStatus operation.
//
// Read status of the specified ReplicationController.
//
// GET /api/v1/namespaces/{namespace}/replicationcontrollers/{name}/status
func (s *Server) handleReadCoreV1NamespacedReplicationControllerStatusRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readCoreV1NamespacedReplicationControllerStatus"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/status"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadCoreV1NamespacedReplicationControllerStatus",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadCoreV1NamespacedReplicationControllerStatus",
			ID:   "readCoreV1NamespacedReplicationControllerStatus",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ReadCoreV1NamespacedReplicationControllerStatus", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeReadCoreV1NamespacedReplicationControllerStatusParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadCoreV1NamespacedReplicationControllerStatusRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ReadCoreV1NamespacedReplicationControllerStatus",
			OperationSummary: "",
			OperationID:      "readCoreV1NamespacedReplicationControllerStatus",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadCoreV1NamespacedReplicationControllerStatusParams
			Response = ReadCoreV1NamespacedReplicationControllerStatusRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadCoreV1NamespacedReplicationControllerStatusParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReadCoreV1NamespacedReplicationControllerStatus(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReadCoreV1NamespacedReplicationControllerStatus(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadCoreV1NamespacedReplicationControllerStatusResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReadCoreV1NamespacedResourceQuotaRequest handles readCoreV1NamespacedResourceQuota operation.
//
// Read the specified ResourceQuota.
//
// GET /api/v1/namespaces/{namespace}/resourcequotas/{name}
func (s *Server) handleReadCoreV1NamespacedResourceQuotaRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readCoreV1NamespacedResourceQuota"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/v1/namespaces/{namespace}/resourcequotas/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadCoreV1NamespacedResourceQuota",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadCoreV1NamespacedResourceQuota",
			ID:   "readCoreV1NamespacedResourceQuota",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ReadCoreV1NamespacedResourceQuota", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeReadCoreV1NamespacedResourceQuotaParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadCoreV1NamespacedResourceQuotaRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ReadCoreV1NamespacedResourceQuota",
			OperationSummary: "",
			OperationID:      "readCoreV1NamespacedResourceQuota",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadCoreV1NamespacedResourceQuotaParams
			Response = ReadCoreV1NamespacedResourceQuotaRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadCoreV1NamespacedResourceQuotaParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReadCoreV1NamespacedResourceQuota(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReadCoreV1NamespacedResourceQuota(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadCoreV1NamespacedResourceQuotaResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReadCoreV1NamespacedResourceQuotaStatusRequest handles readCoreV1NamespacedResourceQuotaStatus operation.
//
// Read status of the specified ResourceQuota.
//
// GET /api/v1/namespaces/{namespace}/resourcequotas/{name}/status
func (s *Server) handleReadCoreV1NamespacedResourceQuotaStatusRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readCoreV1NamespacedResourceQuotaStatus"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/v1/namespaces/{namespace}/resourcequotas/{name}/status"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadCoreV1NamespacedResourceQuotaStatus",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadCoreV1NamespacedResourceQuotaStatus",
			ID:   "readCoreV1NamespacedResourceQuotaStatus",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ReadCoreV1NamespacedResourceQuotaStatus", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeReadCoreV1NamespacedResourceQuotaStatusParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadCoreV1NamespacedResourceQuotaStatusRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ReadCoreV1NamespacedResourceQuotaStatus",
			OperationSummary: "",
			OperationID:      "readCoreV1NamespacedResourceQuotaStatus",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadCoreV1NamespacedResourceQuotaStatusParams
			Response = ReadCoreV1NamespacedResourceQuotaStatusRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadCoreV1NamespacedResourceQuotaStatusParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReadCoreV1NamespacedResourceQuotaStatus(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReadCoreV1NamespacedResourceQuotaStatus(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadCoreV1NamespacedResourceQuotaStatusResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReadCoreV1NamespacedSecretRequest handles readCoreV1NamespacedSecret operation.
//
// Read the specified Secret.
//
// GET /api/v1/namespaces/{namespace}/secrets/{name}
func (s *Server) handleReadCoreV1NamespacedSecretRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readCoreV1NamespacedSecret"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/v1/namespaces/{namespace}/secrets/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadCoreV1NamespacedSecret",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadCoreV1NamespacedSecret",
			ID:   "readCoreV1NamespacedSecret",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ReadCoreV1NamespacedSecret", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeReadCoreV1NamespacedSecretParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadCoreV1NamespacedSecretRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ReadCoreV1NamespacedSecret",
			OperationSummary: "",
			OperationID:      "readCoreV1NamespacedSecret",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadCoreV1NamespacedSecretParams
			Response = ReadCoreV1NamespacedSecretRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadCoreV1NamespacedSecretParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReadCoreV1NamespacedSecret(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReadCoreV1NamespacedSecret(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadCoreV1NamespacedSecretResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReadCoreV1NamespacedServiceRequest handles readCoreV1NamespacedService operation.
//
// Read the specified Service.
//
// GET /api/v1/namespaces/{namespace}/services/{name}
func (s *Server) handleReadCoreV1NamespacedServiceRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readCoreV1NamespacedService"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/v1/namespaces/{namespace}/services/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadCoreV1NamespacedService",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadCoreV1NamespacedService",
			ID:   "readCoreV1NamespacedService",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ReadCoreV1NamespacedService", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeReadCoreV1NamespacedServiceParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadCoreV1NamespacedServiceRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ReadCoreV1NamespacedService",
			OperationSummary: "",
			OperationID:      "readCoreV1NamespacedService",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadCoreV1NamespacedServiceParams
			Response = ReadCoreV1NamespacedServiceRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadCoreV1NamespacedServiceParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReadCoreV1NamespacedService(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReadCoreV1NamespacedService(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadCoreV1NamespacedServiceResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReadCoreV1NamespacedServiceAccountRequest handles readCoreV1NamespacedServiceAccount operation.
//
// Read the specified ServiceAccount.
//
// GET /api/v1/namespaces/{namespace}/serviceaccounts/{name}
func (s *Server) handleReadCoreV1NamespacedServiceAccountRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readCoreV1NamespacedServiceAccount"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/v1/namespaces/{namespace}/serviceaccounts/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadCoreV1NamespacedServiceAccount",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadCoreV1NamespacedServiceAccount",
			ID:   "readCoreV1NamespacedServiceAccount",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ReadCoreV1NamespacedServiceAccount", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeReadCoreV1NamespacedServiceAccountParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadCoreV1NamespacedServiceAccountRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ReadCoreV1NamespacedServiceAccount",
			OperationSummary: "",
			OperationID:      "readCoreV1NamespacedServiceAccount",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadCoreV1NamespacedServiceAccountParams
			Response = ReadCoreV1NamespacedServiceAccountRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadCoreV1NamespacedServiceAccountParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReadCoreV1NamespacedServiceAccount(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReadCoreV1NamespacedServiceAccount(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadCoreV1NamespacedServiceAccountResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReadCoreV1NamespacedServiceStatusRequest handles readCoreV1NamespacedServiceStatus operation.
//
// Read status of the specified Service.
//
// GET /api/v1/namespaces/{namespace}/services/{name}/status
func (s *Server) handleReadCoreV1NamespacedServiceStatusRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readCoreV1NamespacedServiceStatus"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/v1/namespaces/{namespace}/services/{name}/status"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadCoreV1NamespacedServiceStatus",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadCoreV1NamespacedServiceStatus",
			ID:   "readCoreV1NamespacedServiceStatus",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ReadCoreV1NamespacedServiceStatus", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeReadCoreV1NamespacedServiceStatusParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadCoreV1NamespacedServiceStatusRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ReadCoreV1NamespacedServiceStatus",
			OperationSummary: "",
			OperationID:      "readCoreV1NamespacedServiceStatus",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadCoreV1NamespacedServiceStatusParams
			Response = ReadCoreV1NamespacedServiceStatusRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadCoreV1NamespacedServiceStatusParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReadCoreV1NamespacedServiceStatus(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReadCoreV1NamespacedServiceStatus(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadCoreV1NamespacedServiceStatusResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReadCoreV1NodeRequest handles readCoreV1Node operation.
//
// Read the specified Node.
//
// GET /api/v1/nodes/{name}
func (s *Server) handleReadCoreV1NodeRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readCoreV1Node"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/v1/nodes/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadCoreV1Node",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadCoreV1Node",
			ID:   "readCoreV1Node",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ReadCoreV1Node", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeReadCoreV1NodeParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadCoreV1NodeRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ReadCoreV1Node",
			OperationSummary: "",
			OperationID:      "readCoreV1Node",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadCoreV1NodeParams
			Response = ReadCoreV1NodeRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadCoreV1NodeParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReadCoreV1Node(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReadCoreV1Node(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadCoreV1NodeResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReadCoreV1NodeStatusRequest handles readCoreV1NodeStatus operation.
//
// Read status of the specified Node.
//
// GET /api/v1/nodes/{name}/status
func (s *Server) handleReadCoreV1NodeStatusRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readCoreV1NodeStatus"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/v1/nodes/{name}/status"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadCoreV1NodeStatus",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadCoreV1NodeStatus",
			ID:   "readCoreV1NodeStatus",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ReadCoreV1NodeStatus", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeReadCoreV1NodeStatusParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadCoreV1NodeStatusRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ReadCoreV1NodeStatus",
			OperationSummary: "",
			OperationID:      "readCoreV1NodeStatus",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadCoreV1NodeStatusParams
			Response = ReadCoreV1NodeStatusRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadCoreV1NodeStatusParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReadCoreV1NodeStatus(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReadCoreV1NodeStatus(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadCoreV1NodeStatusResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReadCoreV1PersistentVolumeRequest handles readCoreV1PersistentVolume operation.
//
// Read the specified PersistentVolume.
//
// GET /api/v1/persistentvolumes/{name}
func (s *Server) handleReadCoreV1PersistentVolumeRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readCoreV1PersistentVolume"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/v1/persistentvolumes/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadCoreV1PersistentVolume",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadCoreV1PersistentVolume",
			ID:   "readCoreV1PersistentVolume",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ReadCoreV1PersistentVolume", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeReadCoreV1PersistentVolumeParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadCoreV1PersistentVolumeRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ReadCoreV1PersistentVolume",
			OperationSummary: "",
			OperationID:      "readCoreV1PersistentVolume",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadCoreV1PersistentVolumeParams
			Response = ReadCoreV1PersistentVolumeRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadCoreV1PersistentVolumeParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReadCoreV1PersistentVolume(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReadCoreV1PersistentVolume(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadCoreV1PersistentVolumeResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReadCoreV1PersistentVolumeStatusRequest handles readCoreV1PersistentVolumeStatus operation.
//
// Read status of the specified PersistentVolume.
//
// GET /api/v1/persistentvolumes/{name}/status
func (s *Server) handleReadCoreV1PersistentVolumeStatusRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readCoreV1PersistentVolumeStatus"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/v1/persistentvolumes/{name}/status"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadCoreV1PersistentVolumeStatus",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadCoreV1PersistentVolumeStatus",
			ID:   "readCoreV1PersistentVolumeStatus",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ReadCoreV1PersistentVolumeStatus", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeReadCoreV1PersistentVolumeStatusParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadCoreV1PersistentVolumeStatusRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ReadCoreV1PersistentVolumeStatus",
			OperationSummary: "",
			OperationID:      "readCoreV1PersistentVolumeStatus",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadCoreV1PersistentVolumeStatusParams
			Response = ReadCoreV1PersistentVolumeStatusRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadCoreV1PersistentVolumeStatusParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReadCoreV1PersistentVolumeStatus(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReadCoreV1PersistentVolumeStatus(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadCoreV1PersistentVolumeStatusResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReadDiscoveryV1NamespacedEndpointSliceRequest handles readDiscoveryV1NamespacedEndpointSlice operation.
//
// Read the specified EndpointSlice.
//
// GET /apis/discovery.k8s.io/v1/namespaces/{namespace}/endpointslices/{name}
func (s *Server) handleReadDiscoveryV1NamespacedEndpointSliceRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readDiscoveryV1NamespacedEndpointSlice"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/discovery.k8s.io/v1/namespaces/{namespace}/endpointslices/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadDiscoveryV1NamespacedEndpointSlice",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadDiscoveryV1NamespacedEndpointSlice",
			ID:   "readDiscoveryV1NamespacedEndpointSlice",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ReadDiscoveryV1NamespacedEndpointSlice", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeReadDiscoveryV1NamespacedEndpointSliceParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadDiscoveryV1NamespacedEndpointSliceRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ReadDiscoveryV1NamespacedEndpointSlice",
			OperationSummary: "",
			OperationID:      "readDiscoveryV1NamespacedEndpointSlice",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadDiscoveryV1NamespacedEndpointSliceParams
			Response = ReadDiscoveryV1NamespacedEndpointSliceRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadDiscoveryV1NamespacedEndpointSliceParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReadDiscoveryV1NamespacedEndpointSlice(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReadDiscoveryV1NamespacedEndpointSlice(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadDiscoveryV1NamespacedEndpointSliceResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReadDiscoveryV1beta1NamespacedEndpointSliceRequest handles readDiscoveryV1beta1NamespacedEndpointSlice operation.
//
// Read the specified EndpointSlice.
//
// GET /apis/discovery.k8s.io/v1beta1/namespaces/{namespace}/endpointslices/{name}
func (s *Server) handleReadDiscoveryV1beta1NamespacedEndpointSliceRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readDiscoveryV1beta1NamespacedEndpointSlice"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/discovery.k8s.io/v1beta1/namespaces/{namespace}/endpointslices/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadDiscoveryV1beta1NamespacedEndpointSlice",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadDiscoveryV1beta1NamespacedEndpointSlice",
			ID:   "readDiscoveryV1beta1NamespacedEndpointSlice",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ReadDiscoveryV1beta1NamespacedEndpointSlice", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeReadDiscoveryV1beta1NamespacedEndpointSliceParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadDiscoveryV1beta1NamespacedEndpointSliceRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ReadDiscoveryV1beta1NamespacedEndpointSlice",
			OperationSummary: "",
			OperationID:      "readDiscoveryV1beta1NamespacedEndpointSlice",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadDiscoveryV1beta1NamespacedEndpointSliceParams
			Response = ReadDiscoveryV1beta1NamespacedEndpointSliceRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadDiscoveryV1beta1NamespacedEndpointSliceParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReadDiscoveryV1beta1NamespacedEndpointSlice(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReadDiscoveryV1beta1NamespacedEndpointSlice(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadDiscoveryV1beta1NamespacedEndpointSliceResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReadEventsV1NamespacedEventRequest handles readEventsV1NamespacedEvent operation.
//
// Read the specified Event.
//
// GET /apis/events.k8s.io/v1/namespaces/{namespace}/events/{name}
func (s *Server) handleReadEventsV1NamespacedEventRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readEventsV1NamespacedEvent"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/events.k8s.io/v1/namespaces/{namespace}/events/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadEventsV1NamespacedEvent",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadEventsV1NamespacedEvent",
			ID:   "readEventsV1NamespacedEvent",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ReadEventsV1NamespacedEvent", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeReadEventsV1NamespacedEventParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadEventsV1NamespacedEventRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ReadEventsV1NamespacedEvent",
			OperationSummary: "",
			OperationID:      "readEventsV1NamespacedEvent",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadEventsV1NamespacedEventParams
			Response = ReadEventsV1NamespacedEventRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadEventsV1NamespacedEventParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReadEventsV1NamespacedEvent(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReadEventsV1NamespacedEvent(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadEventsV1NamespacedEventResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReadEventsV1beta1NamespacedEventRequest handles readEventsV1beta1NamespacedEvent operation.
//
// Read the specified Event.
//
// GET /apis/events.k8s.io/v1beta1/namespaces/{namespace}/events/{name}
func (s *Server) handleReadEventsV1beta1NamespacedEventRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readEventsV1beta1NamespacedEvent"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/events.k8s.io/v1beta1/namespaces/{namespace}/events/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadEventsV1beta1NamespacedEvent",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadEventsV1beta1NamespacedEvent",
			ID:   "readEventsV1beta1NamespacedEvent",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ReadEventsV1beta1NamespacedEvent", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeReadEventsV1beta1NamespacedEventParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadEventsV1beta1NamespacedEventRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ReadEventsV1beta1NamespacedEvent",
			OperationSummary: "",
			OperationID:      "readEventsV1beta1NamespacedEvent",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadEventsV1beta1NamespacedEventParams
			Response = ReadEventsV1beta1NamespacedEventRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadEventsV1beta1NamespacedEventParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReadEventsV1beta1NamespacedEvent(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReadEventsV1beta1NamespacedEvent(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadEventsV1beta1NamespacedEventResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReadFlowcontrolApiserverV1beta1FlowSchemaRequest handles readFlowcontrolApiserverV1beta1FlowSchema operation.
//
// Read the specified FlowSchema.
//
// GET /apis/flowcontrol.apiserver.k8s.io/v1beta1/flowschemas/{name}
func (s *Server) handleReadFlowcontrolApiserverV1beta1FlowSchemaRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readFlowcontrolApiserverV1beta1FlowSchema"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/flowcontrol.apiserver.k8s.io/v1beta1/flowschemas/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadFlowcontrolApiserverV1beta1FlowSchema",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadFlowcontrolApiserverV1beta1FlowSchema",
			ID:   "readFlowcontrolApiserverV1beta1FlowSchema",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ReadFlowcontrolApiserverV1beta1FlowSchema", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeReadFlowcontrolApiserverV1beta1FlowSchemaParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadFlowcontrolApiserverV1beta1FlowSchemaRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ReadFlowcontrolApiserverV1beta1FlowSchema",
			OperationSummary: "",
			OperationID:      "readFlowcontrolApiserverV1beta1FlowSchema",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadFlowcontrolApiserverV1beta1FlowSchemaParams
			Response = ReadFlowcontrolApiserverV1beta1FlowSchemaRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadFlowcontrolApiserverV1beta1FlowSchemaParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReadFlowcontrolApiserverV1beta1FlowSchema(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReadFlowcontrolApiserverV1beta1FlowSchema(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadFlowcontrolApiserverV1beta1FlowSchemaResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReadFlowcontrolApiserverV1beta1FlowSchemaStatusRequest handles readFlowcontrolApiserverV1beta1FlowSchemaStatus operation.
//
// Read status of the specified FlowSchema.
//
// GET /apis/flowcontrol.apiserver.k8s.io/v1beta1/flowschemas/{name}/status
func (s *Server) handleReadFlowcontrolApiserverV1beta1FlowSchemaStatusRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readFlowcontrolApiserverV1beta1FlowSchemaStatus"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/flowcontrol.apiserver.k8s.io/v1beta1/flowschemas/{name}/status"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadFlowcontrolApiserverV1beta1FlowSchemaStatus",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadFlowcontrolApiserverV1beta1FlowSchemaStatus",
			ID:   "readFlowcontrolApiserverV1beta1FlowSchemaStatus",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ReadFlowcontrolApiserverV1beta1FlowSchemaStatus", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeReadFlowcontrolApiserverV1beta1FlowSchemaStatusParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadFlowcontrolApiserverV1beta1FlowSchemaStatusRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ReadFlowcontrolApiserverV1beta1FlowSchemaStatus",
			OperationSummary: "",
			OperationID:      "readFlowcontrolApiserverV1beta1FlowSchemaStatus",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadFlowcontrolApiserverV1beta1FlowSchemaStatusParams
			Response = ReadFlowcontrolApiserverV1beta1FlowSchemaStatusRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadFlowcontrolApiserverV1beta1FlowSchemaStatusParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReadFlowcontrolApiserverV1beta1FlowSchemaStatus(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReadFlowcontrolApiserverV1beta1FlowSchemaStatus(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadFlowcontrolApiserverV1beta1FlowSchemaStatusResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReadFlowcontrolApiserverV1beta1PriorityLevelConfigurationRequest handles readFlowcontrolApiserverV1beta1PriorityLevelConfiguration operation.
//
// Read the specified PriorityLevelConfiguration.
//
// GET /apis/flowcontrol.apiserver.k8s.io/v1beta1/prioritylevelconfigurations/{name}
func (s *Server) handleReadFlowcontrolApiserverV1beta1PriorityLevelConfigurationRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readFlowcontrolApiserverV1beta1PriorityLevelConfiguration"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/flowcontrol.apiserver.k8s.io/v1beta1/prioritylevelconfigurations/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadFlowcontrolApiserverV1beta1PriorityLevelConfiguration",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadFlowcontrolApiserverV1beta1PriorityLevelConfiguration",
			ID:   "readFlowcontrolApiserverV1beta1PriorityLevelConfiguration",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ReadFlowcontrolApiserverV1beta1PriorityLevelConfiguration", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeReadFlowcontrolApiserverV1beta1PriorityLevelConfigurationParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadFlowcontrolApiserverV1beta1PriorityLevelConfigurationRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ReadFlowcontrolApiserverV1beta1PriorityLevelConfiguration",
			OperationSummary: "",
			OperationID:      "readFlowcontrolApiserverV1beta1PriorityLevelConfiguration",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadFlowcontrolApiserverV1beta1PriorityLevelConfigurationParams
			Response = ReadFlowcontrolApiserverV1beta1PriorityLevelConfigurationRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadFlowcontrolApiserverV1beta1PriorityLevelConfigurationParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReadFlowcontrolApiserverV1beta1PriorityLevelConfiguration(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReadFlowcontrolApiserverV1beta1PriorityLevelConfiguration(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadFlowcontrolApiserverV1beta1PriorityLevelConfigurationResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReadFlowcontrolApiserverV1beta1PriorityLevelConfigurationStatusRequest handles readFlowcontrolApiserverV1beta1PriorityLevelConfigurationStatus operation.
//
// Read status of the specified PriorityLevelConfiguration.
//
// GET /apis/flowcontrol.apiserver.k8s.io/v1beta1/prioritylevelconfigurations/{name}/status
func (s *Server) handleReadFlowcontrolApiserverV1beta1PriorityLevelConfigurationStatusRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readFlowcontrolApiserverV1beta1PriorityLevelConfigurationStatus"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/flowcontrol.apiserver.k8s.io/v1beta1/prioritylevelconfigurations/{name}/status"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadFlowcontrolApiserverV1beta1PriorityLevelConfigurationStatus",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadFlowcontrolApiserverV1beta1PriorityLevelConfigurationStatus",
			ID:   "readFlowcontrolApiserverV1beta1PriorityLevelConfigurationStatus",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ReadFlowcontrolApiserverV1beta1PriorityLevelConfigurationStatus", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeReadFlowcontrolApiserverV1beta1PriorityLevelConfigurationStatusParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadFlowcontrolApiserverV1beta1PriorityLevelConfigurationStatusRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ReadFlowcontrolApiserverV1beta1PriorityLevelConfigurationStatus",
			OperationSummary: "",
			OperationID:      "readFlowcontrolApiserverV1beta1PriorityLevelConfigurationStatus",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadFlowcontrolApiserverV1beta1PriorityLevelConfigurationStatusParams
			Response = ReadFlowcontrolApiserverV1beta1PriorityLevelConfigurationStatusRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadFlowcontrolApiserverV1beta1PriorityLevelConfigurationStatusParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReadFlowcontrolApiserverV1beta1PriorityLevelConfigurationStatus(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReadFlowcontrolApiserverV1beta1PriorityLevelConfigurationStatus(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadFlowcontrolApiserverV1beta1PriorityLevelConfigurationStatusResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReadFlowcontrolApiserverV1beta2FlowSchemaRequest handles readFlowcontrolApiserverV1beta2FlowSchema operation.
//
// Read the specified FlowSchema.
//
// GET /apis/flowcontrol.apiserver.k8s.io/v1beta2/flowschemas/{name}
func (s *Server) handleReadFlowcontrolApiserverV1beta2FlowSchemaRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readFlowcontrolApiserverV1beta2FlowSchema"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/flowcontrol.apiserver.k8s.io/v1beta2/flowschemas/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadFlowcontrolApiserverV1beta2FlowSchema",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadFlowcontrolApiserverV1beta2FlowSchema",
			ID:   "readFlowcontrolApiserverV1beta2FlowSchema",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ReadFlowcontrolApiserverV1beta2FlowSchema", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeReadFlowcontrolApiserverV1beta2FlowSchemaParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadFlowcontrolApiserverV1beta2FlowSchemaRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ReadFlowcontrolApiserverV1beta2FlowSchema",
			OperationSummary: "",
			OperationID:      "readFlowcontrolApiserverV1beta2FlowSchema",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadFlowcontrolApiserverV1beta2FlowSchemaParams
			Response = ReadFlowcontrolApiserverV1beta2FlowSchemaRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadFlowcontrolApiserverV1beta2FlowSchemaParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReadFlowcontrolApiserverV1beta2FlowSchema(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReadFlowcontrolApiserverV1beta2FlowSchema(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadFlowcontrolApiserverV1beta2FlowSchemaResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReadFlowcontrolApiserverV1beta2FlowSchemaStatusRequest handles readFlowcontrolApiserverV1beta2FlowSchemaStatus operation.
//
// Read status of the specified FlowSchema.
//
// GET /apis/flowcontrol.apiserver.k8s.io/v1beta2/flowschemas/{name}/status
func (s *Server) handleReadFlowcontrolApiserverV1beta2FlowSchemaStatusRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readFlowcontrolApiserverV1beta2FlowSchemaStatus"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/flowcontrol.apiserver.k8s.io/v1beta2/flowschemas/{name}/status"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadFlowcontrolApiserverV1beta2FlowSchemaStatus",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadFlowcontrolApiserverV1beta2FlowSchemaStatus",
			ID:   "readFlowcontrolApiserverV1beta2FlowSchemaStatus",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ReadFlowcontrolApiserverV1beta2FlowSchemaStatus", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeReadFlowcontrolApiserverV1beta2FlowSchemaStatusParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadFlowcontrolApiserverV1beta2FlowSchemaStatusRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ReadFlowcontrolApiserverV1beta2FlowSchemaStatus",
			OperationSummary: "",
			OperationID:      "readFlowcontrolApiserverV1beta2FlowSchemaStatus",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadFlowcontrolApiserverV1beta2FlowSchemaStatusParams
			Response = ReadFlowcontrolApiserverV1beta2FlowSchemaStatusRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadFlowcontrolApiserverV1beta2FlowSchemaStatusParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReadFlowcontrolApiserverV1beta2FlowSchemaStatus(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReadFlowcontrolApiserverV1beta2FlowSchemaStatus(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadFlowcontrolApiserverV1beta2FlowSchemaStatusResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReadFlowcontrolApiserverV1beta2PriorityLevelConfigurationRequest handles readFlowcontrolApiserverV1beta2PriorityLevelConfiguration operation.
//
// Read the specified PriorityLevelConfiguration.
//
// GET /apis/flowcontrol.apiserver.k8s.io/v1beta2/prioritylevelconfigurations/{name}
func (s *Server) handleReadFlowcontrolApiserverV1beta2PriorityLevelConfigurationRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readFlowcontrolApiserverV1beta2PriorityLevelConfiguration"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/flowcontrol.apiserver.k8s.io/v1beta2/prioritylevelconfigurations/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadFlowcontrolApiserverV1beta2PriorityLevelConfiguration",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadFlowcontrolApiserverV1beta2PriorityLevelConfiguration",
			ID:   "readFlowcontrolApiserverV1beta2PriorityLevelConfiguration",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ReadFlowcontrolApiserverV1beta2PriorityLevelConfiguration", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeReadFlowcontrolApiserverV1beta2PriorityLevelConfigurationParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadFlowcontrolApiserverV1beta2PriorityLevelConfigurationRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ReadFlowcontrolApiserverV1beta2PriorityLevelConfiguration",
			OperationSummary: "",
			OperationID:      "readFlowcontrolApiserverV1beta2PriorityLevelConfiguration",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadFlowcontrolApiserverV1beta2PriorityLevelConfigurationParams
			Response = ReadFlowcontrolApiserverV1beta2PriorityLevelConfigurationRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadFlowcontrolApiserverV1beta2PriorityLevelConfigurationParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReadFlowcontrolApiserverV1beta2PriorityLevelConfiguration(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReadFlowcontrolApiserverV1beta2PriorityLevelConfiguration(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadFlowcontrolApiserverV1beta2PriorityLevelConfigurationResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReadFlowcontrolApiserverV1beta2PriorityLevelConfigurationStatusRequest handles readFlowcontrolApiserverV1beta2PriorityLevelConfigurationStatus operation.
//
// Read status of the specified PriorityLevelConfiguration.
//
// GET /apis/flowcontrol.apiserver.k8s.io/v1beta2/prioritylevelconfigurations/{name}/status
func (s *Server) handleReadFlowcontrolApiserverV1beta2PriorityLevelConfigurationStatusRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readFlowcontrolApiserverV1beta2PriorityLevelConfigurationStatus"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/flowcontrol.apiserver.k8s.io/v1beta2/prioritylevelconfigurations/{name}/status"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadFlowcontrolApiserverV1beta2PriorityLevelConfigurationStatus",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadFlowcontrolApiserverV1beta2PriorityLevelConfigurationStatus",
			ID:   "readFlowcontrolApiserverV1beta2PriorityLevelConfigurationStatus",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ReadFlowcontrolApiserverV1beta2PriorityLevelConfigurationStatus", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeReadFlowcontrolApiserverV1beta2PriorityLevelConfigurationStatusParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadFlowcontrolApiserverV1beta2PriorityLevelConfigurationStatusRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ReadFlowcontrolApiserverV1beta2PriorityLevelConfigurationStatus",
			OperationSummary: "",
			OperationID:      "readFlowcontrolApiserverV1beta2PriorityLevelConfigurationStatus",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadFlowcontrolApiserverV1beta2PriorityLevelConfigurationStatusParams
			Response = ReadFlowcontrolApiserverV1beta2PriorityLevelConfigurationStatusRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadFlowcontrolApiserverV1beta2PriorityLevelConfigurationStatusParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReadFlowcontrolApiserverV1beta2PriorityLevelConfigurationStatus(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReadFlowcontrolApiserverV1beta2PriorityLevelConfigurationStatus(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadFlowcontrolApiserverV1beta2PriorityLevelConfigurationStatusResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReadInternalApiserverV1alpha1StorageVersionRequest handles readInternalApiserverV1alpha1StorageVersion operation.
//
// Read the specified StorageVersion.
//
// GET /apis/internal.apiserver.k8s.io/v1alpha1/storageversions/{name}
func (s *Server) handleReadInternalApiserverV1alpha1StorageVersionRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readInternalApiserverV1alpha1StorageVersion"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/internal.apiserver.k8s.io/v1alpha1/storageversions/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadInternalApiserverV1alpha1StorageVersion",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadInternalApiserverV1alpha1StorageVersion",
			ID:   "readInternalApiserverV1alpha1StorageVersion",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ReadInternalApiserverV1alpha1StorageVersion", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeReadInternalApiserverV1alpha1StorageVersionParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadInternalApiserverV1alpha1StorageVersionRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ReadInternalApiserverV1alpha1StorageVersion",
			OperationSummary: "",
			OperationID:      "readInternalApiserverV1alpha1StorageVersion",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadInternalApiserverV1alpha1StorageVersionParams
			Response = ReadInternalApiserverV1alpha1StorageVersionRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadInternalApiserverV1alpha1StorageVersionParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReadInternalApiserverV1alpha1StorageVersion(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReadInternalApiserverV1alpha1StorageVersion(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadInternalApiserverV1alpha1StorageVersionResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReadInternalApiserverV1alpha1StorageVersionStatusRequest handles readInternalApiserverV1alpha1StorageVersionStatus operation.
//
// Read status of the specified StorageVersion.
//
// GET /apis/internal.apiserver.k8s.io/v1alpha1/storageversions/{name}/status
func (s *Server) handleReadInternalApiserverV1alpha1StorageVersionStatusRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readInternalApiserverV1alpha1StorageVersionStatus"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/internal.apiserver.k8s.io/v1alpha1/storageversions/{name}/status"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadInternalApiserverV1alpha1StorageVersionStatus",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadInternalApiserverV1alpha1StorageVersionStatus",
			ID:   "readInternalApiserverV1alpha1StorageVersionStatus",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ReadInternalApiserverV1alpha1StorageVersionStatus", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeReadInternalApiserverV1alpha1StorageVersionStatusParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadInternalApiserverV1alpha1StorageVersionStatusRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ReadInternalApiserverV1alpha1StorageVersionStatus",
			OperationSummary: "",
			OperationID:      "readInternalApiserverV1alpha1StorageVersionStatus",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadInternalApiserverV1alpha1StorageVersionStatusParams
			Response = ReadInternalApiserverV1alpha1StorageVersionStatusRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadInternalApiserverV1alpha1StorageVersionStatusParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReadInternalApiserverV1alpha1StorageVersionStatus(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReadInternalApiserverV1alpha1StorageVersionStatus(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadInternalApiserverV1alpha1StorageVersionStatusResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReadNetworkingV1IngressClassRequest handles readNetworkingV1IngressClass operation.
//
// Read the specified IngressClass.
//
// GET /apis/networking.k8s.io/v1/ingressclasses/{name}
func (s *Server) handleReadNetworkingV1IngressClassRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readNetworkingV1IngressClass"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/networking.k8s.io/v1/ingressclasses/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadNetworkingV1IngressClass",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadNetworkingV1IngressClass",
			ID:   "readNetworkingV1IngressClass",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ReadNetworkingV1IngressClass", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeReadNetworkingV1IngressClassParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadNetworkingV1IngressClassRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ReadNetworkingV1IngressClass",
			OperationSummary: "",
			OperationID:      "readNetworkingV1IngressClass",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadNetworkingV1IngressClassParams
			Response = ReadNetworkingV1IngressClassRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadNetworkingV1IngressClassParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReadNetworkingV1IngressClass(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReadNetworkingV1IngressClass(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadNetworkingV1IngressClassResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReadNetworkingV1NamespacedIngressRequest handles readNetworkingV1NamespacedIngress operation.
//
// Read the specified Ingress.
//
// GET /apis/networking.k8s.io/v1/namespaces/{namespace}/ingresses/{name}
func (s *Server) handleReadNetworkingV1NamespacedIngressRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readNetworkingV1NamespacedIngress"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/networking.k8s.io/v1/namespaces/{namespace}/ingresses/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadNetworkingV1NamespacedIngress",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadNetworkingV1NamespacedIngress",
			ID:   "readNetworkingV1NamespacedIngress",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ReadNetworkingV1NamespacedIngress", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeReadNetworkingV1NamespacedIngressParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadNetworkingV1NamespacedIngressRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ReadNetworkingV1NamespacedIngress",
			OperationSummary: "",
			OperationID:      "readNetworkingV1NamespacedIngress",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadNetworkingV1NamespacedIngressParams
			Response = ReadNetworkingV1NamespacedIngressRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadNetworkingV1NamespacedIngressParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReadNetworkingV1NamespacedIngress(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReadNetworkingV1NamespacedIngress(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadNetworkingV1NamespacedIngressResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReadNetworkingV1NamespacedIngressStatusRequest handles readNetworkingV1NamespacedIngressStatus operation.
//
// Read status of the specified Ingress.
//
// GET /apis/networking.k8s.io/v1/namespaces/{namespace}/ingresses/{name}/status
func (s *Server) handleReadNetworkingV1NamespacedIngressStatusRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readNetworkingV1NamespacedIngressStatus"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/networking.k8s.io/v1/namespaces/{namespace}/ingresses/{name}/status"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadNetworkingV1NamespacedIngressStatus",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadNetworkingV1NamespacedIngressStatus",
			ID:   "readNetworkingV1NamespacedIngressStatus",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ReadNetworkingV1NamespacedIngressStatus", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeReadNetworkingV1NamespacedIngressStatusParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadNetworkingV1NamespacedIngressStatusRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ReadNetworkingV1NamespacedIngressStatus",
			OperationSummary: "",
			OperationID:      "readNetworkingV1NamespacedIngressStatus",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadNetworkingV1NamespacedIngressStatusParams
			Response = ReadNetworkingV1NamespacedIngressStatusRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadNetworkingV1NamespacedIngressStatusParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReadNetworkingV1NamespacedIngressStatus(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReadNetworkingV1NamespacedIngressStatus(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadNetworkingV1NamespacedIngressStatusResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReadNetworkingV1NamespacedNetworkPolicyRequest handles readNetworkingV1NamespacedNetworkPolicy operation.
//
// Read the specified NetworkPolicy.
//
// GET /apis/networking.k8s.io/v1/namespaces/{namespace}/networkpolicies/{name}
func (s *Server) handleReadNetworkingV1NamespacedNetworkPolicyRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readNetworkingV1NamespacedNetworkPolicy"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/networking.k8s.io/v1/namespaces/{namespace}/networkpolicies/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadNetworkingV1NamespacedNetworkPolicy",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadNetworkingV1NamespacedNetworkPolicy",
			ID:   "readNetworkingV1NamespacedNetworkPolicy",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ReadNetworkingV1NamespacedNetworkPolicy", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeReadNetworkingV1NamespacedNetworkPolicyParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadNetworkingV1NamespacedNetworkPolicyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ReadNetworkingV1NamespacedNetworkPolicy",
			OperationSummary: "",
			OperationID:      "readNetworkingV1NamespacedNetworkPolicy",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadNetworkingV1NamespacedNetworkPolicyParams
			Response = ReadNetworkingV1NamespacedNetworkPolicyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadNetworkingV1NamespacedNetworkPolicyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReadNetworkingV1NamespacedNetworkPolicy(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReadNetworkingV1NamespacedNetworkPolicy(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadNetworkingV1NamespacedNetworkPolicyResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReadNodeV1RuntimeClassRequest handles readNodeV1RuntimeClass operation.
//
// Read the specified RuntimeClass.
//
// GET /apis/node.k8s.io/v1/runtimeclasses/{name}
func (s *Server) handleReadNodeV1RuntimeClassRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readNodeV1RuntimeClass"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/node.k8s.io/v1/runtimeclasses/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadNodeV1RuntimeClass",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadNodeV1RuntimeClass",
			ID:   "readNodeV1RuntimeClass",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ReadNodeV1RuntimeClass", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeReadNodeV1RuntimeClassParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadNodeV1RuntimeClassRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ReadNodeV1RuntimeClass",
			OperationSummary: "",
			OperationID:      "readNodeV1RuntimeClass",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadNodeV1RuntimeClassParams
			Response = ReadNodeV1RuntimeClassRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadNodeV1RuntimeClassParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReadNodeV1RuntimeClass(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReadNodeV1RuntimeClass(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadNodeV1RuntimeClassResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReadNodeV1alpha1RuntimeClassRequest handles readNodeV1alpha1RuntimeClass operation.
//
// Read the specified RuntimeClass.
//
// GET /apis/node.k8s.io/v1alpha1/runtimeclasses/{name}
func (s *Server) handleReadNodeV1alpha1RuntimeClassRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readNodeV1alpha1RuntimeClass"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/node.k8s.io/v1alpha1/runtimeclasses/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadNodeV1alpha1RuntimeClass",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadNodeV1alpha1RuntimeClass",
			ID:   "readNodeV1alpha1RuntimeClass",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ReadNodeV1alpha1RuntimeClass", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeReadNodeV1alpha1RuntimeClassParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadNodeV1alpha1RuntimeClassRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ReadNodeV1alpha1RuntimeClass",
			OperationSummary: "",
			OperationID:      "readNodeV1alpha1RuntimeClass",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadNodeV1alpha1RuntimeClassParams
			Response = ReadNodeV1alpha1RuntimeClassRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadNodeV1alpha1RuntimeClassParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReadNodeV1alpha1RuntimeClass(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReadNodeV1alpha1RuntimeClass(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadNodeV1alpha1RuntimeClassResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReadNodeV1beta1RuntimeClassRequest handles readNodeV1beta1RuntimeClass operation.
//
// Read the specified RuntimeClass.
//
// GET /apis/node.k8s.io/v1beta1/runtimeclasses/{name}
func (s *Server) handleReadNodeV1beta1RuntimeClassRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readNodeV1beta1RuntimeClass"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/node.k8s.io/v1beta1/runtimeclasses/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadNodeV1beta1RuntimeClass",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadNodeV1beta1RuntimeClass",
			ID:   "readNodeV1beta1RuntimeClass",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ReadNodeV1beta1RuntimeClass", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeReadNodeV1beta1RuntimeClassParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadNodeV1beta1RuntimeClassRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ReadNodeV1beta1RuntimeClass",
			OperationSummary: "",
			OperationID:      "readNodeV1beta1RuntimeClass",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadNodeV1beta1RuntimeClassParams
			Response = ReadNodeV1beta1RuntimeClassRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadNodeV1beta1RuntimeClassParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReadNodeV1beta1RuntimeClass(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReadNodeV1beta1RuntimeClass(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadNodeV1beta1RuntimeClassResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReadPolicyV1NamespacedPodDisruptionBudgetRequest handles readPolicyV1NamespacedPodDisruptionBudget operation.
//
// Read the specified PodDisruptionBudget.
//
// GET /apis/policy/v1/namespaces/{namespace}/poddisruptionbudgets/{name}
func (s *Server) handleReadPolicyV1NamespacedPodDisruptionBudgetRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readPolicyV1NamespacedPodDisruptionBudget"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/policy/v1/namespaces/{namespace}/poddisruptionbudgets/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadPolicyV1NamespacedPodDisruptionBudget",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadPolicyV1NamespacedPodDisruptionBudget",
			ID:   "readPolicyV1NamespacedPodDisruptionBudget",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ReadPolicyV1NamespacedPodDisruptionBudget", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeReadPolicyV1NamespacedPodDisruptionBudgetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadPolicyV1NamespacedPodDisruptionBudgetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ReadPolicyV1NamespacedPodDisruptionBudget",
			OperationSummary: "",
			OperationID:      "readPolicyV1NamespacedPodDisruptionBudget",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadPolicyV1NamespacedPodDisruptionBudgetParams
			Response = ReadPolicyV1NamespacedPodDisruptionBudgetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadPolicyV1NamespacedPodDisruptionBudgetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReadPolicyV1NamespacedPodDisruptionBudget(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReadPolicyV1NamespacedPodDisruptionBudget(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadPolicyV1NamespacedPodDisruptionBudgetResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReadPolicyV1NamespacedPodDisruptionBudgetStatusRequest handles readPolicyV1NamespacedPodDisruptionBudgetStatus operation.
//
// Read status of the specified PodDisruptionBudget.
//
// GET /apis/policy/v1/namespaces/{namespace}/poddisruptionbudgets/{name}/status
func (s *Server) handleReadPolicyV1NamespacedPodDisruptionBudgetStatusRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readPolicyV1NamespacedPodDisruptionBudgetStatus"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/policy/v1/namespaces/{namespace}/poddisruptionbudgets/{name}/status"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadPolicyV1NamespacedPodDisruptionBudgetStatus",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadPolicyV1NamespacedPodDisruptionBudgetStatus",
			ID:   "readPolicyV1NamespacedPodDisruptionBudgetStatus",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ReadPolicyV1NamespacedPodDisruptionBudgetStatus", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeReadPolicyV1NamespacedPodDisruptionBudgetStatusParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadPolicyV1NamespacedPodDisruptionBudgetStatusRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ReadPolicyV1NamespacedPodDisruptionBudgetStatus",
			OperationSummary: "",
			OperationID:      "readPolicyV1NamespacedPodDisruptionBudgetStatus",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadPolicyV1NamespacedPodDisruptionBudgetStatusParams
			Response = ReadPolicyV1NamespacedPodDisruptionBudgetStatusRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadPolicyV1NamespacedPodDisruptionBudgetStatusParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReadPolicyV1NamespacedPodDisruptionBudgetStatus(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReadPolicyV1NamespacedPodDisruptionBudgetStatus(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadPolicyV1NamespacedPodDisruptionBudgetStatusResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReadPolicyV1beta1NamespacedPodDisruptionBudgetRequest handles readPolicyV1beta1NamespacedPodDisruptionBudget operation.
//
// Read the specified PodDisruptionBudget.
//
// GET /apis/policy/v1beta1/namespaces/{namespace}/poddisruptionbudgets/{name}
func (s *Server) handleReadPolicyV1beta1NamespacedPodDisruptionBudgetRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readPolicyV1beta1NamespacedPodDisruptionBudget"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/policy/v1beta1/namespaces/{namespace}/poddisruptionbudgets/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadPolicyV1beta1NamespacedPodDisruptionBudget",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadPolicyV1beta1NamespacedPodDisruptionBudget",
			ID:   "readPolicyV1beta1NamespacedPodDisruptionBudget",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ReadPolicyV1beta1NamespacedPodDisruptionBudget", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeReadPolicyV1beta1NamespacedPodDisruptionBudgetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadPolicyV1beta1NamespacedPodDisruptionBudgetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ReadPolicyV1beta1NamespacedPodDisruptionBudget",
			OperationSummary: "",
			OperationID:      "readPolicyV1beta1NamespacedPodDisruptionBudget",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadPolicyV1beta1NamespacedPodDisruptionBudgetParams
			Response = ReadPolicyV1beta1NamespacedPodDisruptionBudgetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadPolicyV1beta1NamespacedPodDisruptionBudgetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReadPolicyV1beta1NamespacedPodDisruptionBudget(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReadPolicyV1beta1NamespacedPodDisruptionBudget(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadPolicyV1beta1NamespacedPodDisruptionBudgetResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReadPolicyV1beta1NamespacedPodDisruptionBudgetStatusRequest handles readPolicyV1beta1NamespacedPodDisruptionBudgetStatus operation.
//
// Read status of the specified PodDisruptionBudget.
//
// GET /apis/policy/v1beta1/namespaces/{namespace}/poddisruptionbudgets/{name}/status
func (s *Server) handleReadPolicyV1beta1NamespacedPodDisruptionBudgetStatusRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readPolicyV1beta1NamespacedPodDisruptionBudgetStatus"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/policy/v1beta1/namespaces/{namespace}/poddisruptionbudgets/{name}/status"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadPolicyV1beta1NamespacedPodDisruptionBudgetStatus",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadPolicyV1beta1NamespacedPodDisruptionBudgetStatus",
			ID:   "readPolicyV1beta1NamespacedPodDisruptionBudgetStatus",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ReadPolicyV1beta1NamespacedPodDisruptionBudgetStatus", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeReadPolicyV1beta1NamespacedPodDisruptionBudgetStatusParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadPolicyV1beta1NamespacedPodDisruptionBudgetStatusRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ReadPolicyV1beta1NamespacedPodDisruptionBudgetStatus",
			OperationSummary: "",
			OperationID:      "readPolicyV1beta1NamespacedPodDisruptionBudgetStatus",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadPolicyV1beta1NamespacedPodDisruptionBudgetStatusParams
			Response = ReadPolicyV1beta1NamespacedPodDisruptionBudgetStatusRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadPolicyV1beta1NamespacedPodDisruptionBudgetStatusParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReadPolicyV1beta1NamespacedPodDisruptionBudgetStatus(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReadPolicyV1beta1NamespacedPodDisruptionBudgetStatus(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadPolicyV1beta1NamespacedPodDisruptionBudgetStatusResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReadPolicyV1beta1PodSecurityPolicyRequest handles readPolicyV1beta1PodSecurityPolicy operation.
//
// Read the specified PodSecurityPolicy.
//
// GET /apis/policy/v1beta1/podsecuritypolicies/{name}
func (s *Server) handleReadPolicyV1beta1PodSecurityPolicyRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readPolicyV1beta1PodSecurityPolicy"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/policy/v1beta1/podsecuritypolicies/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadPolicyV1beta1PodSecurityPolicy",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadPolicyV1beta1PodSecurityPolicy",
			ID:   "readPolicyV1beta1PodSecurityPolicy",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ReadPolicyV1beta1PodSecurityPolicy", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeReadPolicyV1beta1PodSecurityPolicyParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadPolicyV1beta1PodSecurityPolicyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ReadPolicyV1beta1PodSecurityPolicy",
			OperationSummary: "",
			OperationID:      "readPolicyV1beta1PodSecurityPolicy",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadPolicyV1beta1PodSecurityPolicyParams
			Response = ReadPolicyV1beta1PodSecurityPolicyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadPolicyV1beta1PodSecurityPolicyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReadPolicyV1beta1PodSecurityPolicy(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReadPolicyV1beta1PodSecurityPolicy(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadPolicyV1beta1PodSecurityPolicyResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReadRbacAuthorizationV1ClusterRoleRequest handles readRbacAuthorizationV1ClusterRole operation.
//
// Read the specified ClusterRole.
//
// GET /apis/rbac.authorization.k8s.io/v1/clusterroles/{name}
func (s *Server) handleReadRbacAuthorizationV1ClusterRoleRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readRbacAuthorizationV1ClusterRole"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/rbac.authorization.k8s.io/v1/clusterroles/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadRbacAuthorizationV1ClusterRole",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadRbacAuthorizationV1ClusterRole",
			ID:   "readRbacAuthorizationV1ClusterRole",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ReadRbacAuthorizationV1ClusterRole", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeReadRbacAuthorizationV1ClusterRoleParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadRbacAuthorizationV1ClusterRoleRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ReadRbacAuthorizationV1ClusterRole",
			OperationSummary: "",
			OperationID:      "readRbacAuthorizationV1ClusterRole",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadRbacAuthorizationV1ClusterRoleParams
			Response = ReadRbacAuthorizationV1ClusterRoleRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadRbacAuthorizationV1ClusterRoleParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReadRbacAuthorizationV1ClusterRole(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReadRbacAuthorizationV1ClusterRole(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadRbacAuthorizationV1ClusterRoleResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReadRbacAuthorizationV1ClusterRoleBindingRequest handles readRbacAuthorizationV1ClusterRoleBinding operation.
//
// Read the specified ClusterRoleBinding.
//
// GET /apis/rbac.authorization.k8s.io/v1/clusterrolebindings/{name}
func (s *Server) handleReadRbacAuthorizationV1ClusterRoleBindingRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readRbacAuthorizationV1ClusterRoleBinding"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/rbac.authorization.k8s.io/v1/clusterrolebindings/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadRbacAuthorizationV1ClusterRoleBinding",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadRbacAuthorizationV1ClusterRoleBinding",
			ID:   "readRbacAuthorizationV1ClusterRoleBinding",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ReadRbacAuthorizationV1ClusterRoleBinding", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeReadRbacAuthorizationV1ClusterRoleBindingParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadRbacAuthorizationV1ClusterRoleBindingRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ReadRbacAuthorizationV1ClusterRoleBinding",
			OperationSummary: "",
			OperationID:      "readRbacAuthorizationV1ClusterRoleBinding",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadRbacAuthorizationV1ClusterRoleBindingParams
			Response = ReadRbacAuthorizationV1ClusterRoleBindingRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadRbacAuthorizationV1ClusterRoleBindingParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReadRbacAuthorizationV1ClusterRoleBinding(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReadRbacAuthorizationV1ClusterRoleBinding(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadRbacAuthorizationV1ClusterRoleBindingResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReadRbacAuthorizationV1NamespacedRoleRequest handles readRbacAuthorizationV1NamespacedRole operation.
//
// Read the specified Role.
//
// GET /apis/rbac.authorization.k8s.io/v1/namespaces/{namespace}/roles/{name}
func (s *Server) handleReadRbacAuthorizationV1NamespacedRoleRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readRbacAuthorizationV1NamespacedRole"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/rbac.authorization.k8s.io/v1/namespaces/{namespace}/roles/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadRbacAuthorizationV1NamespacedRole",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadRbacAuthorizationV1NamespacedRole",
			ID:   "readRbacAuthorizationV1NamespacedRole",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ReadRbacAuthorizationV1NamespacedRole", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeReadRbacAuthorizationV1NamespacedRoleParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadRbacAuthorizationV1NamespacedRoleRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ReadRbacAuthorizationV1NamespacedRole",
			OperationSummary: "",
			OperationID:      "readRbacAuthorizationV1NamespacedRole",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadRbacAuthorizationV1NamespacedRoleParams
			Response = ReadRbacAuthorizationV1NamespacedRoleRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadRbacAuthorizationV1NamespacedRoleParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReadRbacAuthorizationV1NamespacedRole(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReadRbacAuthorizationV1NamespacedRole(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadRbacAuthorizationV1NamespacedRoleResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReadRbacAuthorizationV1NamespacedRoleBindingRequest handles readRbacAuthorizationV1NamespacedRoleBinding operation.
//
// Read the specified RoleBinding.
//
// GET /apis/rbac.authorization.k8s.io/v1/namespaces/{namespace}/rolebindings/{name}
func (s *Server) handleReadRbacAuthorizationV1NamespacedRoleBindingRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readRbacAuthorizationV1NamespacedRoleBinding"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/rbac.authorization.k8s.io/v1/namespaces/{namespace}/rolebindings/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadRbacAuthorizationV1NamespacedRoleBinding",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadRbacAuthorizationV1NamespacedRoleBinding",
			ID:   "readRbacAuthorizationV1NamespacedRoleBinding",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ReadRbacAuthorizationV1NamespacedRoleBinding", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeReadRbacAuthorizationV1NamespacedRoleBindingParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadRbacAuthorizationV1NamespacedRoleBindingRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ReadRbacAuthorizationV1NamespacedRoleBinding",
			OperationSummary: "",
			OperationID:      "readRbacAuthorizationV1NamespacedRoleBinding",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadRbacAuthorizationV1NamespacedRoleBindingParams
			Response = ReadRbacAuthorizationV1NamespacedRoleBindingRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadRbacAuthorizationV1NamespacedRoleBindingParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReadRbacAuthorizationV1NamespacedRoleBinding(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReadRbacAuthorizationV1NamespacedRoleBinding(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadRbacAuthorizationV1NamespacedRoleBindingResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReadSchedulingV1PriorityClassRequest handles readSchedulingV1PriorityClass operation.
//
// Read the specified PriorityClass.
//
// GET /apis/scheduling.k8s.io/v1/priorityclasses/{name}
func (s *Server) handleReadSchedulingV1PriorityClassRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readSchedulingV1PriorityClass"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/scheduling.k8s.io/v1/priorityclasses/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadSchedulingV1PriorityClass",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadSchedulingV1PriorityClass",
			ID:   "readSchedulingV1PriorityClass",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ReadSchedulingV1PriorityClass", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeReadSchedulingV1PriorityClassParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadSchedulingV1PriorityClassRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ReadSchedulingV1PriorityClass",
			OperationSummary: "",
			OperationID:      "readSchedulingV1PriorityClass",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadSchedulingV1PriorityClassParams
			Response = ReadSchedulingV1PriorityClassRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadSchedulingV1PriorityClassParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReadSchedulingV1PriorityClass(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReadSchedulingV1PriorityClass(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadSchedulingV1PriorityClassResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReadStorageV1CSIDriverRequest handles readStorageV1CSIDriver operation.
//
// Read the specified CSIDriver.
//
// GET /apis/storage.k8s.io/v1/csidrivers/{name}
func (s *Server) handleReadStorageV1CSIDriverRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readStorageV1CSIDriver"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/storage.k8s.io/v1/csidrivers/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadStorageV1CSIDriver",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadStorageV1CSIDriver",
			ID:   "readStorageV1CSIDriver",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ReadStorageV1CSIDriver", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeReadStorageV1CSIDriverParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadStorageV1CSIDriverRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ReadStorageV1CSIDriver",
			OperationSummary: "",
			OperationID:      "readStorageV1CSIDriver",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadStorageV1CSIDriverParams
			Response = ReadStorageV1CSIDriverRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadStorageV1CSIDriverParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReadStorageV1CSIDriver(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReadStorageV1CSIDriver(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadStorageV1CSIDriverResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReadStorageV1CSINodeRequest handles readStorageV1CSINode operation.
//
// Read the specified CSINode.
//
// GET /apis/storage.k8s.io/v1/csinodes/{name}
func (s *Server) handleReadStorageV1CSINodeRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readStorageV1CSINode"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/storage.k8s.io/v1/csinodes/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadStorageV1CSINode",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadStorageV1CSINode",
			ID:   "readStorageV1CSINode",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ReadStorageV1CSINode", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeReadStorageV1CSINodeParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadStorageV1CSINodeRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ReadStorageV1CSINode",
			OperationSummary: "",
			OperationID:      "readStorageV1CSINode",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadStorageV1CSINodeParams
			Response = ReadStorageV1CSINodeRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadStorageV1CSINodeParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReadStorageV1CSINode(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReadStorageV1CSINode(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadStorageV1CSINodeResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReadStorageV1StorageClassRequest handles readStorageV1StorageClass operation.
//
// Read the specified StorageClass.
//
// GET /apis/storage.k8s.io/v1/storageclasses/{name}
func (s *Server) handleReadStorageV1StorageClassRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readStorageV1StorageClass"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/storage.k8s.io/v1/storageclasses/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadStorageV1StorageClass",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadStorageV1StorageClass",
			ID:   "readStorageV1StorageClass",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ReadStorageV1StorageClass", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeReadStorageV1StorageClassParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadStorageV1StorageClassRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ReadStorageV1StorageClass",
			OperationSummary: "",
			OperationID:      "readStorageV1StorageClass",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadStorageV1StorageClassParams
			Response = ReadStorageV1StorageClassRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadStorageV1StorageClassParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReadStorageV1StorageClass(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReadStorageV1StorageClass(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadStorageV1StorageClassResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReadStorageV1VolumeAttachmentRequest handles readStorageV1VolumeAttachment operation.
//
// Read the specified VolumeAttachment.
//
// GET /apis/storage.k8s.io/v1/volumeattachments/{name}
func (s *Server) handleReadStorageV1VolumeAttachmentRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readStorageV1VolumeAttachment"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/storage.k8s.io/v1/volumeattachments/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadStorageV1VolumeAttachment",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadStorageV1VolumeAttachment",
			ID:   "readStorageV1VolumeAttachment",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ReadStorageV1VolumeAttachment", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeReadStorageV1VolumeAttachmentParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadStorageV1VolumeAttachmentRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ReadStorageV1VolumeAttachment",
			OperationSummary: "",
			OperationID:      "readStorageV1VolumeAttachment",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadStorageV1VolumeAttachmentParams
			Response = ReadStorageV1VolumeAttachmentRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadStorageV1VolumeAttachmentParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReadStorageV1VolumeAttachment(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReadStorageV1VolumeAttachment(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadStorageV1VolumeAttachmentResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReadStorageV1VolumeAttachmentStatusRequest handles readStorageV1VolumeAttachmentStatus operation.
//
// Read status of the specified VolumeAttachment.
//
// GET /apis/storage.k8s.io/v1/volumeattachments/{name}/status
func (s *Server) handleReadStorageV1VolumeAttachmentStatusRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readStorageV1VolumeAttachmentStatus"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/storage.k8s.io/v1/volumeattachments/{name}/status"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadStorageV1VolumeAttachmentStatus",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadStorageV1VolumeAttachmentStatus",
			ID:   "readStorageV1VolumeAttachmentStatus",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ReadStorageV1VolumeAttachmentStatus", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeReadStorageV1VolumeAttachmentStatusParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadStorageV1VolumeAttachmentStatusRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ReadStorageV1VolumeAttachmentStatus",
			OperationSummary: "",
			OperationID:      "readStorageV1VolumeAttachmentStatus",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadStorageV1VolumeAttachmentStatusParams
			Response = ReadStorageV1VolumeAttachmentStatusRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadStorageV1VolumeAttachmentStatusParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReadStorageV1VolumeAttachmentStatus(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReadStorageV1VolumeAttachmentStatus(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadStorageV1VolumeAttachmentStatusResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReadStorageV1alpha1NamespacedCSIStorageCapacityRequest handles readStorageV1alpha1NamespacedCSIStorageCapacity operation.
//
// Read the specified CSIStorageCapacity.
//
// GET /apis/storage.k8s.io/v1alpha1/namespaces/{namespace}/csistoragecapacities/{name}
func (s *Server) handleReadStorageV1alpha1NamespacedCSIStorageCapacityRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readStorageV1alpha1NamespacedCSIStorageCapacity"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/storage.k8s.io/v1alpha1/namespaces/{namespace}/csistoragecapacities/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadStorageV1alpha1NamespacedCSIStorageCapacity",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadStorageV1alpha1NamespacedCSIStorageCapacity",
			ID:   "readStorageV1alpha1NamespacedCSIStorageCapacity",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ReadStorageV1alpha1NamespacedCSIStorageCapacity", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeReadStorageV1alpha1NamespacedCSIStorageCapacityParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadStorageV1alpha1NamespacedCSIStorageCapacityRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ReadStorageV1alpha1NamespacedCSIStorageCapacity",
			OperationSummary: "",
			OperationID:      "readStorageV1alpha1NamespacedCSIStorageCapacity",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadStorageV1alpha1NamespacedCSIStorageCapacityParams
			Response = ReadStorageV1alpha1NamespacedCSIStorageCapacityRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadStorageV1alpha1NamespacedCSIStorageCapacityParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReadStorageV1alpha1NamespacedCSIStorageCapacity(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReadStorageV1alpha1NamespacedCSIStorageCapacity(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadStorageV1alpha1NamespacedCSIStorageCapacityResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReadStorageV1beta1NamespacedCSIStorageCapacityRequest handles readStorageV1beta1NamespacedCSIStorageCapacity operation.
//
// Read the specified CSIStorageCapacity.
//
// GET /apis/storage.k8s.io/v1beta1/namespaces/{namespace}/csistoragecapacities/{name}
func (s *Server) handleReadStorageV1beta1NamespacedCSIStorageCapacityRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readStorageV1beta1NamespacedCSIStorageCapacity"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/storage.k8s.io/v1beta1/namespaces/{namespace}/csistoragecapacities/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadStorageV1beta1NamespacedCSIStorageCapacity",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadStorageV1beta1NamespacedCSIStorageCapacity",
			ID:   "readStorageV1beta1NamespacedCSIStorageCapacity",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "ReadStorageV1beta1NamespacedCSIStorageCapacity", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeReadStorageV1beta1NamespacedCSIStorageCapacityParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadStorageV1beta1NamespacedCSIStorageCapacityRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ReadStorageV1beta1NamespacedCSIStorageCapacity",
			OperationSummary: "",
			OperationID:      "readStorageV1beta1NamespacedCSIStorageCapacity",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadStorageV1beta1NamespacedCSIStorageCapacityParams
			Response = ReadStorageV1beta1NamespacedCSIStorageCapacityRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadStorageV1beta1NamespacedCSIStorageCapacityParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReadStorageV1beta1NamespacedCSIStorageCapacity(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReadStorageV1beta1NamespacedCSIStorageCapacity(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadStorageV1beta1NamespacedCSIStorageCapacityResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchAdmissionregistrationV1MutatingWebhookConfigurationRequest handles watchAdmissionregistrationV1MutatingWebhookConfiguration operation.
//
// Watch changes to an object of kind MutatingWebhookConfiguration. deprecated: use the 'watch'
// parameter with a list operation instead, filtered to a single item with the 'fieldSelector'
// parameter.
//
// GET /apis/admissionregistration.k8s.io/v1/watch/mutatingwebhookconfigurations/{name}
func (s *Server) handleWatchAdmissionregistrationV1MutatingWebhookConfigurationRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchAdmissionregistrationV1MutatingWebhookConfiguration"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/admissionregistration.k8s.io/v1/watch/mutatingwebhookconfigurations/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchAdmissionregistrationV1MutatingWebhookConfiguration",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchAdmissionregistrationV1MutatingWebhookConfiguration",
			ID:   "watchAdmissionregistrationV1MutatingWebhookConfiguration",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchAdmissionregistrationV1MutatingWebhookConfiguration", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchAdmissionregistrationV1MutatingWebhookConfigurationParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchAdmissionregistrationV1MutatingWebhookConfigurationRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchAdmissionregistrationV1MutatingWebhookConfiguration",
			OperationSummary: "",
			OperationID:      "watchAdmissionregistrationV1MutatingWebhookConfiguration",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchAdmissionregistrationV1MutatingWebhookConfigurationParams
			Response = WatchAdmissionregistrationV1MutatingWebhookConfigurationRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchAdmissionregistrationV1MutatingWebhookConfigurationParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchAdmissionregistrationV1MutatingWebhookConfiguration(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchAdmissionregistrationV1MutatingWebhookConfiguration(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchAdmissionregistrationV1MutatingWebhookConfigurationResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchAdmissionregistrationV1MutatingWebhookConfigurationListRequest handles watchAdmissionregistrationV1MutatingWebhookConfigurationList operation.
//
// Watch individual changes to a list of MutatingWebhookConfiguration. deprecated: use the 'watch'
// parameter with a list operation instead.
//
// GET /apis/admissionregistration.k8s.io/v1/watch/mutatingwebhookconfigurations
func (s *Server) handleWatchAdmissionregistrationV1MutatingWebhookConfigurationListRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchAdmissionregistrationV1MutatingWebhookConfigurationList"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/admissionregistration.k8s.io/v1/watch/mutatingwebhookconfigurations"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchAdmissionregistrationV1MutatingWebhookConfigurationList",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchAdmissionregistrationV1MutatingWebhookConfigurationList",
			ID:   "watchAdmissionregistrationV1MutatingWebhookConfigurationList",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchAdmissionregistrationV1MutatingWebhookConfigurationList", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchAdmissionregistrationV1MutatingWebhookConfigurationListParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchAdmissionregistrationV1MutatingWebhookConfigurationListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchAdmissionregistrationV1MutatingWebhookConfigurationList",
			OperationSummary: "",
			OperationID:      "watchAdmissionregistrationV1MutatingWebhookConfigurationList",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchAdmissionregistrationV1MutatingWebhookConfigurationListParams
			Response = WatchAdmissionregistrationV1MutatingWebhookConfigurationListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchAdmissionregistrationV1MutatingWebhookConfigurationListParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchAdmissionregistrationV1MutatingWebhookConfigurationList(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchAdmissionregistrationV1MutatingWebhookConfigurationList(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchAdmissionregistrationV1MutatingWebhookConfigurationListResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchAdmissionregistrationV1ValidatingWebhookConfigurationRequest handles watchAdmissionregistrationV1ValidatingWebhookConfiguration operation.
//
// Watch changes to an object of kind ValidatingWebhookConfiguration. deprecated: use the 'watch'
// parameter with a list operation instead, filtered to a single item with the 'fieldSelector'
// parameter.
//
// GET /apis/admissionregistration.k8s.io/v1/watch/validatingwebhookconfigurations/{name}
func (s *Server) handleWatchAdmissionregistrationV1ValidatingWebhookConfigurationRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchAdmissionregistrationV1ValidatingWebhookConfiguration"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/admissionregistration.k8s.io/v1/watch/validatingwebhookconfigurations/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchAdmissionregistrationV1ValidatingWebhookConfiguration",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchAdmissionregistrationV1ValidatingWebhookConfiguration",
			ID:   "watchAdmissionregistrationV1ValidatingWebhookConfiguration",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchAdmissionregistrationV1ValidatingWebhookConfiguration", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchAdmissionregistrationV1ValidatingWebhookConfigurationParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchAdmissionregistrationV1ValidatingWebhookConfigurationRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchAdmissionregistrationV1ValidatingWebhookConfiguration",
			OperationSummary: "",
			OperationID:      "watchAdmissionregistrationV1ValidatingWebhookConfiguration",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchAdmissionregistrationV1ValidatingWebhookConfigurationParams
			Response = WatchAdmissionregistrationV1ValidatingWebhookConfigurationRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchAdmissionregistrationV1ValidatingWebhookConfigurationParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchAdmissionregistrationV1ValidatingWebhookConfiguration(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchAdmissionregistrationV1ValidatingWebhookConfiguration(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchAdmissionregistrationV1ValidatingWebhookConfigurationResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchAdmissionregistrationV1ValidatingWebhookConfigurationListRequest handles watchAdmissionregistrationV1ValidatingWebhookConfigurationList operation.
//
// Watch individual changes to a list of ValidatingWebhookConfiguration. deprecated: use the 'watch'
// parameter with a list operation instead.
//
// GET /apis/admissionregistration.k8s.io/v1/watch/validatingwebhookconfigurations
func (s *Server) handleWatchAdmissionregistrationV1ValidatingWebhookConfigurationListRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchAdmissionregistrationV1ValidatingWebhookConfigurationList"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/admissionregistration.k8s.io/v1/watch/validatingwebhookconfigurations"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchAdmissionregistrationV1ValidatingWebhookConfigurationList",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchAdmissionregistrationV1ValidatingWebhookConfigurationList",
			ID:   "watchAdmissionregistrationV1ValidatingWebhookConfigurationList",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchAdmissionregistrationV1ValidatingWebhookConfigurationList", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchAdmissionregistrationV1ValidatingWebhookConfigurationListParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchAdmissionregistrationV1ValidatingWebhookConfigurationListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchAdmissionregistrationV1ValidatingWebhookConfigurationList",
			OperationSummary: "",
			OperationID:      "watchAdmissionregistrationV1ValidatingWebhookConfigurationList",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchAdmissionregistrationV1ValidatingWebhookConfigurationListParams
			Response = WatchAdmissionregistrationV1ValidatingWebhookConfigurationListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchAdmissionregistrationV1ValidatingWebhookConfigurationListParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchAdmissionregistrationV1ValidatingWebhookConfigurationList(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchAdmissionregistrationV1ValidatingWebhookConfigurationList(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchAdmissionregistrationV1ValidatingWebhookConfigurationListResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchApiextensionsV1CustomResourceDefinitionRequest handles watchApiextensionsV1CustomResourceDefinition operation.
//
// Watch changes to an object of kind CustomResourceDefinition. deprecated: use the 'watch' parameter
// with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
//
// GET /apis/apiextensions.k8s.io/v1/watch/customresourcedefinitions/{name}
func (s *Server) handleWatchApiextensionsV1CustomResourceDefinitionRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchApiextensionsV1CustomResourceDefinition"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/apiextensions.k8s.io/v1/watch/customresourcedefinitions/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchApiextensionsV1CustomResourceDefinition",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchApiextensionsV1CustomResourceDefinition",
			ID:   "watchApiextensionsV1CustomResourceDefinition",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchApiextensionsV1CustomResourceDefinition", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchApiextensionsV1CustomResourceDefinitionParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchApiextensionsV1CustomResourceDefinitionRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchApiextensionsV1CustomResourceDefinition",
			OperationSummary: "",
			OperationID:      "watchApiextensionsV1CustomResourceDefinition",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchApiextensionsV1CustomResourceDefinitionParams
			Response = WatchApiextensionsV1CustomResourceDefinitionRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchApiextensionsV1CustomResourceDefinitionParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchApiextensionsV1CustomResourceDefinition(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchApiextensionsV1CustomResourceDefinition(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchApiextensionsV1CustomResourceDefinitionResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchApiextensionsV1CustomResourceDefinitionListRequest handles watchApiextensionsV1CustomResourceDefinitionList operation.
//
// Watch individual changes to a list of CustomResourceDefinition. deprecated: use the 'watch'
// parameter with a list operation instead.
//
// GET /apis/apiextensions.k8s.io/v1/watch/customresourcedefinitions
func (s *Server) handleWatchApiextensionsV1CustomResourceDefinitionListRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchApiextensionsV1CustomResourceDefinitionList"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/apiextensions.k8s.io/v1/watch/customresourcedefinitions"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchApiextensionsV1CustomResourceDefinitionList",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchApiextensionsV1CustomResourceDefinitionList",
			ID:   "watchApiextensionsV1CustomResourceDefinitionList",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchApiextensionsV1CustomResourceDefinitionList", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchApiextensionsV1CustomResourceDefinitionListParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchApiextensionsV1CustomResourceDefinitionListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchApiextensionsV1CustomResourceDefinitionList",
			OperationSummary: "",
			OperationID:      "watchApiextensionsV1CustomResourceDefinitionList",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchApiextensionsV1CustomResourceDefinitionListParams
			Response = WatchApiextensionsV1CustomResourceDefinitionListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchApiextensionsV1CustomResourceDefinitionListParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchApiextensionsV1CustomResourceDefinitionList(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchApiextensionsV1CustomResourceDefinitionList(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchApiextensionsV1CustomResourceDefinitionListResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchApiregistrationV1APIServiceRequest handles watchApiregistrationV1APIService operation.
//
// Watch changes to an object of kind APIService. deprecated: use the 'watch' parameter with a list
// operation instead, filtered to a single item with the 'fieldSelector' parameter.
//
// GET /apis/apiregistration.k8s.io/v1/watch/apiservices/{name}
func (s *Server) handleWatchApiregistrationV1APIServiceRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchApiregistrationV1APIService"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/apiregistration.k8s.io/v1/watch/apiservices/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchApiregistrationV1APIService",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchApiregistrationV1APIService",
			ID:   "watchApiregistrationV1APIService",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchApiregistrationV1APIService", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchApiregistrationV1APIServiceParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchApiregistrationV1APIServiceRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchApiregistrationV1APIService",
			OperationSummary: "",
			OperationID:      "watchApiregistrationV1APIService",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchApiregistrationV1APIServiceParams
			Response = WatchApiregistrationV1APIServiceRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchApiregistrationV1APIServiceParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchApiregistrationV1APIService(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchApiregistrationV1APIService(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchApiregistrationV1APIServiceResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchApiregistrationV1APIServiceListRequest handles watchApiregistrationV1APIServiceList operation.
//
// Watch individual changes to a list of APIService. deprecated: use the 'watch' parameter with a
// list operation instead.
//
// GET /apis/apiregistration.k8s.io/v1/watch/apiservices
func (s *Server) handleWatchApiregistrationV1APIServiceListRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchApiregistrationV1APIServiceList"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/apiregistration.k8s.io/v1/watch/apiservices"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchApiregistrationV1APIServiceList",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchApiregistrationV1APIServiceList",
			ID:   "watchApiregistrationV1APIServiceList",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchApiregistrationV1APIServiceList", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchApiregistrationV1APIServiceListParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchApiregistrationV1APIServiceListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchApiregistrationV1APIServiceList",
			OperationSummary: "",
			OperationID:      "watchApiregistrationV1APIServiceList",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchApiregistrationV1APIServiceListParams
			Response = WatchApiregistrationV1APIServiceListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchApiregistrationV1APIServiceListParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchApiregistrationV1APIServiceList(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchApiregistrationV1APIServiceList(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchApiregistrationV1APIServiceListResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchAppsV1ControllerRevisionListForAllNamespacesRequest handles watchAppsV1ControllerRevisionListForAllNamespaces operation.
//
// Watch individual changes to a list of ControllerRevision. deprecated: use the 'watch' parameter
// with a list operation instead.
//
// GET /apis/apps/v1/watch/controllerrevisions
func (s *Server) handleWatchAppsV1ControllerRevisionListForAllNamespacesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchAppsV1ControllerRevisionListForAllNamespaces"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/apps/v1/watch/controllerrevisions"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchAppsV1ControllerRevisionListForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchAppsV1ControllerRevisionListForAllNamespaces",
			ID:   "watchAppsV1ControllerRevisionListForAllNamespaces",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchAppsV1ControllerRevisionListForAllNamespaces", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchAppsV1ControllerRevisionListForAllNamespacesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchAppsV1ControllerRevisionListForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchAppsV1ControllerRevisionListForAllNamespaces",
			OperationSummary: "",
			OperationID:      "watchAppsV1ControllerRevisionListForAllNamespaces",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchAppsV1ControllerRevisionListForAllNamespacesParams
			Response = WatchAppsV1ControllerRevisionListForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchAppsV1ControllerRevisionListForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchAppsV1ControllerRevisionListForAllNamespaces(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchAppsV1ControllerRevisionListForAllNamespaces(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchAppsV1ControllerRevisionListForAllNamespacesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchAppsV1DaemonSetListForAllNamespacesRequest handles watchAppsV1DaemonSetListForAllNamespaces operation.
//
// Watch individual changes to a list of DaemonSet. deprecated: use the 'watch' parameter with a list
// operation instead.
//
// GET /apis/apps/v1/watch/daemonsets
func (s *Server) handleWatchAppsV1DaemonSetListForAllNamespacesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchAppsV1DaemonSetListForAllNamespaces"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/apps/v1/watch/daemonsets"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchAppsV1DaemonSetListForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchAppsV1DaemonSetListForAllNamespaces",
			ID:   "watchAppsV1DaemonSetListForAllNamespaces",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchAppsV1DaemonSetListForAllNamespaces", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchAppsV1DaemonSetListForAllNamespacesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchAppsV1DaemonSetListForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchAppsV1DaemonSetListForAllNamespaces",
			OperationSummary: "",
			OperationID:      "watchAppsV1DaemonSetListForAllNamespaces",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchAppsV1DaemonSetListForAllNamespacesParams
			Response = WatchAppsV1DaemonSetListForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchAppsV1DaemonSetListForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchAppsV1DaemonSetListForAllNamespaces(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchAppsV1DaemonSetListForAllNamespaces(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchAppsV1DaemonSetListForAllNamespacesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchAppsV1DeploymentListForAllNamespacesRequest handles watchAppsV1DeploymentListForAllNamespaces operation.
//
// Watch individual changes to a list of Deployment. deprecated: use the 'watch' parameter with a
// list operation instead.
//
// GET /apis/apps/v1/watch/deployments
func (s *Server) handleWatchAppsV1DeploymentListForAllNamespacesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchAppsV1DeploymentListForAllNamespaces"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/apps/v1/watch/deployments"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchAppsV1DeploymentListForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchAppsV1DeploymentListForAllNamespaces",
			ID:   "watchAppsV1DeploymentListForAllNamespaces",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchAppsV1DeploymentListForAllNamespaces", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchAppsV1DeploymentListForAllNamespacesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchAppsV1DeploymentListForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchAppsV1DeploymentListForAllNamespaces",
			OperationSummary: "",
			OperationID:      "watchAppsV1DeploymentListForAllNamespaces",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchAppsV1DeploymentListForAllNamespacesParams
			Response = WatchAppsV1DeploymentListForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchAppsV1DeploymentListForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchAppsV1DeploymentListForAllNamespaces(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchAppsV1DeploymentListForAllNamespaces(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchAppsV1DeploymentListForAllNamespacesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchAppsV1NamespacedControllerRevisionRequest handles watchAppsV1NamespacedControllerRevision operation.
//
// Watch changes to an object of kind ControllerRevision. deprecated: use the 'watch' parameter with
// a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
//
// GET /apis/apps/v1/watch/namespaces/{namespace}/controllerrevisions/{name}
func (s *Server) handleWatchAppsV1NamespacedControllerRevisionRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchAppsV1NamespacedControllerRevision"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/apps/v1/watch/namespaces/{namespace}/controllerrevisions/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchAppsV1NamespacedControllerRevision",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchAppsV1NamespacedControllerRevision",
			ID:   "watchAppsV1NamespacedControllerRevision",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchAppsV1NamespacedControllerRevision", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchAppsV1NamespacedControllerRevisionParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchAppsV1NamespacedControllerRevisionRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchAppsV1NamespacedControllerRevision",
			OperationSummary: "",
			OperationID:      "watchAppsV1NamespacedControllerRevision",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchAppsV1NamespacedControllerRevisionParams
			Response = WatchAppsV1NamespacedControllerRevisionRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchAppsV1NamespacedControllerRevisionParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchAppsV1NamespacedControllerRevision(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchAppsV1NamespacedControllerRevision(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchAppsV1NamespacedControllerRevisionResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchAppsV1NamespacedControllerRevisionListRequest handles watchAppsV1NamespacedControllerRevisionList operation.
//
// Watch individual changes to a list of ControllerRevision. deprecated: use the 'watch' parameter
// with a list operation instead.
//
// GET /apis/apps/v1/watch/namespaces/{namespace}/controllerrevisions
func (s *Server) handleWatchAppsV1NamespacedControllerRevisionListRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchAppsV1NamespacedControllerRevisionList"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/apps/v1/watch/namespaces/{namespace}/controllerrevisions"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchAppsV1NamespacedControllerRevisionList",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchAppsV1NamespacedControllerRevisionList",
			ID:   "watchAppsV1NamespacedControllerRevisionList",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchAppsV1NamespacedControllerRevisionList", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchAppsV1NamespacedControllerRevisionListParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchAppsV1NamespacedControllerRevisionListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchAppsV1NamespacedControllerRevisionList",
			OperationSummary: "",
			OperationID:      "watchAppsV1NamespacedControllerRevisionList",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchAppsV1NamespacedControllerRevisionListParams
			Response = WatchAppsV1NamespacedControllerRevisionListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchAppsV1NamespacedControllerRevisionListParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchAppsV1NamespacedControllerRevisionList(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchAppsV1NamespacedControllerRevisionList(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchAppsV1NamespacedControllerRevisionListResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchAppsV1NamespacedDaemonSetRequest handles watchAppsV1NamespacedDaemonSet operation.
//
// Watch changes to an object of kind DaemonSet. deprecated: use the 'watch' parameter with a list
// operation instead, filtered to a single item with the 'fieldSelector' parameter.
//
// GET /apis/apps/v1/watch/namespaces/{namespace}/daemonsets/{name}
func (s *Server) handleWatchAppsV1NamespacedDaemonSetRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchAppsV1NamespacedDaemonSet"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/apps/v1/watch/namespaces/{namespace}/daemonsets/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchAppsV1NamespacedDaemonSet",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchAppsV1NamespacedDaemonSet",
			ID:   "watchAppsV1NamespacedDaemonSet",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchAppsV1NamespacedDaemonSet", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchAppsV1NamespacedDaemonSetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchAppsV1NamespacedDaemonSetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchAppsV1NamespacedDaemonSet",
			OperationSummary: "",
			OperationID:      "watchAppsV1NamespacedDaemonSet",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchAppsV1NamespacedDaemonSetParams
			Response = WatchAppsV1NamespacedDaemonSetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchAppsV1NamespacedDaemonSetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchAppsV1NamespacedDaemonSet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchAppsV1NamespacedDaemonSet(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchAppsV1NamespacedDaemonSetResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchAppsV1NamespacedDaemonSetListRequest handles watchAppsV1NamespacedDaemonSetList operation.
//
// Watch individual changes to a list of DaemonSet. deprecated: use the 'watch' parameter with a list
// operation instead.
//
// GET /apis/apps/v1/watch/namespaces/{namespace}/daemonsets
func (s *Server) handleWatchAppsV1NamespacedDaemonSetListRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchAppsV1NamespacedDaemonSetList"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/apps/v1/watch/namespaces/{namespace}/daemonsets"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchAppsV1NamespacedDaemonSetList",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchAppsV1NamespacedDaemonSetList",
			ID:   "watchAppsV1NamespacedDaemonSetList",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchAppsV1NamespacedDaemonSetList", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchAppsV1NamespacedDaemonSetListParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchAppsV1NamespacedDaemonSetListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchAppsV1NamespacedDaemonSetList",
			OperationSummary: "",
			OperationID:      "watchAppsV1NamespacedDaemonSetList",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchAppsV1NamespacedDaemonSetListParams
			Response = WatchAppsV1NamespacedDaemonSetListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchAppsV1NamespacedDaemonSetListParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchAppsV1NamespacedDaemonSetList(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchAppsV1NamespacedDaemonSetList(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchAppsV1NamespacedDaemonSetListResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchAppsV1NamespacedDeploymentRequest handles watchAppsV1NamespacedDeployment operation.
//
// Watch changes to an object of kind Deployment. deprecated: use the 'watch' parameter with a list
// operation instead, filtered to a single item with the 'fieldSelector' parameter.
//
// GET /apis/apps/v1/watch/namespaces/{namespace}/deployments/{name}
func (s *Server) handleWatchAppsV1NamespacedDeploymentRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchAppsV1NamespacedDeployment"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/apps/v1/watch/namespaces/{namespace}/deployments/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchAppsV1NamespacedDeployment",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchAppsV1NamespacedDeployment",
			ID:   "watchAppsV1NamespacedDeployment",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchAppsV1NamespacedDeployment", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchAppsV1NamespacedDeploymentParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchAppsV1NamespacedDeploymentRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchAppsV1NamespacedDeployment",
			OperationSummary: "",
			OperationID:      "watchAppsV1NamespacedDeployment",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchAppsV1NamespacedDeploymentParams
			Response = WatchAppsV1NamespacedDeploymentRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchAppsV1NamespacedDeploymentParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchAppsV1NamespacedDeployment(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchAppsV1NamespacedDeployment(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchAppsV1NamespacedDeploymentResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchAppsV1NamespacedDeploymentListRequest handles watchAppsV1NamespacedDeploymentList operation.
//
// Watch individual changes to a list of Deployment. deprecated: use the 'watch' parameter with a
// list operation instead.
//
// GET /apis/apps/v1/watch/namespaces/{namespace}/deployments
func (s *Server) handleWatchAppsV1NamespacedDeploymentListRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchAppsV1NamespacedDeploymentList"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/apps/v1/watch/namespaces/{namespace}/deployments"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchAppsV1NamespacedDeploymentList",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchAppsV1NamespacedDeploymentList",
			ID:   "watchAppsV1NamespacedDeploymentList",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchAppsV1NamespacedDeploymentList", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchAppsV1NamespacedDeploymentListParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchAppsV1NamespacedDeploymentListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchAppsV1NamespacedDeploymentList",
			OperationSummary: "",
			OperationID:      "watchAppsV1NamespacedDeploymentList",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchAppsV1NamespacedDeploymentListParams
			Response = WatchAppsV1NamespacedDeploymentListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchAppsV1NamespacedDeploymentListParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchAppsV1NamespacedDeploymentList(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchAppsV1NamespacedDeploymentList(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchAppsV1NamespacedDeploymentListResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchAppsV1NamespacedReplicaSetRequest handles watchAppsV1NamespacedReplicaSet operation.
//
// Watch changes to an object of kind ReplicaSet. deprecated: use the 'watch' parameter with a list
// operation instead, filtered to a single item with the 'fieldSelector' parameter.
//
// GET /apis/apps/v1/watch/namespaces/{namespace}/replicasets/{name}
func (s *Server) handleWatchAppsV1NamespacedReplicaSetRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchAppsV1NamespacedReplicaSet"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/apps/v1/watch/namespaces/{namespace}/replicasets/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchAppsV1NamespacedReplicaSet",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchAppsV1NamespacedReplicaSet",
			ID:   "watchAppsV1NamespacedReplicaSet",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchAppsV1NamespacedReplicaSet", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchAppsV1NamespacedReplicaSetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchAppsV1NamespacedReplicaSetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchAppsV1NamespacedReplicaSet",
			OperationSummary: "",
			OperationID:      "watchAppsV1NamespacedReplicaSet",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchAppsV1NamespacedReplicaSetParams
			Response = WatchAppsV1NamespacedReplicaSetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchAppsV1NamespacedReplicaSetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchAppsV1NamespacedReplicaSet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchAppsV1NamespacedReplicaSet(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchAppsV1NamespacedReplicaSetResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchAppsV1NamespacedReplicaSetListRequest handles watchAppsV1NamespacedReplicaSetList operation.
//
// Watch individual changes to a list of ReplicaSet. deprecated: use the 'watch' parameter with a
// list operation instead.
//
// GET /apis/apps/v1/watch/namespaces/{namespace}/replicasets
func (s *Server) handleWatchAppsV1NamespacedReplicaSetListRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchAppsV1NamespacedReplicaSetList"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/apps/v1/watch/namespaces/{namespace}/replicasets"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchAppsV1NamespacedReplicaSetList",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchAppsV1NamespacedReplicaSetList",
			ID:   "watchAppsV1NamespacedReplicaSetList",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchAppsV1NamespacedReplicaSetList", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchAppsV1NamespacedReplicaSetListParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchAppsV1NamespacedReplicaSetListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchAppsV1NamespacedReplicaSetList",
			OperationSummary: "",
			OperationID:      "watchAppsV1NamespacedReplicaSetList",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchAppsV1NamespacedReplicaSetListParams
			Response = WatchAppsV1NamespacedReplicaSetListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchAppsV1NamespacedReplicaSetListParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchAppsV1NamespacedReplicaSetList(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchAppsV1NamespacedReplicaSetList(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchAppsV1NamespacedReplicaSetListResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchAppsV1NamespacedStatefulSetRequest handles watchAppsV1NamespacedStatefulSet operation.
//
// Watch changes to an object of kind StatefulSet. deprecated: use the 'watch' parameter with a list
// operation instead, filtered to a single item with the 'fieldSelector' parameter.
//
// GET /apis/apps/v1/watch/namespaces/{namespace}/statefulsets/{name}
func (s *Server) handleWatchAppsV1NamespacedStatefulSetRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchAppsV1NamespacedStatefulSet"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/apps/v1/watch/namespaces/{namespace}/statefulsets/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchAppsV1NamespacedStatefulSet",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchAppsV1NamespacedStatefulSet",
			ID:   "watchAppsV1NamespacedStatefulSet",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchAppsV1NamespacedStatefulSet", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchAppsV1NamespacedStatefulSetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchAppsV1NamespacedStatefulSetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchAppsV1NamespacedStatefulSet",
			OperationSummary: "",
			OperationID:      "watchAppsV1NamespacedStatefulSet",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchAppsV1NamespacedStatefulSetParams
			Response = WatchAppsV1NamespacedStatefulSetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchAppsV1NamespacedStatefulSetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchAppsV1NamespacedStatefulSet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchAppsV1NamespacedStatefulSet(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchAppsV1NamespacedStatefulSetResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchAppsV1NamespacedStatefulSetListRequest handles watchAppsV1NamespacedStatefulSetList operation.
//
// Watch individual changes to a list of StatefulSet. deprecated: use the 'watch' parameter with a
// list operation instead.
//
// GET /apis/apps/v1/watch/namespaces/{namespace}/statefulsets
func (s *Server) handleWatchAppsV1NamespacedStatefulSetListRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchAppsV1NamespacedStatefulSetList"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/apps/v1/watch/namespaces/{namespace}/statefulsets"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchAppsV1NamespacedStatefulSetList",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchAppsV1NamespacedStatefulSetList",
			ID:   "watchAppsV1NamespacedStatefulSetList",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchAppsV1NamespacedStatefulSetList", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchAppsV1NamespacedStatefulSetListParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchAppsV1NamespacedStatefulSetListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchAppsV1NamespacedStatefulSetList",
			OperationSummary: "",
			OperationID:      "watchAppsV1NamespacedStatefulSetList",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchAppsV1NamespacedStatefulSetListParams
			Response = WatchAppsV1NamespacedStatefulSetListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchAppsV1NamespacedStatefulSetListParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchAppsV1NamespacedStatefulSetList(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchAppsV1NamespacedStatefulSetList(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchAppsV1NamespacedStatefulSetListResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchAppsV1ReplicaSetListForAllNamespacesRequest handles watchAppsV1ReplicaSetListForAllNamespaces operation.
//
// Watch individual changes to a list of ReplicaSet. deprecated: use the 'watch' parameter with a
// list operation instead.
//
// GET /apis/apps/v1/watch/replicasets
func (s *Server) handleWatchAppsV1ReplicaSetListForAllNamespacesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchAppsV1ReplicaSetListForAllNamespaces"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/apps/v1/watch/replicasets"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchAppsV1ReplicaSetListForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchAppsV1ReplicaSetListForAllNamespaces",
			ID:   "watchAppsV1ReplicaSetListForAllNamespaces",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchAppsV1ReplicaSetListForAllNamespaces", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchAppsV1ReplicaSetListForAllNamespacesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchAppsV1ReplicaSetListForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchAppsV1ReplicaSetListForAllNamespaces",
			OperationSummary: "",
			OperationID:      "watchAppsV1ReplicaSetListForAllNamespaces",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchAppsV1ReplicaSetListForAllNamespacesParams
			Response = WatchAppsV1ReplicaSetListForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchAppsV1ReplicaSetListForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchAppsV1ReplicaSetListForAllNamespaces(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchAppsV1ReplicaSetListForAllNamespaces(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchAppsV1ReplicaSetListForAllNamespacesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchAppsV1StatefulSetListForAllNamespacesRequest handles watchAppsV1StatefulSetListForAllNamespaces operation.
//
// Watch individual changes to a list of StatefulSet. deprecated: use the 'watch' parameter with a
// list operation instead.
//
// GET /apis/apps/v1/watch/statefulsets
func (s *Server) handleWatchAppsV1StatefulSetListForAllNamespacesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchAppsV1StatefulSetListForAllNamespaces"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/apps/v1/watch/statefulsets"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchAppsV1StatefulSetListForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchAppsV1StatefulSetListForAllNamespaces",
			ID:   "watchAppsV1StatefulSetListForAllNamespaces",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchAppsV1StatefulSetListForAllNamespaces", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchAppsV1StatefulSetListForAllNamespacesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchAppsV1StatefulSetListForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchAppsV1StatefulSetListForAllNamespaces",
			OperationSummary: "",
			OperationID:      "watchAppsV1StatefulSetListForAllNamespaces",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchAppsV1StatefulSetListForAllNamespacesParams
			Response = WatchAppsV1StatefulSetListForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchAppsV1StatefulSetListForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchAppsV1StatefulSetListForAllNamespaces(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchAppsV1StatefulSetListForAllNamespaces(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchAppsV1StatefulSetListForAllNamespacesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchAutoscalingV1HorizontalPodAutoscalerListForAllNamespacesRequest handles watchAutoscalingV1HorizontalPodAutoscalerListForAllNamespaces operation.
//
// Watch individual changes to a list of HorizontalPodAutoscaler. deprecated: use the 'watch'
// parameter with a list operation instead.
//
// GET /apis/autoscaling/v1/watch/horizontalpodautoscalers
func (s *Server) handleWatchAutoscalingV1HorizontalPodAutoscalerListForAllNamespacesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchAutoscalingV1HorizontalPodAutoscalerListForAllNamespaces"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/autoscaling/v1/watch/horizontalpodautoscalers"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchAutoscalingV1HorizontalPodAutoscalerListForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchAutoscalingV1HorizontalPodAutoscalerListForAllNamespaces",
			ID:   "watchAutoscalingV1HorizontalPodAutoscalerListForAllNamespaces",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchAutoscalingV1HorizontalPodAutoscalerListForAllNamespaces", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchAutoscalingV1HorizontalPodAutoscalerListForAllNamespacesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchAutoscalingV1HorizontalPodAutoscalerListForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchAutoscalingV1HorizontalPodAutoscalerListForAllNamespaces",
			OperationSummary: "",
			OperationID:      "watchAutoscalingV1HorizontalPodAutoscalerListForAllNamespaces",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchAutoscalingV1HorizontalPodAutoscalerListForAllNamespacesParams
			Response = WatchAutoscalingV1HorizontalPodAutoscalerListForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchAutoscalingV1HorizontalPodAutoscalerListForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchAutoscalingV1HorizontalPodAutoscalerListForAllNamespaces(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchAutoscalingV1HorizontalPodAutoscalerListForAllNamespaces(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchAutoscalingV1HorizontalPodAutoscalerListForAllNamespacesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchAutoscalingV1NamespacedHorizontalPodAutoscalerRequest handles watchAutoscalingV1NamespacedHorizontalPodAutoscaler operation.
//
// Watch changes to an object of kind HorizontalPodAutoscaler. deprecated: use the 'watch' parameter
// with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
//
// GET /apis/autoscaling/v1/watch/namespaces/{namespace}/horizontalpodautoscalers/{name}
func (s *Server) handleWatchAutoscalingV1NamespacedHorizontalPodAutoscalerRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchAutoscalingV1NamespacedHorizontalPodAutoscaler"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/autoscaling/v1/watch/namespaces/{namespace}/horizontalpodautoscalers/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchAutoscalingV1NamespacedHorizontalPodAutoscaler",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchAutoscalingV1NamespacedHorizontalPodAutoscaler",
			ID:   "watchAutoscalingV1NamespacedHorizontalPodAutoscaler",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchAutoscalingV1NamespacedHorizontalPodAutoscaler", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchAutoscalingV1NamespacedHorizontalPodAutoscalerParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchAutoscalingV1NamespacedHorizontalPodAutoscalerRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchAutoscalingV1NamespacedHorizontalPodAutoscaler",
			OperationSummary: "",
			OperationID:      "watchAutoscalingV1NamespacedHorizontalPodAutoscaler",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchAutoscalingV1NamespacedHorizontalPodAutoscalerParams
			Response = WatchAutoscalingV1NamespacedHorizontalPodAutoscalerRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchAutoscalingV1NamespacedHorizontalPodAutoscalerParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchAutoscalingV1NamespacedHorizontalPodAutoscaler(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchAutoscalingV1NamespacedHorizontalPodAutoscaler(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchAutoscalingV1NamespacedHorizontalPodAutoscalerResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchAutoscalingV1NamespacedHorizontalPodAutoscalerListRequest handles watchAutoscalingV1NamespacedHorizontalPodAutoscalerList operation.
//
// Watch individual changes to a list of HorizontalPodAutoscaler. deprecated: use the 'watch'
// parameter with a list operation instead.
//
// GET /apis/autoscaling/v1/watch/namespaces/{namespace}/horizontalpodautoscalers
func (s *Server) handleWatchAutoscalingV1NamespacedHorizontalPodAutoscalerListRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchAutoscalingV1NamespacedHorizontalPodAutoscalerList"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/autoscaling/v1/watch/namespaces/{namespace}/horizontalpodautoscalers"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchAutoscalingV1NamespacedHorizontalPodAutoscalerList",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchAutoscalingV1NamespacedHorizontalPodAutoscalerList",
			ID:   "watchAutoscalingV1NamespacedHorizontalPodAutoscalerList",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchAutoscalingV1NamespacedHorizontalPodAutoscalerList", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchAutoscalingV1NamespacedHorizontalPodAutoscalerListParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchAutoscalingV1NamespacedHorizontalPodAutoscalerListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchAutoscalingV1NamespacedHorizontalPodAutoscalerList",
			OperationSummary: "",
			OperationID:      "watchAutoscalingV1NamespacedHorizontalPodAutoscalerList",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchAutoscalingV1NamespacedHorizontalPodAutoscalerListParams
			Response = WatchAutoscalingV1NamespacedHorizontalPodAutoscalerListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchAutoscalingV1NamespacedHorizontalPodAutoscalerListParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchAutoscalingV1NamespacedHorizontalPodAutoscalerList(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchAutoscalingV1NamespacedHorizontalPodAutoscalerList(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchAutoscalingV1NamespacedHorizontalPodAutoscalerListResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchAutoscalingV2beta1HorizontalPodAutoscalerListForAllNamespacesRequest handles watchAutoscalingV2beta1HorizontalPodAutoscalerListForAllNamespaces operation.
//
// Watch individual changes to a list of HorizontalPodAutoscaler. deprecated: use the 'watch'
// parameter with a list operation instead.
//
// GET /apis/autoscaling/v2beta1/watch/horizontalpodautoscalers
func (s *Server) handleWatchAutoscalingV2beta1HorizontalPodAutoscalerListForAllNamespacesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchAutoscalingV2beta1HorizontalPodAutoscalerListForAllNamespaces"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/autoscaling/v2beta1/watch/horizontalpodautoscalers"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchAutoscalingV2beta1HorizontalPodAutoscalerListForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchAutoscalingV2beta1HorizontalPodAutoscalerListForAllNamespaces",
			ID:   "watchAutoscalingV2beta1HorizontalPodAutoscalerListForAllNamespaces",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchAutoscalingV2beta1HorizontalPodAutoscalerListForAllNamespaces", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchAutoscalingV2beta1HorizontalPodAutoscalerListForAllNamespacesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchAutoscalingV2beta1HorizontalPodAutoscalerListForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchAutoscalingV2beta1HorizontalPodAutoscalerListForAllNamespaces",
			OperationSummary: "",
			OperationID:      "watchAutoscalingV2beta1HorizontalPodAutoscalerListForAllNamespaces",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchAutoscalingV2beta1HorizontalPodAutoscalerListForAllNamespacesParams
			Response = WatchAutoscalingV2beta1HorizontalPodAutoscalerListForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchAutoscalingV2beta1HorizontalPodAutoscalerListForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchAutoscalingV2beta1HorizontalPodAutoscalerListForAllNamespaces(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchAutoscalingV2beta1HorizontalPodAutoscalerListForAllNamespaces(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchAutoscalingV2beta1HorizontalPodAutoscalerListForAllNamespacesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerRequest handles watchAutoscalingV2beta1NamespacedHorizontalPodAutoscaler operation.
//
// Watch changes to an object of kind HorizontalPodAutoscaler. deprecated: use the 'watch' parameter
// with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
//
// GET /apis/autoscaling/v2beta1/watch/namespaces/{namespace}/horizontalpodautoscalers/{name}
func (s *Server) handleWatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchAutoscalingV2beta1NamespacedHorizontalPodAutoscaler"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/autoscaling/v2beta1/watch/namespaces/{namespace}/horizontalpodautoscalers/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchAutoscalingV2beta1NamespacedHorizontalPodAutoscaler",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchAutoscalingV2beta1NamespacedHorizontalPodAutoscaler",
			ID:   "watchAutoscalingV2beta1NamespacedHorizontalPodAutoscaler",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchAutoscalingV2beta1NamespacedHorizontalPodAutoscaler", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchAutoscalingV2beta1NamespacedHorizontalPodAutoscaler",
			OperationSummary: "",
			OperationID:      "watchAutoscalingV2beta1NamespacedHorizontalPodAutoscaler",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerParams
			Response = WatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchAutoscalingV2beta1NamespacedHorizontalPodAutoscaler(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchAutoscalingV2beta1NamespacedHorizontalPodAutoscaler(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerListRequest handles watchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerList operation.
//
// Watch individual changes to a list of HorizontalPodAutoscaler. deprecated: use the 'watch'
// parameter with a list operation instead.
//
// GET /apis/autoscaling/v2beta1/watch/namespaces/{namespace}/horizontalpodautoscalers
func (s *Server) handleWatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerListRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerList"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/autoscaling/v2beta1/watch/namespaces/{namespace}/horizontalpodautoscalers"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerList",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerList",
			ID:   "watchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerList",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerList", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerListParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerList",
			OperationSummary: "",
			OperationID:      "watchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerList",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerListParams
			Response = WatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerListParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerList(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerList(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerListResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchAutoscalingV2beta2HorizontalPodAutoscalerListForAllNamespacesRequest handles watchAutoscalingV2beta2HorizontalPodAutoscalerListForAllNamespaces operation.
//
// Watch individual changes to a list of HorizontalPodAutoscaler. deprecated: use the 'watch'
// parameter with a list operation instead.
//
// GET /apis/autoscaling/v2beta2/watch/horizontalpodautoscalers
func (s *Server) handleWatchAutoscalingV2beta2HorizontalPodAutoscalerListForAllNamespacesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchAutoscalingV2beta2HorizontalPodAutoscalerListForAllNamespaces"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/autoscaling/v2beta2/watch/horizontalpodautoscalers"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchAutoscalingV2beta2HorizontalPodAutoscalerListForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchAutoscalingV2beta2HorizontalPodAutoscalerListForAllNamespaces",
			ID:   "watchAutoscalingV2beta2HorizontalPodAutoscalerListForAllNamespaces",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchAutoscalingV2beta2HorizontalPodAutoscalerListForAllNamespaces", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchAutoscalingV2beta2HorizontalPodAutoscalerListForAllNamespacesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchAutoscalingV2beta2HorizontalPodAutoscalerListForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchAutoscalingV2beta2HorizontalPodAutoscalerListForAllNamespaces",
			OperationSummary: "",
			OperationID:      "watchAutoscalingV2beta2HorizontalPodAutoscalerListForAllNamespaces",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchAutoscalingV2beta2HorizontalPodAutoscalerListForAllNamespacesParams
			Response = WatchAutoscalingV2beta2HorizontalPodAutoscalerListForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchAutoscalingV2beta2HorizontalPodAutoscalerListForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchAutoscalingV2beta2HorizontalPodAutoscalerListForAllNamespaces(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchAutoscalingV2beta2HorizontalPodAutoscalerListForAllNamespaces(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchAutoscalingV2beta2HorizontalPodAutoscalerListForAllNamespacesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerRequest handles watchAutoscalingV2beta2NamespacedHorizontalPodAutoscaler operation.
//
// Watch changes to an object of kind HorizontalPodAutoscaler. deprecated: use the 'watch' parameter
// with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
//
// GET /apis/autoscaling/v2beta2/watch/namespaces/{namespace}/horizontalpodautoscalers/{name}
func (s *Server) handleWatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchAutoscalingV2beta2NamespacedHorizontalPodAutoscaler"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/autoscaling/v2beta2/watch/namespaces/{namespace}/horizontalpodautoscalers/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchAutoscalingV2beta2NamespacedHorizontalPodAutoscaler",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchAutoscalingV2beta2NamespacedHorizontalPodAutoscaler",
			ID:   "watchAutoscalingV2beta2NamespacedHorizontalPodAutoscaler",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchAutoscalingV2beta2NamespacedHorizontalPodAutoscaler", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchAutoscalingV2beta2NamespacedHorizontalPodAutoscaler",
			OperationSummary: "",
			OperationID:      "watchAutoscalingV2beta2NamespacedHorizontalPodAutoscaler",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerParams
			Response = WatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchAutoscalingV2beta2NamespacedHorizontalPodAutoscaler(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchAutoscalingV2beta2NamespacedHorizontalPodAutoscaler(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerListRequest handles watchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerList operation.
//
// Watch individual changes to a list of HorizontalPodAutoscaler. deprecated: use the 'watch'
// parameter with a list operation instead.
//
// GET /apis/autoscaling/v2beta2/watch/namespaces/{namespace}/horizontalpodautoscalers
func (s *Server) handleWatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerListRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerList"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/autoscaling/v2beta2/watch/namespaces/{namespace}/horizontalpodautoscalers"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerList",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerList",
			ID:   "watchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerList",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerList", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerListParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerList",
			OperationSummary: "",
			OperationID:      "watchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerList",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerListParams
			Response = WatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerListParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerList(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerList(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerListResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchBatchV1CronJobListForAllNamespacesRequest handles watchBatchV1CronJobListForAllNamespaces operation.
//
// Watch individual changes to a list of CronJob. deprecated: use the 'watch' parameter with a list
// operation instead.
//
// GET /apis/batch/v1/watch/cronjobs
func (s *Server) handleWatchBatchV1CronJobListForAllNamespacesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchBatchV1CronJobListForAllNamespaces"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/batch/v1/watch/cronjobs"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchBatchV1CronJobListForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchBatchV1CronJobListForAllNamespaces",
			ID:   "watchBatchV1CronJobListForAllNamespaces",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchBatchV1CronJobListForAllNamespaces", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchBatchV1CronJobListForAllNamespacesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchBatchV1CronJobListForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchBatchV1CronJobListForAllNamespaces",
			OperationSummary: "",
			OperationID:      "watchBatchV1CronJobListForAllNamespaces",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchBatchV1CronJobListForAllNamespacesParams
			Response = WatchBatchV1CronJobListForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchBatchV1CronJobListForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchBatchV1CronJobListForAllNamespaces(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchBatchV1CronJobListForAllNamespaces(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchBatchV1CronJobListForAllNamespacesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchBatchV1JobListForAllNamespacesRequest handles watchBatchV1JobListForAllNamespaces operation.
//
// Watch individual changes to a list of Job. deprecated: use the 'watch' parameter with a list
// operation instead.
//
// GET /apis/batch/v1/watch/jobs
func (s *Server) handleWatchBatchV1JobListForAllNamespacesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchBatchV1JobListForAllNamespaces"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/batch/v1/watch/jobs"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchBatchV1JobListForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchBatchV1JobListForAllNamespaces",
			ID:   "watchBatchV1JobListForAllNamespaces",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchBatchV1JobListForAllNamespaces", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchBatchV1JobListForAllNamespacesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchBatchV1JobListForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchBatchV1JobListForAllNamespaces",
			OperationSummary: "",
			OperationID:      "watchBatchV1JobListForAllNamespaces",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchBatchV1JobListForAllNamespacesParams
			Response = WatchBatchV1JobListForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchBatchV1JobListForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchBatchV1JobListForAllNamespaces(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchBatchV1JobListForAllNamespaces(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchBatchV1JobListForAllNamespacesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchBatchV1NamespacedCronJobRequest handles watchBatchV1NamespacedCronJob operation.
//
// Watch changes to an object of kind CronJob. deprecated: use the 'watch' parameter with a list
// operation instead, filtered to a single item with the 'fieldSelector' parameter.
//
// GET /apis/batch/v1/watch/namespaces/{namespace}/cronjobs/{name}
func (s *Server) handleWatchBatchV1NamespacedCronJobRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchBatchV1NamespacedCronJob"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/batch/v1/watch/namespaces/{namespace}/cronjobs/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchBatchV1NamespacedCronJob",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchBatchV1NamespacedCronJob",
			ID:   "watchBatchV1NamespacedCronJob",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchBatchV1NamespacedCronJob", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchBatchV1NamespacedCronJobParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchBatchV1NamespacedCronJobRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchBatchV1NamespacedCronJob",
			OperationSummary: "",
			OperationID:      "watchBatchV1NamespacedCronJob",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchBatchV1NamespacedCronJobParams
			Response = WatchBatchV1NamespacedCronJobRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchBatchV1NamespacedCronJobParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchBatchV1NamespacedCronJob(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchBatchV1NamespacedCronJob(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchBatchV1NamespacedCronJobResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchBatchV1NamespacedCronJobListRequest handles watchBatchV1NamespacedCronJobList operation.
//
// Watch individual changes to a list of CronJob. deprecated: use the 'watch' parameter with a list
// operation instead.
//
// GET /apis/batch/v1/watch/namespaces/{namespace}/cronjobs
func (s *Server) handleWatchBatchV1NamespacedCronJobListRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchBatchV1NamespacedCronJobList"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/batch/v1/watch/namespaces/{namespace}/cronjobs"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchBatchV1NamespacedCronJobList",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchBatchV1NamespacedCronJobList",
			ID:   "watchBatchV1NamespacedCronJobList",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchBatchV1NamespacedCronJobList", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchBatchV1NamespacedCronJobListParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchBatchV1NamespacedCronJobListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchBatchV1NamespacedCronJobList",
			OperationSummary: "",
			OperationID:      "watchBatchV1NamespacedCronJobList",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchBatchV1NamespacedCronJobListParams
			Response = WatchBatchV1NamespacedCronJobListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchBatchV1NamespacedCronJobListParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchBatchV1NamespacedCronJobList(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchBatchV1NamespacedCronJobList(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchBatchV1NamespacedCronJobListResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchBatchV1NamespacedJobRequest handles watchBatchV1NamespacedJob operation.
//
// Watch changes to an object of kind Job. deprecated: use the 'watch' parameter with a list
// operation instead, filtered to a single item with the 'fieldSelector' parameter.
//
// GET /apis/batch/v1/watch/namespaces/{namespace}/jobs/{name}
func (s *Server) handleWatchBatchV1NamespacedJobRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchBatchV1NamespacedJob"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/batch/v1/watch/namespaces/{namespace}/jobs/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchBatchV1NamespacedJob",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchBatchV1NamespacedJob",
			ID:   "watchBatchV1NamespacedJob",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchBatchV1NamespacedJob", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchBatchV1NamespacedJobParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchBatchV1NamespacedJobRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchBatchV1NamespacedJob",
			OperationSummary: "",
			OperationID:      "watchBatchV1NamespacedJob",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchBatchV1NamespacedJobParams
			Response = WatchBatchV1NamespacedJobRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchBatchV1NamespacedJobParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchBatchV1NamespacedJob(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchBatchV1NamespacedJob(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchBatchV1NamespacedJobResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchBatchV1NamespacedJobListRequest handles watchBatchV1NamespacedJobList operation.
//
// Watch individual changes to a list of Job. deprecated: use the 'watch' parameter with a list
// operation instead.
//
// GET /apis/batch/v1/watch/namespaces/{namespace}/jobs
func (s *Server) handleWatchBatchV1NamespacedJobListRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchBatchV1NamespacedJobList"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/batch/v1/watch/namespaces/{namespace}/jobs"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchBatchV1NamespacedJobList",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchBatchV1NamespacedJobList",
			ID:   "watchBatchV1NamespacedJobList",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchBatchV1NamespacedJobList", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchBatchV1NamespacedJobListParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchBatchV1NamespacedJobListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchBatchV1NamespacedJobList",
			OperationSummary: "",
			OperationID:      "watchBatchV1NamespacedJobList",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchBatchV1NamespacedJobListParams
			Response = WatchBatchV1NamespacedJobListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchBatchV1NamespacedJobListParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchBatchV1NamespacedJobList(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchBatchV1NamespacedJobList(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchBatchV1NamespacedJobListResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchBatchV1beta1CronJobListForAllNamespacesRequest handles watchBatchV1beta1CronJobListForAllNamespaces operation.
//
// Watch individual changes to a list of CronJob. deprecated: use the 'watch' parameter with a list
// operation instead.
//
// GET /apis/batch/v1beta1/watch/cronjobs
func (s *Server) handleWatchBatchV1beta1CronJobListForAllNamespacesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchBatchV1beta1CronJobListForAllNamespaces"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/batch/v1beta1/watch/cronjobs"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchBatchV1beta1CronJobListForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchBatchV1beta1CronJobListForAllNamespaces",
			ID:   "watchBatchV1beta1CronJobListForAllNamespaces",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchBatchV1beta1CronJobListForAllNamespaces", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchBatchV1beta1CronJobListForAllNamespacesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchBatchV1beta1CronJobListForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchBatchV1beta1CronJobListForAllNamespaces",
			OperationSummary: "",
			OperationID:      "watchBatchV1beta1CronJobListForAllNamespaces",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchBatchV1beta1CronJobListForAllNamespacesParams
			Response = WatchBatchV1beta1CronJobListForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchBatchV1beta1CronJobListForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchBatchV1beta1CronJobListForAllNamespaces(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchBatchV1beta1CronJobListForAllNamespaces(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchBatchV1beta1CronJobListForAllNamespacesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchBatchV1beta1NamespacedCronJobRequest handles watchBatchV1beta1NamespacedCronJob operation.
//
// Watch changes to an object of kind CronJob. deprecated: use the 'watch' parameter with a list
// operation instead, filtered to a single item with the 'fieldSelector' parameter.
//
// GET /apis/batch/v1beta1/watch/namespaces/{namespace}/cronjobs/{name}
func (s *Server) handleWatchBatchV1beta1NamespacedCronJobRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchBatchV1beta1NamespacedCronJob"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/batch/v1beta1/watch/namespaces/{namespace}/cronjobs/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchBatchV1beta1NamespacedCronJob",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchBatchV1beta1NamespacedCronJob",
			ID:   "watchBatchV1beta1NamespacedCronJob",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchBatchV1beta1NamespacedCronJob", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchBatchV1beta1NamespacedCronJobParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchBatchV1beta1NamespacedCronJobRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchBatchV1beta1NamespacedCronJob",
			OperationSummary: "",
			OperationID:      "watchBatchV1beta1NamespacedCronJob",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchBatchV1beta1NamespacedCronJobParams
			Response = WatchBatchV1beta1NamespacedCronJobRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchBatchV1beta1NamespacedCronJobParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchBatchV1beta1NamespacedCronJob(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchBatchV1beta1NamespacedCronJob(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchBatchV1beta1NamespacedCronJobResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchBatchV1beta1NamespacedCronJobListRequest handles watchBatchV1beta1NamespacedCronJobList operation.
//
// Watch individual changes to a list of CronJob. deprecated: use the 'watch' parameter with a list
// operation instead.
//
// GET /apis/batch/v1beta1/watch/namespaces/{namespace}/cronjobs
func (s *Server) handleWatchBatchV1beta1NamespacedCronJobListRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchBatchV1beta1NamespacedCronJobList"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/batch/v1beta1/watch/namespaces/{namespace}/cronjobs"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchBatchV1beta1NamespacedCronJobList",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchBatchV1beta1NamespacedCronJobList",
			ID:   "watchBatchV1beta1NamespacedCronJobList",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchBatchV1beta1NamespacedCronJobList", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchBatchV1beta1NamespacedCronJobListParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchBatchV1beta1NamespacedCronJobListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchBatchV1beta1NamespacedCronJobList",
			OperationSummary: "",
			OperationID:      "watchBatchV1beta1NamespacedCronJobList",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchBatchV1beta1NamespacedCronJobListParams
			Response = WatchBatchV1beta1NamespacedCronJobListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchBatchV1beta1NamespacedCronJobListParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchBatchV1beta1NamespacedCronJobList(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchBatchV1beta1NamespacedCronJobList(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchBatchV1beta1NamespacedCronJobListResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchCertificatesV1CertificateSigningRequestRequest handles watchCertificatesV1CertificateSigningRequest operation.
//
// Watch changes to an object of kind CertificateSigningRequest. deprecated: use the 'watch'
// parameter with a list operation instead, filtered to a single item with the 'fieldSelector'
// parameter.
//
// GET /apis/certificates.k8s.io/v1/watch/certificatesigningrequests/{name}
func (s *Server) handleWatchCertificatesV1CertificateSigningRequestRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCertificatesV1CertificateSigningRequest"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/certificates.k8s.io/v1/watch/certificatesigningrequests/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCertificatesV1CertificateSigningRequest",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchCertificatesV1CertificateSigningRequest",
			ID:   "watchCertificatesV1CertificateSigningRequest",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchCertificatesV1CertificateSigningRequest", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchCertificatesV1CertificateSigningRequestParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchCertificatesV1CertificateSigningRequestRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchCertificatesV1CertificateSigningRequest",
			OperationSummary: "",
			OperationID:      "watchCertificatesV1CertificateSigningRequest",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchCertificatesV1CertificateSigningRequestParams
			Response = WatchCertificatesV1CertificateSigningRequestRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchCertificatesV1CertificateSigningRequestParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchCertificatesV1CertificateSigningRequest(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchCertificatesV1CertificateSigningRequest(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchCertificatesV1CertificateSigningRequestResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchCertificatesV1CertificateSigningRequestListRequest handles watchCertificatesV1CertificateSigningRequestList operation.
//
// Watch individual changes to a list of CertificateSigningRequest. deprecated: use the 'watch'
// parameter with a list operation instead.
//
// GET /apis/certificates.k8s.io/v1/watch/certificatesigningrequests
func (s *Server) handleWatchCertificatesV1CertificateSigningRequestListRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCertificatesV1CertificateSigningRequestList"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/certificates.k8s.io/v1/watch/certificatesigningrequests"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCertificatesV1CertificateSigningRequestList",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchCertificatesV1CertificateSigningRequestList",
			ID:   "watchCertificatesV1CertificateSigningRequestList",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchCertificatesV1CertificateSigningRequestList", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchCertificatesV1CertificateSigningRequestListParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchCertificatesV1CertificateSigningRequestListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchCertificatesV1CertificateSigningRequestList",
			OperationSummary: "",
			OperationID:      "watchCertificatesV1CertificateSigningRequestList",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchCertificatesV1CertificateSigningRequestListParams
			Response = WatchCertificatesV1CertificateSigningRequestListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchCertificatesV1CertificateSigningRequestListParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchCertificatesV1CertificateSigningRequestList(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchCertificatesV1CertificateSigningRequestList(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchCertificatesV1CertificateSigningRequestListResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchCoordinationV1LeaseListForAllNamespacesRequest handles watchCoordinationV1LeaseListForAllNamespaces operation.
//
// Watch individual changes to a list of Lease. deprecated: use the 'watch' parameter with a list
// operation instead.
//
// GET /apis/coordination.k8s.io/v1/watch/leases
func (s *Server) handleWatchCoordinationV1LeaseListForAllNamespacesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoordinationV1LeaseListForAllNamespaces"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/coordination.k8s.io/v1/watch/leases"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoordinationV1LeaseListForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchCoordinationV1LeaseListForAllNamespaces",
			ID:   "watchCoordinationV1LeaseListForAllNamespaces",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchCoordinationV1LeaseListForAllNamespaces", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchCoordinationV1LeaseListForAllNamespacesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchCoordinationV1LeaseListForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchCoordinationV1LeaseListForAllNamespaces",
			OperationSummary: "",
			OperationID:      "watchCoordinationV1LeaseListForAllNamespaces",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchCoordinationV1LeaseListForAllNamespacesParams
			Response = WatchCoordinationV1LeaseListForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchCoordinationV1LeaseListForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchCoordinationV1LeaseListForAllNamespaces(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchCoordinationV1LeaseListForAllNamespaces(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchCoordinationV1LeaseListForAllNamespacesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchCoordinationV1NamespacedLeaseRequest handles watchCoordinationV1NamespacedLease operation.
//
// Watch changes to an object of kind Lease. deprecated: use the 'watch' parameter with a list
// operation instead, filtered to a single item with the 'fieldSelector' parameter.
//
// GET /apis/coordination.k8s.io/v1/watch/namespaces/{namespace}/leases/{name}
func (s *Server) handleWatchCoordinationV1NamespacedLeaseRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoordinationV1NamespacedLease"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/coordination.k8s.io/v1/watch/namespaces/{namespace}/leases/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoordinationV1NamespacedLease",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchCoordinationV1NamespacedLease",
			ID:   "watchCoordinationV1NamespacedLease",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchCoordinationV1NamespacedLease", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchCoordinationV1NamespacedLeaseParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchCoordinationV1NamespacedLeaseRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchCoordinationV1NamespacedLease",
			OperationSummary: "",
			OperationID:      "watchCoordinationV1NamespacedLease",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchCoordinationV1NamespacedLeaseParams
			Response = WatchCoordinationV1NamespacedLeaseRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchCoordinationV1NamespacedLeaseParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchCoordinationV1NamespacedLease(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchCoordinationV1NamespacedLease(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchCoordinationV1NamespacedLeaseResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchCoordinationV1NamespacedLeaseListRequest handles watchCoordinationV1NamespacedLeaseList operation.
//
// Watch individual changes to a list of Lease. deprecated: use the 'watch' parameter with a list
// operation instead.
//
// GET /apis/coordination.k8s.io/v1/watch/namespaces/{namespace}/leases
func (s *Server) handleWatchCoordinationV1NamespacedLeaseListRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoordinationV1NamespacedLeaseList"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/coordination.k8s.io/v1/watch/namespaces/{namespace}/leases"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoordinationV1NamespacedLeaseList",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchCoordinationV1NamespacedLeaseList",
			ID:   "watchCoordinationV1NamespacedLeaseList",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchCoordinationV1NamespacedLeaseList", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchCoordinationV1NamespacedLeaseListParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchCoordinationV1NamespacedLeaseListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchCoordinationV1NamespacedLeaseList",
			OperationSummary: "",
			OperationID:      "watchCoordinationV1NamespacedLeaseList",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchCoordinationV1NamespacedLeaseListParams
			Response = WatchCoordinationV1NamespacedLeaseListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchCoordinationV1NamespacedLeaseListParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchCoordinationV1NamespacedLeaseList(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchCoordinationV1NamespacedLeaseList(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchCoordinationV1NamespacedLeaseListResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchCoreV1ConfigMapListForAllNamespacesRequest handles watchCoreV1ConfigMapListForAllNamespaces operation.
//
// Watch individual changes to a list of ConfigMap. deprecated: use the 'watch' parameter with a list
// operation instead.
//
// GET /api/v1/watch/configmaps
func (s *Server) handleWatchCoreV1ConfigMapListForAllNamespacesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1ConfigMapListForAllNamespaces"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/v1/watch/configmaps"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1ConfigMapListForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchCoreV1ConfigMapListForAllNamespaces",
			ID:   "watchCoreV1ConfigMapListForAllNamespaces",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchCoreV1ConfigMapListForAllNamespaces", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchCoreV1ConfigMapListForAllNamespacesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchCoreV1ConfigMapListForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchCoreV1ConfigMapListForAllNamespaces",
			OperationSummary: "",
			OperationID:      "watchCoreV1ConfigMapListForAllNamespaces",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchCoreV1ConfigMapListForAllNamespacesParams
			Response = WatchCoreV1ConfigMapListForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchCoreV1ConfigMapListForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchCoreV1ConfigMapListForAllNamespaces(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchCoreV1ConfigMapListForAllNamespaces(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchCoreV1ConfigMapListForAllNamespacesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchCoreV1EndpointsListForAllNamespacesRequest handles watchCoreV1EndpointsListForAllNamespaces operation.
//
// Watch individual changes to a list of Endpoints. deprecated: use the 'watch' parameter with a list
// operation instead.
//
// GET /api/v1/watch/endpoints
func (s *Server) handleWatchCoreV1EndpointsListForAllNamespacesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1EndpointsListForAllNamespaces"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/v1/watch/endpoints"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1EndpointsListForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchCoreV1EndpointsListForAllNamespaces",
			ID:   "watchCoreV1EndpointsListForAllNamespaces",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchCoreV1EndpointsListForAllNamespaces", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchCoreV1EndpointsListForAllNamespacesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchCoreV1EndpointsListForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchCoreV1EndpointsListForAllNamespaces",
			OperationSummary: "",
			OperationID:      "watchCoreV1EndpointsListForAllNamespaces",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchCoreV1EndpointsListForAllNamespacesParams
			Response = WatchCoreV1EndpointsListForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchCoreV1EndpointsListForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchCoreV1EndpointsListForAllNamespaces(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchCoreV1EndpointsListForAllNamespaces(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchCoreV1EndpointsListForAllNamespacesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchCoreV1EventListForAllNamespacesRequest handles watchCoreV1EventListForAllNamespaces operation.
//
// Watch individual changes to a list of Event. deprecated: use the 'watch' parameter with a list
// operation instead.
//
// GET /api/v1/watch/events
func (s *Server) handleWatchCoreV1EventListForAllNamespacesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1EventListForAllNamespaces"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/v1/watch/events"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1EventListForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchCoreV1EventListForAllNamespaces",
			ID:   "watchCoreV1EventListForAllNamespaces",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchCoreV1EventListForAllNamespaces", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchCoreV1EventListForAllNamespacesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchCoreV1EventListForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchCoreV1EventListForAllNamespaces",
			OperationSummary: "",
			OperationID:      "watchCoreV1EventListForAllNamespaces",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchCoreV1EventListForAllNamespacesParams
			Response = WatchCoreV1EventListForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchCoreV1EventListForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchCoreV1EventListForAllNamespaces(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchCoreV1EventListForAllNamespaces(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchCoreV1EventListForAllNamespacesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchCoreV1LimitRangeListForAllNamespacesRequest handles watchCoreV1LimitRangeListForAllNamespaces operation.
//
// Watch individual changes to a list of LimitRange. deprecated: use the 'watch' parameter with a
// list operation instead.
//
// GET /api/v1/watch/limitranges
func (s *Server) handleWatchCoreV1LimitRangeListForAllNamespacesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1LimitRangeListForAllNamespaces"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/v1/watch/limitranges"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1LimitRangeListForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchCoreV1LimitRangeListForAllNamespaces",
			ID:   "watchCoreV1LimitRangeListForAllNamespaces",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchCoreV1LimitRangeListForAllNamespaces", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchCoreV1LimitRangeListForAllNamespacesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchCoreV1LimitRangeListForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchCoreV1LimitRangeListForAllNamespaces",
			OperationSummary: "",
			OperationID:      "watchCoreV1LimitRangeListForAllNamespaces",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchCoreV1LimitRangeListForAllNamespacesParams
			Response = WatchCoreV1LimitRangeListForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchCoreV1LimitRangeListForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchCoreV1LimitRangeListForAllNamespaces(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchCoreV1LimitRangeListForAllNamespaces(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchCoreV1LimitRangeListForAllNamespacesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchCoreV1NamespaceRequest handles watchCoreV1Namespace operation.
//
// Watch changes to an object of kind Namespace. deprecated: use the 'watch' parameter with a list
// operation instead, filtered to a single item with the 'fieldSelector' parameter.
//
// GET /api/v1/watch/namespaces/{name}
func (s *Server) handleWatchCoreV1NamespaceRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1Namespace"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/v1/watch/namespaces/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1Namespace",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchCoreV1Namespace",
			ID:   "watchCoreV1Namespace",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchCoreV1Namespace", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchCoreV1NamespaceParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchCoreV1NamespaceRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchCoreV1Namespace",
			OperationSummary: "",
			OperationID:      "watchCoreV1Namespace",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchCoreV1NamespaceParams
			Response = WatchCoreV1NamespaceRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchCoreV1NamespaceParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchCoreV1Namespace(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchCoreV1Namespace(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchCoreV1NamespaceResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchCoreV1NamespaceListRequest handles watchCoreV1NamespaceList operation.
//
// Watch individual changes to a list of Namespace. deprecated: use the 'watch' parameter with a list
// operation instead.
//
// GET /api/v1/watch/namespaces
func (s *Server) handleWatchCoreV1NamespaceListRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1NamespaceList"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/v1/watch/namespaces"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1NamespaceList",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchCoreV1NamespaceList",
			ID:   "watchCoreV1NamespaceList",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchCoreV1NamespaceList", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchCoreV1NamespaceListParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchCoreV1NamespaceListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchCoreV1NamespaceList",
			OperationSummary: "",
			OperationID:      "watchCoreV1NamespaceList",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchCoreV1NamespaceListParams
			Response = WatchCoreV1NamespaceListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchCoreV1NamespaceListParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchCoreV1NamespaceList(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchCoreV1NamespaceList(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchCoreV1NamespaceListResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchCoreV1NamespacedConfigMapRequest handles watchCoreV1NamespacedConfigMap operation.
//
// Watch changes to an object of kind ConfigMap. deprecated: use the 'watch' parameter with a list
// operation instead, filtered to a single item with the 'fieldSelector' parameter.
//
// GET /api/v1/watch/namespaces/{namespace}/configmaps/{name}
func (s *Server) handleWatchCoreV1NamespacedConfigMapRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1NamespacedConfigMap"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/v1/watch/namespaces/{namespace}/configmaps/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1NamespacedConfigMap",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchCoreV1NamespacedConfigMap",
			ID:   "watchCoreV1NamespacedConfigMap",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchCoreV1NamespacedConfigMap", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchCoreV1NamespacedConfigMapParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchCoreV1NamespacedConfigMapRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchCoreV1NamespacedConfigMap",
			OperationSummary: "",
			OperationID:      "watchCoreV1NamespacedConfigMap",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchCoreV1NamespacedConfigMapParams
			Response = WatchCoreV1NamespacedConfigMapRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchCoreV1NamespacedConfigMapParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchCoreV1NamespacedConfigMap(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchCoreV1NamespacedConfigMap(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchCoreV1NamespacedConfigMapResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchCoreV1NamespacedConfigMapListRequest handles watchCoreV1NamespacedConfigMapList operation.
//
// Watch individual changes to a list of ConfigMap. deprecated: use the 'watch' parameter with a list
// operation instead.
//
// GET /api/v1/watch/namespaces/{namespace}/configmaps
func (s *Server) handleWatchCoreV1NamespacedConfigMapListRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1NamespacedConfigMapList"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/v1/watch/namespaces/{namespace}/configmaps"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1NamespacedConfigMapList",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchCoreV1NamespacedConfigMapList",
			ID:   "watchCoreV1NamespacedConfigMapList",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchCoreV1NamespacedConfigMapList", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchCoreV1NamespacedConfigMapListParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchCoreV1NamespacedConfigMapListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchCoreV1NamespacedConfigMapList",
			OperationSummary: "",
			OperationID:      "watchCoreV1NamespacedConfigMapList",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchCoreV1NamespacedConfigMapListParams
			Response = WatchCoreV1NamespacedConfigMapListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchCoreV1NamespacedConfigMapListParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchCoreV1NamespacedConfigMapList(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchCoreV1NamespacedConfigMapList(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchCoreV1NamespacedConfigMapListResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchCoreV1NamespacedEndpointsRequest handles watchCoreV1NamespacedEndpoints operation.
//
// Watch changes to an object of kind Endpoints. deprecated: use the 'watch' parameter with a list
// operation instead, filtered to a single item with the 'fieldSelector' parameter.
//
// GET /api/v1/watch/namespaces/{namespace}/endpoints/{name}
func (s *Server) handleWatchCoreV1NamespacedEndpointsRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1NamespacedEndpoints"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/v1/watch/namespaces/{namespace}/endpoints/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1NamespacedEndpoints",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchCoreV1NamespacedEndpoints",
			ID:   "watchCoreV1NamespacedEndpoints",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchCoreV1NamespacedEndpoints", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchCoreV1NamespacedEndpointsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchCoreV1NamespacedEndpointsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchCoreV1NamespacedEndpoints",
			OperationSummary: "",
			OperationID:      "watchCoreV1NamespacedEndpoints",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchCoreV1NamespacedEndpointsParams
			Response = WatchCoreV1NamespacedEndpointsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchCoreV1NamespacedEndpointsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchCoreV1NamespacedEndpoints(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchCoreV1NamespacedEndpoints(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchCoreV1NamespacedEndpointsResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchCoreV1NamespacedEndpointsListRequest handles watchCoreV1NamespacedEndpointsList operation.
//
// Watch individual changes to a list of Endpoints. deprecated: use the 'watch' parameter with a list
// operation instead.
//
// GET /api/v1/watch/namespaces/{namespace}/endpoints
func (s *Server) handleWatchCoreV1NamespacedEndpointsListRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1NamespacedEndpointsList"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/v1/watch/namespaces/{namespace}/endpoints"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1NamespacedEndpointsList",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchCoreV1NamespacedEndpointsList",
			ID:   "watchCoreV1NamespacedEndpointsList",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchCoreV1NamespacedEndpointsList", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchCoreV1NamespacedEndpointsListParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchCoreV1NamespacedEndpointsListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchCoreV1NamespacedEndpointsList",
			OperationSummary: "",
			OperationID:      "watchCoreV1NamespacedEndpointsList",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchCoreV1NamespacedEndpointsListParams
			Response = WatchCoreV1NamespacedEndpointsListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchCoreV1NamespacedEndpointsListParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchCoreV1NamespacedEndpointsList(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchCoreV1NamespacedEndpointsList(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchCoreV1NamespacedEndpointsListResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchCoreV1NamespacedEventRequest handles watchCoreV1NamespacedEvent operation.
//
// Watch changes to an object of kind Event. deprecated: use the 'watch' parameter with a list
// operation instead, filtered to a single item with the 'fieldSelector' parameter.
//
// GET /api/v1/watch/namespaces/{namespace}/events/{name}
func (s *Server) handleWatchCoreV1NamespacedEventRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1NamespacedEvent"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/v1/watch/namespaces/{namespace}/events/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1NamespacedEvent",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchCoreV1NamespacedEvent",
			ID:   "watchCoreV1NamespacedEvent",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchCoreV1NamespacedEvent", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchCoreV1NamespacedEventParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchCoreV1NamespacedEventRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchCoreV1NamespacedEvent",
			OperationSummary: "",
			OperationID:      "watchCoreV1NamespacedEvent",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchCoreV1NamespacedEventParams
			Response = WatchCoreV1NamespacedEventRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchCoreV1NamespacedEventParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchCoreV1NamespacedEvent(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchCoreV1NamespacedEvent(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchCoreV1NamespacedEventResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchCoreV1NamespacedEventListRequest handles watchCoreV1NamespacedEventList operation.
//
// Watch individual changes to a list of Event. deprecated: use the 'watch' parameter with a list
// operation instead.
//
// GET /api/v1/watch/namespaces/{namespace}/events
func (s *Server) handleWatchCoreV1NamespacedEventListRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1NamespacedEventList"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/v1/watch/namespaces/{namespace}/events"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1NamespacedEventList",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchCoreV1NamespacedEventList",
			ID:   "watchCoreV1NamespacedEventList",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchCoreV1NamespacedEventList", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchCoreV1NamespacedEventListParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchCoreV1NamespacedEventListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchCoreV1NamespacedEventList",
			OperationSummary: "",
			OperationID:      "watchCoreV1NamespacedEventList",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchCoreV1NamespacedEventListParams
			Response = WatchCoreV1NamespacedEventListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchCoreV1NamespacedEventListParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchCoreV1NamespacedEventList(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchCoreV1NamespacedEventList(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchCoreV1NamespacedEventListResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchCoreV1NamespacedLimitRangeRequest handles watchCoreV1NamespacedLimitRange operation.
//
// Watch changes to an object of kind LimitRange. deprecated: use the 'watch' parameter with a list
// operation instead, filtered to a single item with the 'fieldSelector' parameter.
//
// GET /api/v1/watch/namespaces/{namespace}/limitranges/{name}
func (s *Server) handleWatchCoreV1NamespacedLimitRangeRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1NamespacedLimitRange"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/v1/watch/namespaces/{namespace}/limitranges/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1NamespacedLimitRange",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchCoreV1NamespacedLimitRange",
			ID:   "watchCoreV1NamespacedLimitRange",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchCoreV1NamespacedLimitRange", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchCoreV1NamespacedLimitRangeParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchCoreV1NamespacedLimitRangeRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchCoreV1NamespacedLimitRange",
			OperationSummary: "",
			OperationID:      "watchCoreV1NamespacedLimitRange",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchCoreV1NamespacedLimitRangeParams
			Response = WatchCoreV1NamespacedLimitRangeRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchCoreV1NamespacedLimitRangeParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchCoreV1NamespacedLimitRange(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchCoreV1NamespacedLimitRange(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchCoreV1NamespacedLimitRangeResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchCoreV1NamespacedLimitRangeListRequest handles watchCoreV1NamespacedLimitRangeList operation.
//
// Watch individual changes to a list of LimitRange. deprecated: use the 'watch' parameter with a
// list operation instead.
//
// GET /api/v1/watch/namespaces/{namespace}/limitranges
func (s *Server) handleWatchCoreV1NamespacedLimitRangeListRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1NamespacedLimitRangeList"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/v1/watch/namespaces/{namespace}/limitranges"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1NamespacedLimitRangeList",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchCoreV1NamespacedLimitRangeList",
			ID:   "watchCoreV1NamespacedLimitRangeList",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchCoreV1NamespacedLimitRangeList", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchCoreV1NamespacedLimitRangeListParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchCoreV1NamespacedLimitRangeListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchCoreV1NamespacedLimitRangeList",
			OperationSummary: "",
			OperationID:      "watchCoreV1NamespacedLimitRangeList",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchCoreV1NamespacedLimitRangeListParams
			Response = WatchCoreV1NamespacedLimitRangeListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchCoreV1NamespacedLimitRangeListParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchCoreV1NamespacedLimitRangeList(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchCoreV1NamespacedLimitRangeList(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchCoreV1NamespacedLimitRangeListResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchCoreV1NamespacedPersistentVolumeClaimRequest handles watchCoreV1NamespacedPersistentVolumeClaim operation.
//
// Watch changes to an object of kind PersistentVolumeClaim. deprecated: use the 'watch' parameter
// with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
//
// GET /api/v1/watch/namespaces/{namespace}/persistentvolumeclaims/{name}
func (s *Server) handleWatchCoreV1NamespacedPersistentVolumeClaimRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1NamespacedPersistentVolumeClaim"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/v1/watch/namespaces/{namespace}/persistentvolumeclaims/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1NamespacedPersistentVolumeClaim",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchCoreV1NamespacedPersistentVolumeClaim",
			ID:   "watchCoreV1NamespacedPersistentVolumeClaim",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchCoreV1NamespacedPersistentVolumeClaim", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchCoreV1NamespacedPersistentVolumeClaimParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchCoreV1NamespacedPersistentVolumeClaimRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchCoreV1NamespacedPersistentVolumeClaim",
			OperationSummary: "",
			OperationID:      "watchCoreV1NamespacedPersistentVolumeClaim",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchCoreV1NamespacedPersistentVolumeClaimParams
			Response = WatchCoreV1NamespacedPersistentVolumeClaimRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchCoreV1NamespacedPersistentVolumeClaimParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchCoreV1NamespacedPersistentVolumeClaim(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchCoreV1NamespacedPersistentVolumeClaim(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchCoreV1NamespacedPersistentVolumeClaimResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchCoreV1NamespacedPersistentVolumeClaimListRequest handles watchCoreV1NamespacedPersistentVolumeClaimList operation.
//
// Watch individual changes to a list of PersistentVolumeClaim. deprecated: use the 'watch' parameter
// with a list operation instead.
//
// GET /api/v1/watch/namespaces/{namespace}/persistentvolumeclaims
func (s *Server) handleWatchCoreV1NamespacedPersistentVolumeClaimListRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1NamespacedPersistentVolumeClaimList"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/v1/watch/namespaces/{namespace}/persistentvolumeclaims"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1NamespacedPersistentVolumeClaimList",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchCoreV1NamespacedPersistentVolumeClaimList",
			ID:   "watchCoreV1NamespacedPersistentVolumeClaimList",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchCoreV1NamespacedPersistentVolumeClaimList", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchCoreV1NamespacedPersistentVolumeClaimListParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchCoreV1NamespacedPersistentVolumeClaimListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchCoreV1NamespacedPersistentVolumeClaimList",
			OperationSummary: "",
			OperationID:      "watchCoreV1NamespacedPersistentVolumeClaimList",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchCoreV1NamespacedPersistentVolumeClaimListParams
			Response = WatchCoreV1NamespacedPersistentVolumeClaimListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchCoreV1NamespacedPersistentVolumeClaimListParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchCoreV1NamespacedPersistentVolumeClaimList(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchCoreV1NamespacedPersistentVolumeClaimList(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchCoreV1NamespacedPersistentVolumeClaimListResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchCoreV1NamespacedPodRequest handles watchCoreV1NamespacedPod operation.
//
// Watch changes to an object of kind Pod. deprecated: use the 'watch' parameter with a list
// operation instead, filtered to a single item with the 'fieldSelector' parameter.
//
// GET /api/v1/watch/namespaces/{namespace}/pods/{name}
func (s *Server) handleWatchCoreV1NamespacedPodRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1NamespacedPod"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/v1/watch/namespaces/{namespace}/pods/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1NamespacedPod",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchCoreV1NamespacedPod",
			ID:   "watchCoreV1NamespacedPod",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchCoreV1NamespacedPod", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchCoreV1NamespacedPodParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchCoreV1NamespacedPodRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchCoreV1NamespacedPod",
			OperationSummary: "",
			OperationID:      "watchCoreV1NamespacedPod",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchCoreV1NamespacedPodParams
			Response = WatchCoreV1NamespacedPodRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchCoreV1NamespacedPodParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchCoreV1NamespacedPod(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchCoreV1NamespacedPod(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchCoreV1NamespacedPodResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchCoreV1NamespacedPodListRequest handles watchCoreV1NamespacedPodList operation.
//
// Watch individual changes to a list of Pod. deprecated: use the 'watch' parameter with a list
// operation instead.
//
// GET /api/v1/watch/namespaces/{namespace}/pods
func (s *Server) handleWatchCoreV1NamespacedPodListRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1NamespacedPodList"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/v1/watch/namespaces/{namespace}/pods"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1NamespacedPodList",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchCoreV1NamespacedPodList",
			ID:   "watchCoreV1NamespacedPodList",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchCoreV1NamespacedPodList", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchCoreV1NamespacedPodListParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchCoreV1NamespacedPodListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchCoreV1NamespacedPodList",
			OperationSummary: "",
			OperationID:      "watchCoreV1NamespacedPodList",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchCoreV1NamespacedPodListParams
			Response = WatchCoreV1NamespacedPodListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchCoreV1NamespacedPodListParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchCoreV1NamespacedPodList(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchCoreV1NamespacedPodList(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchCoreV1NamespacedPodListResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchCoreV1NamespacedPodTemplateRequest handles watchCoreV1NamespacedPodTemplate operation.
//
// Watch changes to an object of kind PodTemplate. deprecated: use the 'watch' parameter with a list
// operation instead, filtered to a single item with the 'fieldSelector' parameter.
//
// GET /api/v1/watch/namespaces/{namespace}/podtemplates/{name}
func (s *Server) handleWatchCoreV1NamespacedPodTemplateRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1NamespacedPodTemplate"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/v1/watch/namespaces/{namespace}/podtemplates/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1NamespacedPodTemplate",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchCoreV1NamespacedPodTemplate",
			ID:   "watchCoreV1NamespacedPodTemplate",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchCoreV1NamespacedPodTemplate", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchCoreV1NamespacedPodTemplateParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchCoreV1NamespacedPodTemplateRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchCoreV1NamespacedPodTemplate",
			OperationSummary: "",
			OperationID:      "watchCoreV1NamespacedPodTemplate",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchCoreV1NamespacedPodTemplateParams
			Response = WatchCoreV1NamespacedPodTemplateRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchCoreV1NamespacedPodTemplateParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchCoreV1NamespacedPodTemplate(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchCoreV1NamespacedPodTemplate(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchCoreV1NamespacedPodTemplateResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchCoreV1NamespacedPodTemplateListRequest handles watchCoreV1NamespacedPodTemplateList operation.
//
// Watch individual changes to a list of PodTemplate. deprecated: use the 'watch' parameter with a
// list operation instead.
//
// GET /api/v1/watch/namespaces/{namespace}/podtemplates
func (s *Server) handleWatchCoreV1NamespacedPodTemplateListRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1NamespacedPodTemplateList"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/v1/watch/namespaces/{namespace}/podtemplates"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1NamespacedPodTemplateList",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchCoreV1NamespacedPodTemplateList",
			ID:   "watchCoreV1NamespacedPodTemplateList",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchCoreV1NamespacedPodTemplateList", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchCoreV1NamespacedPodTemplateListParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchCoreV1NamespacedPodTemplateListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchCoreV1NamespacedPodTemplateList",
			OperationSummary: "",
			OperationID:      "watchCoreV1NamespacedPodTemplateList",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchCoreV1NamespacedPodTemplateListParams
			Response = WatchCoreV1NamespacedPodTemplateListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchCoreV1NamespacedPodTemplateListParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchCoreV1NamespacedPodTemplateList(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchCoreV1NamespacedPodTemplateList(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchCoreV1NamespacedPodTemplateListResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchCoreV1NamespacedReplicationControllerRequest handles watchCoreV1NamespacedReplicationController operation.
//
// Watch changes to an object of kind ReplicationController. deprecated: use the 'watch' parameter
// with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
//
// GET /api/v1/watch/namespaces/{namespace}/replicationcontrollers/{name}
func (s *Server) handleWatchCoreV1NamespacedReplicationControllerRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1NamespacedReplicationController"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/v1/watch/namespaces/{namespace}/replicationcontrollers/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1NamespacedReplicationController",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchCoreV1NamespacedReplicationController",
			ID:   "watchCoreV1NamespacedReplicationController",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchCoreV1NamespacedReplicationController", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchCoreV1NamespacedReplicationControllerParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchCoreV1NamespacedReplicationControllerRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchCoreV1NamespacedReplicationController",
			OperationSummary: "",
			OperationID:      "watchCoreV1NamespacedReplicationController",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchCoreV1NamespacedReplicationControllerParams
			Response = WatchCoreV1NamespacedReplicationControllerRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchCoreV1NamespacedReplicationControllerParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchCoreV1NamespacedReplicationController(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchCoreV1NamespacedReplicationController(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchCoreV1NamespacedReplicationControllerResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchCoreV1NamespacedReplicationControllerListRequest handles watchCoreV1NamespacedReplicationControllerList operation.
//
// Watch individual changes to a list of ReplicationController. deprecated: use the 'watch' parameter
// with a list operation instead.
//
// GET /api/v1/watch/namespaces/{namespace}/replicationcontrollers
func (s *Server) handleWatchCoreV1NamespacedReplicationControllerListRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1NamespacedReplicationControllerList"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/v1/watch/namespaces/{namespace}/replicationcontrollers"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1NamespacedReplicationControllerList",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchCoreV1NamespacedReplicationControllerList",
			ID:   "watchCoreV1NamespacedReplicationControllerList",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchCoreV1NamespacedReplicationControllerList", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchCoreV1NamespacedReplicationControllerListParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchCoreV1NamespacedReplicationControllerListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchCoreV1NamespacedReplicationControllerList",
			OperationSummary: "",
			OperationID:      "watchCoreV1NamespacedReplicationControllerList",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchCoreV1NamespacedReplicationControllerListParams
			Response = WatchCoreV1NamespacedReplicationControllerListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchCoreV1NamespacedReplicationControllerListParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchCoreV1NamespacedReplicationControllerList(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchCoreV1NamespacedReplicationControllerList(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchCoreV1NamespacedReplicationControllerListResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchCoreV1NamespacedResourceQuotaRequest handles watchCoreV1NamespacedResourceQuota operation.
//
// Watch changes to an object of kind ResourceQuota. deprecated: use the 'watch' parameter with a
// list operation instead, filtered to a single item with the 'fieldSelector' parameter.
//
// GET /api/v1/watch/namespaces/{namespace}/resourcequotas/{name}
func (s *Server) handleWatchCoreV1NamespacedResourceQuotaRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1NamespacedResourceQuota"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/v1/watch/namespaces/{namespace}/resourcequotas/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1NamespacedResourceQuota",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchCoreV1NamespacedResourceQuota",
			ID:   "watchCoreV1NamespacedResourceQuota",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchCoreV1NamespacedResourceQuota", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchCoreV1NamespacedResourceQuotaParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchCoreV1NamespacedResourceQuotaRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchCoreV1NamespacedResourceQuota",
			OperationSummary: "",
			OperationID:      "watchCoreV1NamespacedResourceQuota",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchCoreV1NamespacedResourceQuotaParams
			Response = WatchCoreV1NamespacedResourceQuotaRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchCoreV1NamespacedResourceQuotaParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchCoreV1NamespacedResourceQuota(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchCoreV1NamespacedResourceQuota(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchCoreV1NamespacedResourceQuotaResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchCoreV1NamespacedResourceQuotaListRequest handles watchCoreV1NamespacedResourceQuotaList operation.
//
// Watch individual changes to a list of ResourceQuota. deprecated: use the 'watch' parameter with a
// list operation instead.
//
// GET /api/v1/watch/namespaces/{namespace}/resourcequotas
func (s *Server) handleWatchCoreV1NamespacedResourceQuotaListRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1NamespacedResourceQuotaList"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/v1/watch/namespaces/{namespace}/resourcequotas"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1NamespacedResourceQuotaList",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchCoreV1NamespacedResourceQuotaList",
			ID:   "watchCoreV1NamespacedResourceQuotaList",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchCoreV1NamespacedResourceQuotaList", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchCoreV1NamespacedResourceQuotaListParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchCoreV1NamespacedResourceQuotaListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchCoreV1NamespacedResourceQuotaList",
			OperationSummary: "",
			OperationID:      "watchCoreV1NamespacedResourceQuotaList",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchCoreV1NamespacedResourceQuotaListParams
			Response = WatchCoreV1NamespacedResourceQuotaListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchCoreV1NamespacedResourceQuotaListParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchCoreV1NamespacedResourceQuotaList(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchCoreV1NamespacedResourceQuotaList(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchCoreV1NamespacedResourceQuotaListResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchCoreV1NamespacedSecretRequest handles watchCoreV1NamespacedSecret operation.
//
// Watch changes to an object of kind Secret. deprecated: use the 'watch' parameter with a list
// operation instead, filtered to a single item with the 'fieldSelector' parameter.
//
// GET /api/v1/watch/namespaces/{namespace}/secrets/{name}
func (s *Server) handleWatchCoreV1NamespacedSecretRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1NamespacedSecret"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/v1/watch/namespaces/{namespace}/secrets/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1NamespacedSecret",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchCoreV1NamespacedSecret",
			ID:   "watchCoreV1NamespacedSecret",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchCoreV1NamespacedSecret", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchCoreV1NamespacedSecretParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchCoreV1NamespacedSecretRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchCoreV1NamespacedSecret",
			OperationSummary: "",
			OperationID:      "watchCoreV1NamespacedSecret",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchCoreV1NamespacedSecretParams
			Response = WatchCoreV1NamespacedSecretRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchCoreV1NamespacedSecretParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchCoreV1NamespacedSecret(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchCoreV1NamespacedSecret(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchCoreV1NamespacedSecretResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchCoreV1NamespacedSecretListRequest handles watchCoreV1NamespacedSecretList operation.
//
// Watch individual changes to a list of Secret. deprecated: use the 'watch' parameter with a list
// operation instead.
//
// GET /api/v1/watch/namespaces/{namespace}/secrets
func (s *Server) handleWatchCoreV1NamespacedSecretListRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1NamespacedSecretList"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/v1/watch/namespaces/{namespace}/secrets"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1NamespacedSecretList",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchCoreV1NamespacedSecretList",
			ID:   "watchCoreV1NamespacedSecretList",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchCoreV1NamespacedSecretList", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchCoreV1NamespacedSecretListParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchCoreV1NamespacedSecretListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchCoreV1NamespacedSecretList",
			OperationSummary: "",
			OperationID:      "watchCoreV1NamespacedSecretList",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchCoreV1NamespacedSecretListParams
			Response = WatchCoreV1NamespacedSecretListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchCoreV1NamespacedSecretListParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchCoreV1NamespacedSecretList(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchCoreV1NamespacedSecretList(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchCoreV1NamespacedSecretListResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchCoreV1NamespacedServiceRequest handles watchCoreV1NamespacedService operation.
//
// Watch changes to an object of kind Service. deprecated: use the 'watch' parameter with a list
// operation instead, filtered to a single item with the 'fieldSelector' parameter.
//
// GET /api/v1/watch/namespaces/{namespace}/services/{name}
func (s *Server) handleWatchCoreV1NamespacedServiceRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1NamespacedService"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/v1/watch/namespaces/{namespace}/services/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1NamespacedService",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchCoreV1NamespacedService",
			ID:   "watchCoreV1NamespacedService",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchCoreV1NamespacedService", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchCoreV1NamespacedServiceParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchCoreV1NamespacedServiceRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchCoreV1NamespacedService",
			OperationSummary: "",
			OperationID:      "watchCoreV1NamespacedService",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchCoreV1NamespacedServiceParams
			Response = WatchCoreV1NamespacedServiceRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchCoreV1NamespacedServiceParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchCoreV1NamespacedService(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchCoreV1NamespacedService(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchCoreV1NamespacedServiceResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchCoreV1NamespacedServiceAccountRequest handles watchCoreV1NamespacedServiceAccount operation.
//
// Watch changes to an object of kind ServiceAccount. deprecated: use the 'watch' parameter with a
// list operation instead, filtered to a single item with the 'fieldSelector' parameter.
//
// GET /api/v1/watch/namespaces/{namespace}/serviceaccounts/{name}
func (s *Server) handleWatchCoreV1NamespacedServiceAccountRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1NamespacedServiceAccount"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/v1/watch/namespaces/{namespace}/serviceaccounts/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1NamespacedServiceAccount",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchCoreV1NamespacedServiceAccount",
			ID:   "watchCoreV1NamespacedServiceAccount",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchCoreV1NamespacedServiceAccount", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchCoreV1NamespacedServiceAccountParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchCoreV1NamespacedServiceAccountRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchCoreV1NamespacedServiceAccount",
			OperationSummary: "",
			OperationID:      "watchCoreV1NamespacedServiceAccount",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchCoreV1NamespacedServiceAccountParams
			Response = WatchCoreV1NamespacedServiceAccountRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchCoreV1NamespacedServiceAccountParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchCoreV1NamespacedServiceAccount(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchCoreV1NamespacedServiceAccount(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchCoreV1NamespacedServiceAccountResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchCoreV1NamespacedServiceAccountListRequest handles watchCoreV1NamespacedServiceAccountList operation.
//
// Watch individual changes to a list of ServiceAccount. deprecated: use the 'watch' parameter with a
// list operation instead.
//
// GET /api/v1/watch/namespaces/{namespace}/serviceaccounts
func (s *Server) handleWatchCoreV1NamespacedServiceAccountListRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1NamespacedServiceAccountList"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/v1/watch/namespaces/{namespace}/serviceaccounts"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1NamespacedServiceAccountList",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchCoreV1NamespacedServiceAccountList",
			ID:   "watchCoreV1NamespacedServiceAccountList",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchCoreV1NamespacedServiceAccountList", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchCoreV1NamespacedServiceAccountListParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchCoreV1NamespacedServiceAccountListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchCoreV1NamespacedServiceAccountList",
			OperationSummary: "",
			OperationID:      "watchCoreV1NamespacedServiceAccountList",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchCoreV1NamespacedServiceAccountListParams
			Response = WatchCoreV1NamespacedServiceAccountListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchCoreV1NamespacedServiceAccountListParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchCoreV1NamespacedServiceAccountList(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchCoreV1NamespacedServiceAccountList(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchCoreV1NamespacedServiceAccountListResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchCoreV1NamespacedServiceListRequest handles watchCoreV1NamespacedServiceList operation.
//
// Watch individual changes to a list of Service. deprecated: use the 'watch' parameter with a list
// operation instead.
//
// GET /api/v1/watch/namespaces/{namespace}/services
func (s *Server) handleWatchCoreV1NamespacedServiceListRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1NamespacedServiceList"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/v1/watch/namespaces/{namespace}/services"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1NamespacedServiceList",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchCoreV1NamespacedServiceList",
			ID:   "watchCoreV1NamespacedServiceList",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchCoreV1NamespacedServiceList", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchCoreV1NamespacedServiceListParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchCoreV1NamespacedServiceListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchCoreV1NamespacedServiceList",
			OperationSummary: "",
			OperationID:      "watchCoreV1NamespacedServiceList",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchCoreV1NamespacedServiceListParams
			Response = WatchCoreV1NamespacedServiceListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchCoreV1NamespacedServiceListParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchCoreV1NamespacedServiceList(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchCoreV1NamespacedServiceList(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchCoreV1NamespacedServiceListResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchCoreV1NodeRequest handles watchCoreV1Node operation.
//
// Watch changes to an object of kind Node. deprecated: use the 'watch' parameter with a list
// operation instead, filtered to a single item with the 'fieldSelector' parameter.
//
// GET /api/v1/watch/nodes/{name}
func (s *Server) handleWatchCoreV1NodeRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1Node"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/v1/watch/nodes/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1Node",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchCoreV1Node",
			ID:   "watchCoreV1Node",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchCoreV1Node", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchCoreV1NodeParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchCoreV1NodeRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchCoreV1Node",
			OperationSummary: "",
			OperationID:      "watchCoreV1Node",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchCoreV1NodeParams
			Response = WatchCoreV1NodeRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchCoreV1NodeParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchCoreV1Node(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchCoreV1Node(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchCoreV1NodeResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchCoreV1NodeListRequest handles watchCoreV1NodeList operation.
//
// Watch individual changes to a list of Node. deprecated: use the 'watch' parameter with a list
// operation instead.
//
// GET /api/v1/watch/nodes
func (s *Server) handleWatchCoreV1NodeListRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1NodeList"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/v1/watch/nodes"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1NodeList",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchCoreV1NodeList",
			ID:   "watchCoreV1NodeList",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchCoreV1NodeList", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchCoreV1NodeListParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchCoreV1NodeListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchCoreV1NodeList",
			OperationSummary: "",
			OperationID:      "watchCoreV1NodeList",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchCoreV1NodeListParams
			Response = WatchCoreV1NodeListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchCoreV1NodeListParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchCoreV1NodeList(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchCoreV1NodeList(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchCoreV1NodeListResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchCoreV1PersistentVolumeRequest handles watchCoreV1PersistentVolume operation.
//
// Watch changes to an object of kind PersistentVolume. deprecated: use the 'watch' parameter with a
// list operation instead, filtered to a single item with the 'fieldSelector' parameter.
//
// GET /api/v1/watch/persistentvolumes/{name}
func (s *Server) handleWatchCoreV1PersistentVolumeRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1PersistentVolume"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/v1/watch/persistentvolumes/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1PersistentVolume",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchCoreV1PersistentVolume",
			ID:   "watchCoreV1PersistentVolume",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchCoreV1PersistentVolume", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchCoreV1PersistentVolumeParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchCoreV1PersistentVolumeRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchCoreV1PersistentVolume",
			OperationSummary: "",
			OperationID:      "watchCoreV1PersistentVolume",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchCoreV1PersistentVolumeParams
			Response = WatchCoreV1PersistentVolumeRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchCoreV1PersistentVolumeParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchCoreV1PersistentVolume(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchCoreV1PersistentVolume(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchCoreV1PersistentVolumeResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchCoreV1PersistentVolumeClaimListForAllNamespacesRequest handles watchCoreV1PersistentVolumeClaimListForAllNamespaces operation.
//
// Watch individual changes to a list of PersistentVolumeClaim. deprecated: use the 'watch' parameter
// with a list operation instead.
//
// GET /api/v1/watch/persistentvolumeclaims
func (s *Server) handleWatchCoreV1PersistentVolumeClaimListForAllNamespacesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1PersistentVolumeClaimListForAllNamespaces"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/v1/watch/persistentvolumeclaims"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1PersistentVolumeClaimListForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchCoreV1PersistentVolumeClaimListForAllNamespaces",
			ID:   "watchCoreV1PersistentVolumeClaimListForAllNamespaces",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchCoreV1PersistentVolumeClaimListForAllNamespaces", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchCoreV1PersistentVolumeClaimListForAllNamespacesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchCoreV1PersistentVolumeClaimListForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchCoreV1PersistentVolumeClaimListForAllNamespaces",
			OperationSummary: "",
			OperationID:      "watchCoreV1PersistentVolumeClaimListForAllNamespaces",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchCoreV1PersistentVolumeClaimListForAllNamespacesParams
			Response = WatchCoreV1PersistentVolumeClaimListForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchCoreV1PersistentVolumeClaimListForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchCoreV1PersistentVolumeClaimListForAllNamespaces(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchCoreV1PersistentVolumeClaimListForAllNamespaces(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchCoreV1PersistentVolumeClaimListForAllNamespacesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchCoreV1PersistentVolumeListRequest handles watchCoreV1PersistentVolumeList operation.
//
// Watch individual changes to a list of PersistentVolume. deprecated: use the 'watch' parameter with
// a list operation instead.
//
// GET /api/v1/watch/persistentvolumes
func (s *Server) handleWatchCoreV1PersistentVolumeListRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1PersistentVolumeList"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/v1/watch/persistentvolumes"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1PersistentVolumeList",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchCoreV1PersistentVolumeList",
			ID:   "watchCoreV1PersistentVolumeList",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchCoreV1PersistentVolumeList", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchCoreV1PersistentVolumeListParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchCoreV1PersistentVolumeListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchCoreV1PersistentVolumeList",
			OperationSummary: "",
			OperationID:      "watchCoreV1PersistentVolumeList",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchCoreV1PersistentVolumeListParams
			Response = WatchCoreV1PersistentVolumeListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchCoreV1PersistentVolumeListParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchCoreV1PersistentVolumeList(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchCoreV1PersistentVolumeList(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchCoreV1PersistentVolumeListResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchCoreV1PodListForAllNamespacesRequest handles watchCoreV1PodListForAllNamespaces operation.
//
// Watch individual changes to a list of Pod. deprecated: use the 'watch' parameter with a list
// operation instead.
//
// GET /api/v1/watch/pods
func (s *Server) handleWatchCoreV1PodListForAllNamespacesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1PodListForAllNamespaces"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/v1/watch/pods"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1PodListForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchCoreV1PodListForAllNamespaces",
			ID:   "watchCoreV1PodListForAllNamespaces",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchCoreV1PodListForAllNamespaces", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchCoreV1PodListForAllNamespacesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchCoreV1PodListForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchCoreV1PodListForAllNamespaces",
			OperationSummary: "",
			OperationID:      "watchCoreV1PodListForAllNamespaces",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchCoreV1PodListForAllNamespacesParams
			Response = WatchCoreV1PodListForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchCoreV1PodListForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchCoreV1PodListForAllNamespaces(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchCoreV1PodListForAllNamespaces(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchCoreV1PodListForAllNamespacesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchCoreV1PodTemplateListForAllNamespacesRequest handles watchCoreV1PodTemplateListForAllNamespaces operation.
//
// Watch individual changes to a list of PodTemplate. deprecated: use the 'watch' parameter with a
// list operation instead.
//
// GET /api/v1/watch/podtemplates
func (s *Server) handleWatchCoreV1PodTemplateListForAllNamespacesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1PodTemplateListForAllNamespaces"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/v1/watch/podtemplates"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1PodTemplateListForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchCoreV1PodTemplateListForAllNamespaces",
			ID:   "watchCoreV1PodTemplateListForAllNamespaces",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchCoreV1PodTemplateListForAllNamespaces", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchCoreV1PodTemplateListForAllNamespacesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchCoreV1PodTemplateListForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchCoreV1PodTemplateListForAllNamespaces",
			OperationSummary: "",
			OperationID:      "watchCoreV1PodTemplateListForAllNamespaces",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchCoreV1PodTemplateListForAllNamespacesParams
			Response = WatchCoreV1PodTemplateListForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchCoreV1PodTemplateListForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchCoreV1PodTemplateListForAllNamespaces(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchCoreV1PodTemplateListForAllNamespaces(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchCoreV1PodTemplateListForAllNamespacesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchCoreV1ReplicationControllerListForAllNamespacesRequest handles watchCoreV1ReplicationControllerListForAllNamespaces operation.
//
// Watch individual changes to a list of ReplicationController. deprecated: use the 'watch' parameter
// with a list operation instead.
//
// GET /api/v1/watch/replicationcontrollers
func (s *Server) handleWatchCoreV1ReplicationControllerListForAllNamespacesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1ReplicationControllerListForAllNamespaces"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/v1/watch/replicationcontrollers"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1ReplicationControllerListForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchCoreV1ReplicationControllerListForAllNamespaces",
			ID:   "watchCoreV1ReplicationControllerListForAllNamespaces",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchCoreV1ReplicationControllerListForAllNamespaces", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchCoreV1ReplicationControllerListForAllNamespacesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchCoreV1ReplicationControllerListForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchCoreV1ReplicationControllerListForAllNamespaces",
			OperationSummary: "",
			OperationID:      "watchCoreV1ReplicationControllerListForAllNamespaces",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchCoreV1ReplicationControllerListForAllNamespacesParams
			Response = WatchCoreV1ReplicationControllerListForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchCoreV1ReplicationControllerListForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchCoreV1ReplicationControllerListForAllNamespaces(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchCoreV1ReplicationControllerListForAllNamespaces(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchCoreV1ReplicationControllerListForAllNamespacesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchCoreV1ResourceQuotaListForAllNamespacesRequest handles watchCoreV1ResourceQuotaListForAllNamespaces operation.
//
// Watch individual changes to a list of ResourceQuota. deprecated: use the 'watch' parameter with a
// list operation instead.
//
// GET /api/v1/watch/resourcequotas
func (s *Server) handleWatchCoreV1ResourceQuotaListForAllNamespacesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1ResourceQuotaListForAllNamespaces"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/v1/watch/resourcequotas"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1ResourceQuotaListForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchCoreV1ResourceQuotaListForAllNamespaces",
			ID:   "watchCoreV1ResourceQuotaListForAllNamespaces",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchCoreV1ResourceQuotaListForAllNamespaces", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchCoreV1ResourceQuotaListForAllNamespacesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchCoreV1ResourceQuotaListForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchCoreV1ResourceQuotaListForAllNamespaces",
			OperationSummary: "",
			OperationID:      "watchCoreV1ResourceQuotaListForAllNamespaces",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchCoreV1ResourceQuotaListForAllNamespacesParams
			Response = WatchCoreV1ResourceQuotaListForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchCoreV1ResourceQuotaListForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchCoreV1ResourceQuotaListForAllNamespaces(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchCoreV1ResourceQuotaListForAllNamespaces(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchCoreV1ResourceQuotaListForAllNamespacesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchCoreV1SecretListForAllNamespacesRequest handles watchCoreV1SecretListForAllNamespaces operation.
//
// Watch individual changes to a list of Secret. deprecated: use the 'watch' parameter with a list
// operation instead.
//
// GET /api/v1/watch/secrets
func (s *Server) handleWatchCoreV1SecretListForAllNamespacesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1SecretListForAllNamespaces"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/v1/watch/secrets"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1SecretListForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchCoreV1SecretListForAllNamespaces",
			ID:   "watchCoreV1SecretListForAllNamespaces",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchCoreV1SecretListForAllNamespaces", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchCoreV1SecretListForAllNamespacesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchCoreV1SecretListForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchCoreV1SecretListForAllNamespaces",
			OperationSummary: "",
			OperationID:      "watchCoreV1SecretListForAllNamespaces",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchCoreV1SecretListForAllNamespacesParams
			Response = WatchCoreV1SecretListForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchCoreV1SecretListForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchCoreV1SecretListForAllNamespaces(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchCoreV1SecretListForAllNamespaces(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchCoreV1SecretListForAllNamespacesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchCoreV1ServiceAccountListForAllNamespacesRequest handles watchCoreV1ServiceAccountListForAllNamespaces operation.
//
// Watch individual changes to a list of ServiceAccount. deprecated: use the 'watch' parameter with a
// list operation instead.
//
// GET /api/v1/watch/serviceaccounts
func (s *Server) handleWatchCoreV1ServiceAccountListForAllNamespacesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1ServiceAccountListForAllNamespaces"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/v1/watch/serviceaccounts"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1ServiceAccountListForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchCoreV1ServiceAccountListForAllNamespaces",
			ID:   "watchCoreV1ServiceAccountListForAllNamespaces",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchCoreV1ServiceAccountListForAllNamespaces", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchCoreV1ServiceAccountListForAllNamespacesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchCoreV1ServiceAccountListForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchCoreV1ServiceAccountListForAllNamespaces",
			OperationSummary: "",
			OperationID:      "watchCoreV1ServiceAccountListForAllNamespaces",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchCoreV1ServiceAccountListForAllNamespacesParams
			Response = WatchCoreV1ServiceAccountListForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchCoreV1ServiceAccountListForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchCoreV1ServiceAccountListForAllNamespaces(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchCoreV1ServiceAccountListForAllNamespaces(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchCoreV1ServiceAccountListForAllNamespacesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchCoreV1ServiceListForAllNamespacesRequest handles watchCoreV1ServiceListForAllNamespaces operation.
//
// Watch individual changes to a list of Service. deprecated: use the 'watch' parameter with a list
// operation instead.
//
// GET /api/v1/watch/services
func (s *Server) handleWatchCoreV1ServiceListForAllNamespacesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1ServiceListForAllNamespaces"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/api/v1/watch/services"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1ServiceListForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchCoreV1ServiceListForAllNamespaces",
			ID:   "watchCoreV1ServiceListForAllNamespaces",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchCoreV1ServiceListForAllNamespaces", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchCoreV1ServiceListForAllNamespacesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchCoreV1ServiceListForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchCoreV1ServiceListForAllNamespaces",
			OperationSummary: "",
			OperationID:      "watchCoreV1ServiceListForAllNamespaces",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchCoreV1ServiceListForAllNamespacesParams
			Response = WatchCoreV1ServiceListForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchCoreV1ServiceListForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchCoreV1ServiceListForAllNamespaces(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchCoreV1ServiceListForAllNamespaces(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchCoreV1ServiceListForAllNamespacesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchDiscoveryV1EndpointSliceListForAllNamespacesRequest handles watchDiscoveryV1EndpointSliceListForAllNamespaces operation.
//
// Watch individual changes to a list of EndpointSlice. deprecated: use the 'watch' parameter with a
// list operation instead.
//
// GET /apis/discovery.k8s.io/v1/watch/endpointslices
func (s *Server) handleWatchDiscoveryV1EndpointSliceListForAllNamespacesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchDiscoveryV1EndpointSliceListForAllNamespaces"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/discovery.k8s.io/v1/watch/endpointslices"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchDiscoveryV1EndpointSliceListForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchDiscoveryV1EndpointSliceListForAllNamespaces",
			ID:   "watchDiscoveryV1EndpointSliceListForAllNamespaces",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchDiscoveryV1EndpointSliceListForAllNamespaces", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchDiscoveryV1EndpointSliceListForAllNamespacesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchDiscoveryV1EndpointSliceListForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchDiscoveryV1EndpointSliceListForAllNamespaces",
			OperationSummary: "",
			OperationID:      "watchDiscoveryV1EndpointSliceListForAllNamespaces",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchDiscoveryV1EndpointSliceListForAllNamespacesParams
			Response = WatchDiscoveryV1EndpointSliceListForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchDiscoveryV1EndpointSliceListForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchDiscoveryV1EndpointSliceListForAllNamespaces(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchDiscoveryV1EndpointSliceListForAllNamespaces(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchDiscoveryV1EndpointSliceListForAllNamespacesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchDiscoveryV1NamespacedEndpointSliceRequest handles watchDiscoveryV1NamespacedEndpointSlice operation.
//
// Watch changes to an object of kind EndpointSlice. deprecated: use the 'watch' parameter with a
// list operation instead, filtered to a single item with the 'fieldSelector' parameter.
//
// GET /apis/discovery.k8s.io/v1/watch/namespaces/{namespace}/endpointslices/{name}
func (s *Server) handleWatchDiscoveryV1NamespacedEndpointSliceRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchDiscoveryV1NamespacedEndpointSlice"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/discovery.k8s.io/v1/watch/namespaces/{namespace}/endpointslices/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchDiscoveryV1NamespacedEndpointSlice",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchDiscoveryV1NamespacedEndpointSlice",
			ID:   "watchDiscoveryV1NamespacedEndpointSlice",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchDiscoveryV1NamespacedEndpointSlice", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchDiscoveryV1NamespacedEndpointSliceParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchDiscoveryV1NamespacedEndpointSliceRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchDiscoveryV1NamespacedEndpointSlice",
			OperationSummary: "",
			OperationID:      "watchDiscoveryV1NamespacedEndpointSlice",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchDiscoveryV1NamespacedEndpointSliceParams
			Response = WatchDiscoveryV1NamespacedEndpointSliceRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchDiscoveryV1NamespacedEndpointSliceParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchDiscoveryV1NamespacedEndpointSlice(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchDiscoveryV1NamespacedEndpointSlice(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchDiscoveryV1NamespacedEndpointSliceResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchDiscoveryV1NamespacedEndpointSliceListRequest handles watchDiscoveryV1NamespacedEndpointSliceList operation.
//
// Watch individual changes to a list of EndpointSlice. deprecated: use the 'watch' parameter with a
// list operation instead.
//
// GET /apis/discovery.k8s.io/v1/watch/namespaces/{namespace}/endpointslices
func (s *Server) handleWatchDiscoveryV1NamespacedEndpointSliceListRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchDiscoveryV1NamespacedEndpointSliceList"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/discovery.k8s.io/v1/watch/namespaces/{namespace}/endpointslices"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchDiscoveryV1NamespacedEndpointSliceList",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchDiscoveryV1NamespacedEndpointSliceList",
			ID:   "watchDiscoveryV1NamespacedEndpointSliceList",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchDiscoveryV1NamespacedEndpointSliceList", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchDiscoveryV1NamespacedEndpointSliceListParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchDiscoveryV1NamespacedEndpointSliceListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchDiscoveryV1NamespacedEndpointSliceList",
			OperationSummary: "",
			OperationID:      "watchDiscoveryV1NamespacedEndpointSliceList",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchDiscoveryV1NamespacedEndpointSliceListParams
			Response = WatchDiscoveryV1NamespacedEndpointSliceListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchDiscoveryV1NamespacedEndpointSliceListParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchDiscoveryV1NamespacedEndpointSliceList(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchDiscoveryV1NamespacedEndpointSliceList(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchDiscoveryV1NamespacedEndpointSliceListResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchDiscoveryV1beta1EndpointSliceListForAllNamespacesRequest handles watchDiscoveryV1beta1EndpointSliceListForAllNamespaces operation.
//
// Watch individual changes to a list of EndpointSlice. deprecated: use the 'watch' parameter with a
// list operation instead.
//
// GET /apis/discovery.k8s.io/v1beta1/watch/endpointslices
func (s *Server) handleWatchDiscoveryV1beta1EndpointSliceListForAllNamespacesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchDiscoveryV1beta1EndpointSliceListForAllNamespaces"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/discovery.k8s.io/v1beta1/watch/endpointslices"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchDiscoveryV1beta1EndpointSliceListForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchDiscoveryV1beta1EndpointSliceListForAllNamespaces",
			ID:   "watchDiscoveryV1beta1EndpointSliceListForAllNamespaces",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchDiscoveryV1beta1EndpointSliceListForAllNamespaces", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchDiscoveryV1beta1EndpointSliceListForAllNamespacesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchDiscoveryV1beta1EndpointSliceListForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchDiscoveryV1beta1EndpointSliceListForAllNamespaces",
			OperationSummary: "",
			OperationID:      "watchDiscoveryV1beta1EndpointSliceListForAllNamespaces",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchDiscoveryV1beta1EndpointSliceListForAllNamespacesParams
			Response = WatchDiscoveryV1beta1EndpointSliceListForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchDiscoveryV1beta1EndpointSliceListForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchDiscoveryV1beta1EndpointSliceListForAllNamespaces(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchDiscoveryV1beta1EndpointSliceListForAllNamespaces(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchDiscoveryV1beta1EndpointSliceListForAllNamespacesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchDiscoveryV1beta1NamespacedEndpointSliceRequest handles watchDiscoveryV1beta1NamespacedEndpointSlice operation.
//
// Watch changes to an object of kind EndpointSlice. deprecated: use the 'watch' parameter with a
// list operation instead, filtered to a single item with the 'fieldSelector' parameter.
//
// GET /apis/discovery.k8s.io/v1beta1/watch/namespaces/{namespace}/endpointslices/{name}
func (s *Server) handleWatchDiscoveryV1beta1NamespacedEndpointSliceRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchDiscoveryV1beta1NamespacedEndpointSlice"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/discovery.k8s.io/v1beta1/watch/namespaces/{namespace}/endpointslices/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchDiscoveryV1beta1NamespacedEndpointSlice",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchDiscoveryV1beta1NamespacedEndpointSlice",
			ID:   "watchDiscoveryV1beta1NamespacedEndpointSlice",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchDiscoveryV1beta1NamespacedEndpointSlice", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchDiscoveryV1beta1NamespacedEndpointSliceParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchDiscoveryV1beta1NamespacedEndpointSliceRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchDiscoveryV1beta1NamespacedEndpointSlice",
			OperationSummary: "",
			OperationID:      "watchDiscoveryV1beta1NamespacedEndpointSlice",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchDiscoveryV1beta1NamespacedEndpointSliceParams
			Response = WatchDiscoveryV1beta1NamespacedEndpointSliceRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchDiscoveryV1beta1NamespacedEndpointSliceParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchDiscoveryV1beta1NamespacedEndpointSlice(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchDiscoveryV1beta1NamespacedEndpointSlice(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchDiscoveryV1beta1NamespacedEndpointSliceResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchDiscoveryV1beta1NamespacedEndpointSliceListRequest handles watchDiscoveryV1beta1NamespacedEndpointSliceList operation.
//
// Watch individual changes to a list of EndpointSlice. deprecated: use the 'watch' parameter with a
// list operation instead.
//
// GET /apis/discovery.k8s.io/v1beta1/watch/namespaces/{namespace}/endpointslices
func (s *Server) handleWatchDiscoveryV1beta1NamespacedEndpointSliceListRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchDiscoveryV1beta1NamespacedEndpointSliceList"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/discovery.k8s.io/v1beta1/watch/namespaces/{namespace}/endpointslices"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchDiscoveryV1beta1NamespacedEndpointSliceList",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchDiscoveryV1beta1NamespacedEndpointSliceList",
			ID:   "watchDiscoveryV1beta1NamespacedEndpointSliceList",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchDiscoveryV1beta1NamespacedEndpointSliceList", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchDiscoveryV1beta1NamespacedEndpointSliceListParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchDiscoveryV1beta1NamespacedEndpointSliceListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchDiscoveryV1beta1NamespacedEndpointSliceList",
			OperationSummary: "",
			OperationID:      "watchDiscoveryV1beta1NamespacedEndpointSliceList",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchDiscoveryV1beta1NamespacedEndpointSliceListParams
			Response = WatchDiscoveryV1beta1NamespacedEndpointSliceListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchDiscoveryV1beta1NamespacedEndpointSliceListParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchDiscoveryV1beta1NamespacedEndpointSliceList(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchDiscoveryV1beta1NamespacedEndpointSliceList(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchDiscoveryV1beta1NamespacedEndpointSliceListResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchEventsV1EventListForAllNamespacesRequest handles watchEventsV1EventListForAllNamespaces operation.
//
// Watch individual changes to a list of Event. deprecated: use the 'watch' parameter with a list
// operation instead.
//
// GET /apis/events.k8s.io/v1/watch/events
func (s *Server) handleWatchEventsV1EventListForAllNamespacesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchEventsV1EventListForAllNamespaces"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/events.k8s.io/v1/watch/events"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchEventsV1EventListForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchEventsV1EventListForAllNamespaces",
			ID:   "watchEventsV1EventListForAllNamespaces",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchEventsV1EventListForAllNamespaces", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchEventsV1EventListForAllNamespacesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchEventsV1EventListForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchEventsV1EventListForAllNamespaces",
			OperationSummary: "",
			OperationID:      "watchEventsV1EventListForAllNamespaces",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchEventsV1EventListForAllNamespacesParams
			Response = WatchEventsV1EventListForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchEventsV1EventListForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchEventsV1EventListForAllNamespaces(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchEventsV1EventListForAllNamespaces(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchEventsV1EventListForAllNamespacesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchEventsV1NamespacedEventRequest handles watchEventsV1NamespacedEvent operation.
//
// Watch changes to an object of kind Event. deprecated: use the 'watch' parameter with a list
// operation instead, filtered to a single item with the 'fieldSelector' parameter.
//
// GET /apis/events.k8s.io/v1/watch/namespaces/{namespace}/events/{name}
func (s *Server) handleWatchEventsV1NamespacedEventRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchEventsV1NamespacedEvent"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/events.k8s.io/v1/watch/namespaces/{namespace}/events/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchEventsV1NamespacedEvent",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchEventsV1NamespacedEvent",
			ID:   "watchEventsV1NamespacedEvent",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchEventsV1NamespacedEvent", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchEventsV1NamespacedEventParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchEventsV1NamespacedEventRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchEventsV1NamespacedEvent",
			OperationSummary: "",
			OperationID:      "watchEventsV1NamespacedEvent",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchEventsV1NamespacedEventParams
			Response = WatchEventsV1NamespacedEventRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchEventsV1NamespacedEventParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchEventsV1NamespacedEvent(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchEventsV1NamespacedEvent(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchEventsV1NamespacedEventResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchEventsV1NamespacedEventListRequest handles watchEventsV1NamespacedEventList operation.
//
// Watch individual changes to a list of Event. deprecated: use the 'watch' parameter with a list
// operation instead.
//
// GET /apis/events.k8s.io/v1/watch/namespaces/{namespace}/events
func (s *Server) handleWatchEventsV1NamespacedEventListRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchEventsV1NamespacedEventList"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/events.k8s.io/v1/watch/namespaces/{namespace}/events"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchEventsV1NamespacedEventList",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchEventsV1NamespacedEventList",
			ID:   "watchEventsV1NamespacedEventList",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchEventsV1NamespacedEventList", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchEventsV1NamespacedEventListParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchEventsV1NamespacedEventListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchEventsV1NamespacedEventList",
			OperationSummary: "",
			OperationID:      "watchEventsV1NamespacedEventList",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchEventsV1NamespacedEventListParams
			Response = WatchEventsV1NamespacedEventListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchEventsV1NamespacedEventListParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchEventsV1NamespacedEventList(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchEventsV1NamespacedEventList(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchEventsV1NamespacedEventListResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchEventsV1beta1EventListForAllNamespacesRequest handles watchEventsV1beta1EventListForAllNamespaces operation.
//
// Watch individual changes to a list of Event. deprecated: use the 'watch' parameter with a list
// operation instead.
//
// GET /apis/events.k8s.io/v1beta1/watch/events
func (s *Server) handleWatchEventsV1beta1EventListForAllNamespacesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchEventsV1beta1EventListForAllNamespaces"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/events.k8s.io/v1beta1/watch/events"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchEventsV1beta1EventListForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchEventsV1beta1EventListForAllNamespaces",
			ID:   "watchEventsV1beta1EventListForAllNamespaces",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchEventsV1beta1EventListForAllNamespaces", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchEventsV1beta1EventListForAllNamespacesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchEventsV1beta1EventListForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchEventsV1beta1EventListForAllNamespaces",
			OperationSummary: "",
			OperationID:      "watchEventsV1beta1EventListForAllNamespaces",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchEventsV1beta1EventListForAllNamespacesParams
			Response = WatchEventsV1beta1EventListForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchEventsV1beta1EventListForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchEventsV1beta1EventListForAllNamespaces(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchEventsV1beta1EventListForAllNamespaces(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchEventsV1beta1EventListForAllNamespacesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchEventsV1beta1NamespacedEventRequest handles watchEventsV1beta1NamespacedEvent operation.
//
// Watch changes to an object of kind Event. deprecated: use the 'watch' parameter with a list
// operation instead, filtered to a single item with the 'fieldSelector' parameter.
//
// GET /apis/events.k8s.io/v1beta1/watch/namespaces/{namespace}/events/{name}
func (s *Server) handleWatchEventsV1beta1NamespacedEventRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchEventsV1beta1NamespacedEvent"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/events.k8s.io/v1beta1/watch/namespaces/{namespace}/events/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchEventsV1beta1NamespacedEvent",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchEventsV1beta1NamespacedEvent",
			ID:   "watchEventsV1beta1NamespacedEvent",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchEventsV1beta1NamespacedEvent", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchEventsV1beta1NamespacedEventParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchEventsV1beta1NamespacedEventRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchEventsV1beta1NamespacedEvent",
			OperationSummary: "",
			OperationID:      "watchEventsV1beta1NamespacedEvent",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchEventsV1beta1NamespacedEventParams
			Response = WatchEventsV1beta1NamespacedEventRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchEventsV1beta1NamespacedEventParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchEventsV1beta1NamespacedEvent(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchEventsV1beta1NamespacedEvent(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchEventsV1beta1NamespacedEventResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchEventsV1beta1NamespacedEventListRequest handles watchEventsV1beta1NamespacedEventList operation.
//
// Watch individual changes to a list of Event. deprecated: use the 'watch' parameter with a list
// operation instead.
//
// GET /apis/events.k8s.io/v1beta1/watch/namespaces/{namespace}/events
func (s *Server) handleWatchEventsV1beta1NamespacedEventListRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchEventsV1beta1NamespacedEventList"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/events.k8s.io/v1beta1/watch/namespaces/{namespace}/events"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchEventsV1beta1NamespacedEventList",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchEventsV1beta1NamespacedEventList",
			ID:   "watchEventsV1beta1NamespacedEventList",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchEventsV1beta1NamespacedEventList", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchEventsV1beta1NamespacedEventListParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchEventsV1beta1NamespacedEventListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchEventsV1beta1NamespacedEventList",
			OperationSummary: "",
			OperationID:      "watchEventsV1beta1NamespacedEventList",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchEventsV1beta1NamespacedEventListParams
			Response = WatchEventsV1beta1NamespacedEventListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchEventsV1beta1NamespacedEventListParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchEventsV1beta1NamespacedEventList(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchEventsV1beta1NamespacedEventList(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchEventsV1beta1NamespacedEventListResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchFlowcontrolApiserverV1beta1FlowSchemaRequest handles watchFlowcontrolApiserverV1beta1FlowSchema operation.
//
// Watch changes to an object of kind FlowSchema. deprecated: use the 'watch' parameter with a list
// operation instead, filtered to a single item with the 'fieldSelector' parameter.
//
// GET /apis/flowcontrol.apiserver.k8s.io/v1beta1/watch/flowschemas/{name}
func (s *Server) handleWatchFlowcontrolApiserverV1beta1FlowSchemaRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchFlowcontrolApiserverV1beta1FlowSchema"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/flowcontrol.apiserver.k8s.io/v1beta1/watch/flowschemas/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchFlowcontrolApiserverV1beta1FlowSchema",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchFlowcontrolApiserverV1beta1FlowSchema",
			ID:   "watchFlowcontrolApiserverV1beta1FlowSchema",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchFlowcontrolApiserverV1beta1FlowSchema", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchFlowcontrolApiserverV1beta1FlowSchemaParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchFlowcontrolApiserverV1beta1FlowSchemaRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchFlowcontrolApiserverV1beta1FlowSchema",
			OperationSummary: "",
			OperationID:      "watchFlowcontrolApiserverV1beta1FlowSchema",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchFlowcontrolApiserverV1beta1FlowSchemaParams
			Response = WatchFlowcontrolApiserverV1beta1FlowSchemaRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchFlowcontrolApiserverV1beta1FlowSchemaParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchFlowcontrolApiserverV1beta1FlowSchema(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchFlowcontrolApiserverV1beta1FlowSchema(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchFlowcontrolApiserverV1beta1FlowSchemaResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchFlowcontrolApiserverV1beta1FlowSchemaListRequest handles watchFlowcontrolApiserverV1beta1FlowSchemaList operation.
//
// Watch individual changes to a list of FlowSchema. deprecated: use the 'watch' parameter with a
// list operation instead.
//
// GET /apis/flowcontrol.apiserver.k8s.io/v1beta1/watch/flowschemas
func (s *Server) handleWatchFlowcontrolApiserverV1beta1FlowSchemaListRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchFlowcontrolApiserverV1beta1FlowSchemaList"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/flowcontrol.apiserver.k8s.io/v1beta1/watch/flowschemas"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchFlowcontrolApiserverV1beta1FlowSchemaList",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchFlowcontrolApiserverV1beta1FlowSchemaList",
			ID:   "watchFlowcontrolApiserverV1beta1FlowSchemaList",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchFlowcontrolApiserverV1beta1FlowSchemaList", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchFlowcontrolApiserverV1beta1FlowSchemaListParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchFlowcontrolApiserverV1beta1FlowSchemaListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchFlowcontrolApiserverV1beta1FlowSchemaList",
			OperationSummary: "",
			OperationID:      "watchFlowcontrolApiserverV1beta1FlowSchemaList",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchFlowcontrolApiserverV1beta1FlowSchemaListParams
			Response = WatchFlowcontrolApiserverV1beta1FlowSchemaListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchFlowcontrolApiserverV1beta1FlowSchemaListParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchFlowcontrolApiserverV1beta1FlowSchemaList(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchFlowcontrolApiserverV1beta1FlowSchemaList(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchFlowcontrolApiserverV1beta1FlowSchemaListResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationRequest handles watchFlowcontrolApiserverV1beta1PriorityLevelConfiguration operation.
//
// Watch changes to an object of kind PriorityLevelConfiguration. deprecated: use the 'watch'
// parameter with a list operation instead, filtered to a single item with the 'fieldSelector'
// parameter.
//
// GET /apis/flowcontrol.apiserver.k8s.io/v1beta1/watch/prioritylevelconfigurations/{name}
func (s *Server) handleWatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchFlowcontrolApiserverV1beta1PriorityLevelConfiguration"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/flowcontrol.apiserver.k8s.io/v1beta1/watch/prioritylevelconfigurations/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchFlowcontrolApiserverV1beta1PriorityLevelConfiguration",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchFlowcontrolApiserverV1beta1PriorityLevelConfiguration",
			ID:   "watchFlowcontrolApiserverV1beta1PriorityLevelConfiguration",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchFlowcontrolApiserverV1beta1PriorityLevelConfiguration", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchFlowcontrolApiserverV1beta1PriorityLevelConfiguration",
			OperationSummary: "",
			OperationID:      "watchFlowcontrolApiserverV1beta1PriorityLevelConfiguration",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationParams
			Response = WatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchFlowcontrolApiserverV1beta1PriorityLevelConfiguration(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchFlowcontrolApiserverV1beta1PriorityLevelConfiguration(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationListRequest handles watchFlowcontrolApiserverV1beta1PriorityLevelConfigurationList operation.
//
// Watch individual changes to a list of PriorityLevelConfiguration. deprecated: use the 'watch'
// parameter with a list operation instead.
//
// GET /apis/flowcontrol.apiserver.k8s.io/v1beta1/watch/prioritylevelconfigurations
func (s *Server) handleWatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationListRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchFlowcontrolApiserverV1beta1PriorityLevelConfigurationList"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/flowcontrol.apiserver.k8s.io/v1beta1/watch/prioritylevelconfigurations"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationList",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationList",
			ID:   "watchFlowcontrolApiserverV1beta1PriorityLevelConfigurationList",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationList", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationListParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationList",
			OperationSummary: "",
			OperationID:      "watchFlowcontrolApiserverV1beta1PriorityLevelConfigurationList",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationListParams
			Response = WatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationListParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationList(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationList(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationListResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchFlowcontrolApiserverV1beta2FlowSchemaRequest handles watchFlowcontrolApiserverV1beta2FlowSchema operation.
//
// Watch changes to an object of kind FlowSchema. deprecated: use the 'watch' parameter with a list
// operation instead, filtered to a single item with the 'fieldSelector' parameter.
//
// GET /apis/flowcontrol.apiserver.k8s.io/v1beta2/watch/flowschemas/{name}
func (s *Server) handleWatchFlowcontrolApiserverV1beta2FlowSchemaRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchFlowcontrolApiserverV1beta2FlowSchema"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/flowcontrol.apiserver.k8s.io/v1beta2/watch/flowschemas/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchFlowcontrolApiserverV1beta2FlowSchema",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchFlowcontrolApiserverV1beta2FlowSchema",
			ID:   "watchFlowcontrolApiserverV1beta2FlowSchema",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchFlowcontrolApiserverV1beta2FlowSchema", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchFlowcontrolApiserverV1beta2FlowSchemaParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchFlowcontrolApiserverV1beta2FlowSchemaRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchFlowcontrolApiserverV1beta2FlowSchema",
			OperationSummary: "",
			OperationID:      "watchFlowcontrolApiserverV1beta2FlowSchema",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchFlowcontrolApiserverV1beta2FlowSchemaParams
			Response = WatchFlowcontrolApiserverV1beta2FlowSchemaRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchFlowcontrolApiserverV1beta2FlowSchemaParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchFlowcontrolApiserverV1beta2FlowSchema(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchFlowcontrolApiserverV1beta2FlowSchema(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchFlowcontrolApiserverV1beta2FlowSchemaResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchFlowcontrolApiserverV1beta2FlowSchemaListRequest handles watchFlowcontrolApiserverV1beta2FlowSchemaList operation.
//
// Watch individual changes to a list of FlowSchema. deprecated: use the 'watch' parameter with a
// list operation instead.
//
// GET /apis/flowcontrol.apiserver.k8s.io/v1beta2/watch/flowschemas
func (s *Server) handleWatchFlowcontrolApiserverV1beta2FlowSchemaListRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchFlowcontrolApiserverV1beta2FlowSchemaList"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/flowcontrol.apiserver.k8s.io/v1beta2/watch/flowschemas"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchFlowcontrolApiserverV1beta2FlowSchemaList",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchFlowcontrolApiserverV1beta2FlowSchemaList",
			ID:   "watchFlowcontrolApiserverV1beta2FlowSchemaList",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchFlowcontrolApiserverV1beta2FlowSchemaList", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchFlowcontrolApiserverV1beta2FlowSchemaListParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchFlowcontrolApiserverV1beta2FlowSchemaListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchFlowcontrolApiserverV1beta2FlowSchemaList",
			OperationSummary: "",
			OperationID:      "watchFlowcontrolApiserverV1beta2FlowSchemaList",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchFlowcontrolApiserverV1beta2FlowSchemaListParams
			Response = WatchFlowcontrolApiserverV1beta2FlowSchemaListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchFlowcontrolApiserverV1beta2FlowSchemaListParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchFlowcontrolApiserverV1beta2FlowSchemaList(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchFlowcontrolApiserverV1beta2FlowSchemaList(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchFlowcontrolApiserverV1beta2FlowSchemaListResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationRequest handles watchFlowcontrolApiserverV1beta2PriorityLevelConfiguration operation.
//
// Watch changes to an object of kind PriorityLevelConfiguration. deprecated: use the 'watch'
// parameter with a list operation instead, filtered to a single item with the 'fieldSelector'
// parameter.
//
// GET /apis/flowcontrol.apiserver.k8s.io/v1beta2/watch/prioritylevelconfigurations/{name}
func (s *Server) handleWatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchFlowcontrolApiserverV1beta2PriorityLevelConfiguration"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/flowcontrol.apiserver.k8s.io/v1beta2/watch/prioritylevelconfigurations/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchFlowcontrolApiserverV1beta2PriorityLevelConfiguration",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchFlowcontrolApiserverV1beta2PriorityLevelConfiguration",
			ID:   "watchFlowcontrolApiserverV1beta2PriorityLevelConfiguration",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchFlowcontrolApiserverV1beta2PriorityLevelConfiguration", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchFlowcontrolApiserverV1beta2PriorityLevelConfiguration",
			OperationSummary: "",
			OperationID:      "watchFlowcontrolApiserverV1beta2PriorityLevelConfiguration",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationParams
			Response = WatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchFlowcontrolApiserverV1beta2PriorityLevelConfiguration(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchFlowcontrolApiserverV1beta2PriorityLevelConfiguration(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationListRequest handles watchFlowcontrolApiserverV1beta2PriorityLevelConfigurationList operation.
//
// Watch individual changes to a list of PriorityLevelConfiguration. deprecated: use the 'watch'
// parameter with a list operation instead.
//
// GET /apis/flowcontrol.apiserver.k8s.io/v1beta2/watch/prioritylevelconfigurations
func (s *Server) handleWatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationListRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchFlowcontrolApiserverV1beta2PriorityLevelConfigurationList"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/flowcontrol.apiserver.k8s.io/v1beta2/watch/prioritylevelconfigurations"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationList",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationList",
			ID:   "watchFlowcontrolApiserverV1beta2PriorityLevelConfigurationList",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationList", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationListParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationList",
			OperationSummary: "",
			OperationID:      "watchFlowcontrolApiserverV1beta2PriorityLevelConfigurationList",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationListParams
			Response = WatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationListParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationList(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationList(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationListResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchInternalApiserverV1alpha1StorageVersionRequest handles watchInternalApiserverV1alpha1StorageVersion operation.
//
// Watch changes to an object of kind StorageVersion. deprecated: use the 'watch' parameter with a
// list operation instead, filtered to a single item with the 'fieldSelector' parameter.
//
// GET /apis/internal.apiserver.k8s.io/v1alpha1/watch/storageversions/{name}
func (s *Server) handleWatchInternalApiserverV1alpha1StorageVersionRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchInternalApiserverV1alpha1StorageVersion"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/internal.apiserver.k8s.io/v1alpha1/watch/storageversions/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchInternalApiserverV1alpha1StorageVersion",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchInternalApiserverV1alpha1StorageVersion",
			ID:   "watchInternalApiserverV1alpha1StorageVersion",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchInternalApiserverV1alpha1StorageVersion", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchInternalApiserverV1alpha1StorageVersionParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchInternalApiserverV1alpha1StorageVersionRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchInternalApiserverV1alpha1StorageVersion",
			OperationSummary: "",
			OperationID:      "watchInternalApiserverV1alpha1StorageVersion",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchInternalApiserverV1alpha1StorageVersionParams
			Response = WatchInternalApiserverV1alpha1StorageVersionRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchInternalApiserverV1alpha1StorageVersionParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchInternalApiserverV1alpha1StorageVersion(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchInternalApiserverV1alpha1StorageVersion(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchInternalApiserverV1alpha1StorageVersionResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchInternalApiserverV1alpha1StorageVersionListRequest handles watchInternalApiserverV1alpha1StorageVersionList operation.
//
// Watch individual changes to a list of StorageVersion. deprecated: use the 'watch' parameter with a
// list operation instead.
//
// GET /apis/internal.apiserver.k8s.io/v1alpha1/watch/storageversions
func (s *Server) handleWatchInternalApiserverV1alpha1StorageVersionListRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchInternalApiserverV1alpha1StorageVersionList"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/internal.apiserver.k8s.io/v1alpha1/watch/storageversions"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchInternalApiserverV1alpha1StorageVersionList",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchInternalApiserverV1alpha1StorageVersionList",
			ID:   "watchInternalApiserverV1alpha1StorageVersionList",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchInternalApiserverV1alpha1StorageVersionList", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchInternalApiserverV1alpha1StorageVersionListParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchInternalApiserverV1alpha1StorageVersionListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchInternalApiserverV1alpha1StorageVersionList",
			OperationSummary: "",
			OperationID:      "watchInternalApiserverV1alpha1StorageVersionList",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchInternalApiserverV1alpha1StorageVersionListParams
			Response = WatchInternalApiserverV1alpha1StorageVersionListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchInternalApiserverV1alpha1StorageVersionListParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchInternalApiserverV1alpha1StorageVersionList(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchInternalApiserverV1alpha1StorageVersionList(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchInternalApiserverV1alpha1StorageVersionListResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchNetworkingV1IngressClassRequest handles watchNetworkingV1IngressClass operation.
//
// Watch changes to an object of kind IngressClass. deprecated: use the 'watch' parameter with a list
// operation instead, filtered to a single item with the 'fieldSelector' parameter.
//
// GET /apis/networking.k8s.io/v1/watch/ingressclasses/{name}
func (s *Server) handleWatchNetworkingV1IngressClassRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchNetworkingV1IngressClass"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/networking.k8s.io/v1/watch/ingressclasses/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchNetworkingV1IngressClass",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchNetworkingV1IngressClass",
			ID:   "watchNetworkingV1IngressClass",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchNetworkingV1IngressClass", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchNetworkingV1IngressClassParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchNetworkingV1IngressClassRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchNetworkingV1IngressClass",
			OperationSummary: "",
			OperationID:      "watchNetworkingV1IngressClass",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchNetworkingV1IngressClassParams
			Response = WatchNetworkingV1IngressClassRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchNetworkingV1IngressClassParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchNetworkingV1IngressClass(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchNetworkingV1IngressClass(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchNetworkingV1IngressClassResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchNetworkingV1IngressClassListRequest handles watchNetworkingV1IngressClassList operation.
//
// Watch individual changes to a list of IngressClass. deprecated: use the 'watch' parameter with a
// list operation instead.
//
// GET /apis/networking.k8s.io/v1/watch/ingressclasses
func (s *Server) handleWatchNetworkingV1IngressClassListRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchNetworkingV1IngressClassList"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/networking.k8s.io/v1/watch/ingressclasses"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchNetworkingV1IngressClassList",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchNetworkingV1IngressClassList",
			ID:   "watchNetworkingV1IngressClassList",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchNetworkingV1IngressClassList", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchNetworkingV1IngressClassListParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchNetworkingV1IngressClassListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchNetworkingV1IngressClassList",
			OperationSummary: "",
			OperationID:      "watchNetworkingV1IngressClassList",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchNetworkingV1IngressClassListParams
			Response = WatchNetworkingV1IngressClassListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchNetworkingV1IngressClassListParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchNetworkingV1IngressClassList(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchNetworkingV1IngressClassList(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchNetworkingV1IngressClassListResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchNetworkingV1IngressListForAllNamespacesRequest handles watchNetworkingV1IngressListForAllNamespaces operation.
//
// Watch individual changes to a list of Ingress. deprecated: use the 'watch' parameter with a list
// operation instead.
//
// GET /apis/networking.k8s.io/v1/watch/ingresses
func (s *Server) handleWatchNetworkingV1IngressListForAllNamespacesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchNetworkingV1IngressListForAllNamespaces"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/networking.k8s.io/v1/watch/ingresses"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchNetworkingV1IngressListForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchNetworkingV1IngressListForAllNamespaces",
			ID:   "watchNetworkingV1IngressListForAllNamespaces",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchNetworkingV1IngressListForAllNamespaces", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchNetworkingV1IngressListForAllNamespacesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchNetworkingV1IngressListForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchNetworkingV1IngressListForAllNamespaces",
			OperationSummary: "",
			OperationID:      "watchNetworkingV1IngressListForAllNamespaces",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchNetworkingV1IngressListForAllNamespacesParams
			Response = WatchNetworkingV1IngressListForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchNetworkingV1IngressListForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchNetworkingV1IngressListForAllNamespaces(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchNetworkingV1IngressListForAllNamespaces(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchNetworkingV1IngressListForAllNamespacesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchNetworkingV1NamespacedIngressRequest handles watchNetworkingV1NamespacedIngress operation.
//
// Watch changes to an object of kind Ingress. deprecated: use the 'watch' parameter with a list
// operation instead, filtered to a single item with the 'fieldSelector' parameter.
//
// GET /apis/networking.k8s.io/v1/watch/namespaces/{namespace}/ingresses/{name}
func (s *Server) handleWatchNetworkingV1NamespacedIngressRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchNetworkingV1NamespacedIngress"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/networking.k8s.io/v1/watch/namespaces/{namespace}/ingresses/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchNetworkingV1NamespacedIngress",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchNetworkingV1NamespacedIngress",
			ID:   "watchNetworkingV1NamespacedIngress",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchNetworkingV1NamespacedIngress", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchNetworkingV1NamespacedIngressParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchNetworkingV1NamespacedIngressRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchNetworkingV1NamespacedIngress",
			OperationSummary: "",
			OperationID:      "watchNetworkingV1NamespacedIngress",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchNetworkingV1NamespacedIngressParams
			Response = WatchNetworkingV1NamespacedIngressRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchNetworkingV1NamespacedIngressParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchNetworkingV1NamespacedIngress(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchNetworkingV1NamespacedIngress(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchNetworkingV1NamespacedIngressResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchNetworkingV1NamespacedIngressListRequest handles watchNetworkingV1NamespacedIngressList operation.
//
// Watch individual changes to a list of Ingress. deprecated: use the 'watch' parameter with a list
// operation instead.
//
// GET /apis/networking.k8s.io/v1/watch/namespaces/{namespace}/ingresses
func (s *Server) handleWatchNetworkingV1NamespacedIngressListRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchNetworkingV1NamespacedIngressList"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/networking.k8s.io/v1/watch/namespaces/{namespace}/ingresses"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchNetworkingV1NamespacedIngressList",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchNetworkingV1NamespacedIngressList",
			ID:   "watchNetworkingV1NamespacedIngressList",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchNetworkingV1NamespacedIngressList", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchNetworkingV1NamespacedIngressListParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchNetworkingV1NamespacedIngressListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchNetworkingV1NamespacedIngressList",
			OperationSummary: "",
			OperationID:      "watchNetworkingV1NamespacedIngressList",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchNetworkingV1NamespacedIngressListParams
			Response = WatchNetworkingV1NamespacedIngressListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchNetworkingV1NamespacedIngressListParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchNetworkingV1NamespacedIngressList(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchNetworkingV1NamespacedIngressList(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchNetworkingV1NamespacedIngressListResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchNetworkingV1NamespacedNetworkPolicyRequest handles watchNetworkingV1NamespacedNetworkPolicy operation.
//
// Watch changes to an object of kind NetworkPolicy. deprecated: use the 'watch' parameter with a
// list operation instead, filtered to a single item with the 'fieldSelector' parameter.
//
// GET /apis/networking.k8s.io/v1/watch/namespaces/{namespace}/networkpolicies/{name}
func (s *Server) handleWatchNetworkingV1NamespacedNetworkPolicyRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchNetworkingV1NamespacedNetworkPolicy"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/networking.k8s.io/v1/watch/namespaces/{namespace}/networkpolicies/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchNetworkingV1NamespacedNetworkPolicy",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchNetworkingV1NamespacedNetworkPolicy",
			ID:   "watchNetworkingV1NamespacedNetworkPolicy",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchNetworkingV1NamespacedNetworkPolicy", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchNetworkingV1NamespacedNetworkPolicyParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchNetworkingV1NamespacedNetworkPolicyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchNetworkingV1NamespacedNetworkPolicy",
			OperationSummary: "",
			OperationID:      "watchNetworkingV1NamespacedNetworkPolicy",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchNetworkingV1NamespacedNetworkPolicyParams
			Response = WatchNetworkingV1NamespacedNetworkPolicyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchNetworkingV1NamespacedNetworkPolicyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchNetworkingV1NamespacedNetworkPolicy(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchNetworkingV1NamespacedNetworkPolicy(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchNetworkingV1NamespacedNetworkPolicyResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchNetworkingV1NamespacedNetworkPolicyListRequest handles watchNetworkingV1NamespacedNetworkPolicyList operation.
//
// Watch individual changes to a list of NetworkPolicy. deprecated: use the 'watch' parameter with a
// list operation instead.
//
// GET /apis/networking.k8s.io/v1/watch/namespaces/{namespace}/networkpolicies
func (s *Server) handleWatchNetworkingV1NamespacedNetworkPolicyListRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchNetworkingV1NamespacedNetworkPolicyList"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/networking.k8s.io/v1/watch/namespaces/{namespace}/networkpolicies"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchNetworkingV1NamespacedNetworkPolicyList",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchNetworkingV1NamespacedNetworkPolicyList",
			ID:   "watchNetworkingV1NamespacedNetworkPolicyList",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchNetworkingV1NamespacedNetworkPolicyList", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchNetworkingV1NamespacedNetworkPolicyListParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchNetworkingV1NamespacedNetworkPolicyListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchNetworkingV1NamespacedNetworkPolicyList",
			OperationSummary: "",
			OperationID:      "watchNetworkingV1NamespacedNetworkPolicyList",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchNetworkingV1NamespacedNetworkPolicyListParams
			Response = WatchNetworkingV1NamespacedNetworkPolicyListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchNetworkingV1NamespacedNetworkPolicyListParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchNetworkingV1NamespacedNetworkPolicyList(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchNetworkingV1NamespacedNetworkPolicyList(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchNetworkingV1NamespacedNetworkPolicyListResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchNetworkingV1NetworkPolicyListForAllNamespacesRequest handles watchNetworkingV1NetworkPolicyListForAllNamespaces operation.
//
// Watch individual changes to a list of NetworkPolicy. deprecated: use the 'watch' parameter with a
// list operation instead.
//
// GET /apis/networking.k8s.io/v1/watch/networkpolicies
func (s *Server) handleWatchNetworkingV1NetworkPolicyListForAllNamespacesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchNetworkingV1NetworkPolicyListForAllNamespaces"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/networking.k8s.io/v1/watch/networkpolicies"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchNetworkingV1NetworkPolicyListForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchNetworkingV1NetworkPolicyListForAllNamespaces",
			ID:   "watchNetworkingV1NetworkPolicyListForAllNamespaces",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchNetworkingV1NetworkPolicyListForAllNamespaces", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchNetworkingV1NetworkPolicyListForAllNamespacesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchNetworkingV1NetworkPolicyListForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchNetworkingV1NetworkPolicyListForAllNamespaces",
			OperationSummary: "",
			OperationID:      "watchNetworkingV1NetworkPolicyListForAllNamespaces",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchNetworkingV1NetworkPolicyListForAllNamespacesParams
			Response = WatchNetworkingV1NetworkPolicyListForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchNetworkingV1NetworkPolicyListForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchNetworkingV1NetworkPolicyListForAllNamespaces(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchNetworkingV1NetworkPolicyListForAllNamespaces(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchNetworkingV1NetworkPolicyListForAllNamespacesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchNodeV1RuntimeClassRequest handles watchNodeV1RuntimeClass operation.
//
// Watch changes to an object of kind RuntimeClass. deprecated: use the 'watch' parameter with a list
// operation instead, filtered to a single item with the 'fieldSelector' parameter.
//
// GET /apis/node.k8s.io/v1/watch/runtimeclasses/{name}
func (s *Server) handleWatchNodeV1RuntimeClassRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchNodeV1RuntimeClass"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/node.k8s.io/v1/watch/runtimeclasses/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchNodeV1RuntimeClass",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchNodeV1RuntimeClass",
			ID:   "watchNodeV1RuntimeClass",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchNodeV1RuntimeClass", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchNodeV1RuntimeClassParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchNodeV1RuntimeClassRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchNodeV1RuntimeClass",
			OperationSummary: "",
			OperationID:      "watchNodeV1RuntimeClass",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchNodeV1RuntimeClassParams
			Response = WatchNodeV1RuntimeClassRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchNodeV1RuntimeClassParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchNodeV1RuntimeClass(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchNodeV1RuntimeClass(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchNodeV1RuntimeClassResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchNodeV1RuntimeClassListRequest handles watchNodeV1RuntimeClassList operation.
//
// Watch individual changes to a list of RuntimeClass. deprecated: use the 'watch' parameter with a
// list operation instead.
//
// GET /apis/node.k8s.io/v1/watch/runtimeclasses
func (s *Server) handleWatchNodeV1RuntimeClassListRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchNodeV1RuntimeClassList"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/node.k8s.io/v1/watch/runtimeclasses"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchNodeV1RuntimeClassList",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchNodeV1RuntimeClassList",
			ID:   "watchNodeV1RuntimeClassList",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchNodeV1RuntimeClassList", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchNodeV1RuntimeClassListParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchNodeV1RuntimeClassListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchNodeV1RuntimeClassList",
			OperationSummary: "",
			OperationID:      "watchNodeV1RuntimeClassList",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchNodeV1RuntimeClassListParams
			Response = WatchNodeV1RuntimeClassListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchNodeV1RuntimeClassListParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchNodeV1RuntimeClassList(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchNodeV1RuntimeClassList(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchNodeV1RuntimeClassListResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchNodeV1alpha1RuntimeClassRequest handles watchNodeV1alpha1RuntimeClass operation.
//
// Watch changes to an object of kind RuntimeClass. deprecated: use the 'watch' parameter with a list
// operation instead, filtered to a single item with the 'fieldSelector' parameter.
//
// GET /apis/node.k8s.io/v1alpha1/watch/runtimeclasses/{name}
func (s *Server) handleWatchNodeV1alpha1RuntimeClassRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchNodeV1alpha1RuntimeClass"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/node.k8s.io/v1alpha1/watch/runtimeclasses/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchNodeV1alpha1RuntimeClass",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchNodeV1alpha1RuntimeClass",
			ID:   "watchNodeV1alpha1RuntimeClass",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchNodeV1alpha1RuntimeClass", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchNodeV1alpha1RuntimeClassParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchNodeV1alpha1RuntimeClassRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchNodeV1alpha1RuntimeClass",
			OperationSummary: "",
			OperationID:      "watchNodeV1alpha1RuntimeClass",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchNodeV1alpha1RuntimeClassParams
			Response = WatchNodeV1alpha1RuntimeClassRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchNodeV1alpha1RuntimeClassParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchNodeV1alpha1RuntimeClass(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchNodeV1alpha1RuntimeClass(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchNodeV1alpha1RuntimeClassResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchNodeV1alpha1RuntimeClassListRequest handles watchNodeV1alpha1RuntimeClassList operation.
//
// Watch individual changes to a list of RuntimeClass. deprecated: use the 'watch' parameter with a
// list operation instead.
//
// GET /apis/node.k8s.io/v1alpha1/watch/runtimeclasses
func (s *Server) handleWatchNodeV1alpha1RuntimeClassListRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchNodeV1alpha1RuntimeClassList"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/node.k8s.io/v1alpha1/watch/runtimeclasses"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchNodeV1alpha1RuntimeClassList",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchNodeV1alpha1RuntimeClassList",
			ID:   "watchNodeV1alpha1RuntimeClassList",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchNodeV1alpha1RuntimeClassList", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchNodeV1alpha1RuntimeClassListParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchNodeV1alpha1RuntimeClassListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchNodeV1alpha1RuntimeClassList",
			OperationSummary: "",
			OperationID:      "watchNodeV1alpha1RuntimeClassList",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchNodeV1alpha1RuntimeClassListParams
			Response = WatchNodeV1alpha1RuntimeClassListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchNodeV1alpha1RuntimeClassListParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchNodeV1alpha1RuntimeClassList(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchNodeV1alpha1RuntimeClassList(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchNodeV1alpha1RuntimeClassListResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchNodeV1beta1RuntimeClassRequest handles watchNodeV1beta1RuntimeClass operation.
//
// Watch changes to an object of kind RuntimeClass. deprecated: use the 'watch' parameter with a list
// operation instead, filtered to a single item with the 'fieldSelector' parameter.
//
// GET /apis/node.k8s.io/v1beta1/watch/runtimeclasses/{name}
func (s *Server) handleWatchNodeV1beta1RuntimeClassRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchNodeV1beta1RuntimeClass"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/node.k8s.io/v1beta1/watch/runtimeclasses/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchNodeV1beta1RuntimeClass",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchNodeV1beta1RuntimeClass",
			ID:   "watchNodeV1beta1RuntimeClass",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchNodeV1beta1RuntimeClass", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchNodeV1beta1RuntimeClassParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchNodeV1beta1RuntimeClassRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchNodeV1beta1RuntimeClass",
			OperationSummary: "",
			OperationID:      "watchNodeV1beta1RuntimeClass",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchNodeV1beta1RuntimeClassParams
			Response = WatchNodeV1beta1RuntimeClassRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchNodeV1beta1RuntimeClassParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchNodeV1beta1RuntimeClass(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchNodeV1beta1RuntimeClass(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchNodeV1beta1RuntimeClassResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchNodeV1beta1RuntimeClassListRequest handles watchNodeV1beta1RuntimeClassList operation.
//
// Watch individual changes to a list of RuntimeClass. deprecated: use the 'watch' parameter with a
// list operation instead.
//
// GET /apis/node.k8s.io/v1beta1/watch/runtimeclasses
func (s *Server) handleWatchNodeV1beta1RuntimeClassListRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchNodeV1beta1RuntimeClassList"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/node.k8s.io/v1beta1/watch/runtimeclasses"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchNodeV1beta1RuntimeClassList",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchNodeV1beta1RuntimeClassList",
			ID:   "watchNodeV1beta1RuntimeClassList",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchNodeV1beta1RuntimeClassList", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchNodeV1beta1RuntimeClassListParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchNodeV1beta1RuntimeClassListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchNodeV1beta1RuntimeClassList",
			OperationSummary: "",
			OperationID:      "watchNodeV1beta1RuntimeClassList",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchNodeV1beta1RuntimeClassListParams
			Response = WatchNodeV1beta1RuntimeClassListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchNodeV1beta1RuntimeClassListParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchNodeV1beta1RuntimeClassList(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchNodeV1beta1RuntimeClassList(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchNodeV1beta1RuntimeClassListResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchPolicyV1NamespacedPodDisruptionBudgetRequest handles watchPolicyV1NamespacedPodDisruptionBudget operation.
//
// Watch changes to an object of kind PodDisruptionBudget. deprecated: use the 'watch' parameter with
// a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
//
// GET /apis/policy/v1/watch/namespaces/{namespace}/poddisruptionbudgets/{name}
func (s *Server) handleWatchPolicyV1NamespacedPodDisruptionBudgetRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchPolicyV1NamespacedPodDisruptionBudget"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/policy/v1/watch/namespaces/{namespace}/poddisruptionbudgets/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchPolicyV1NamespacedPodDisruptionBudget",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchPolicyV1NamespacedPodDisruptionBudget",
			ID:   "watchPolicyV1NamespacedPodDisruptionBudget",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchPolicyV1NamespacedPodDisruptionBudget", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchPolicyV1NamespacedPodDisruptionBudgetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchPolicyV1NamespacedPodDisruptionBudgetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchPolicyV1NamespacedPodDisruptionBudget",
			OperationSummary: "",
			OperationID:      "watchPolicyV1NamespacedPodDisruptionBudget",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchPolicyV1NamespacedPodDisruptionBudgetParams
			Response = WatchPolicyV1NamespacedPodDisruptionBudgetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchPolicyV1NamespacedPodDisruptionBudgetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchPolicyV1NamespacedPodDisruptionBudget(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchPolicyV1NamespacedPodDisruptionBudget(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchPolicyV1NamespacedPodDisruptionBudgetResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchPolicyV1NamespacedPodDisruptionBudgetListRequest handles watchPolicyV1NamespacedPodDisruptionBudgetList operation.
//
// Watch individual changes to a list of PodDisruptionBudget. deprecated: use the 'watch' parameter
// with a list operation instead.
//
// GET /apis/policy/v1/watch/namespaces/{namespace}/poddisruptionbudgets
func (s *Server) handleWatchPolicyV1NamespacedPodDisruptionBudgetListRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchPolicyV1NamespacedPodDisruptionBudgetList"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/policy/v1/watch/namespaces/{namespace}/poddisruptionbudgets"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchPolicyV1NamespacedPodDisruptionBudgetList",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchPolicyV1NamespacedPodDisruptionBudgetList",
			ID:   "watchPolicyV1NamespacedPodDisruptionBudgetList",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchPolicyV1NamespacedPodDisruptionBudgetList", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchPolicyV1NamespacedPodDisruptionBudgetListParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchPolicyV1NamespacedPodDisruptionBudgetListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchPolicyV1NamespacedPodDisruptionBudgetList",
			OperationSummary: "",
			OperationID:      "watchPolicyV1NamespacedPodDisruptionBudgetList",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchPolicyV1NamespacedPodDisruptionBudgetListParams
			Response = WatchPolicyV1NamespacedPodDisruptionBudgetListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchPolicyV1NamespacedPodDisruptionBudgetListParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchPolicyV1NamespacedPodDisruptionBudgetList(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchPolicyV1NamespacedPodDisruptionBudgetList(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchPolicyV1NamespacedPodDisruptionBudgetListResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchPolicyV1PodDisruptionBudgetListForAllNamespacesRequest handles watchPolicyV1PodDisruptionBudgetListForAllNamespaces operation.
//
// Watch individual changes to a list of PodDisruptionBudget. deprecated: use the 'watch' parameter
// with a list operation instead.
//
// GET /apis/policy/v1/watch/poddisruptionbudgets
func (s *Server) handleWatchPolicyV1PodDisruptionBudgetListForAllNamespacesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchPolicyV1PodDisruptionBudgetListForAllNamespaces"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/policy/v1/watch/poddisruptionbudgets"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchPolicyV1PodDisruptionBudgetListForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchPolicyV1PodDisruptionBudgetListForAllNamespaces",
			ID:   "watchPolicyV1PodDisruptionBudgetListForAllNamespaces",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchPolicyV1PodDisruptionBudgetListForAllNamespaces", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchPolicyV1PodDisruptionBudgetListForAllNamespacesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchPolicyV1PodDisruptionBudgetListForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchPolicyV1PodDisruptionBudgetListForAllNamespaces",
			OperationSummary: "",
			OperationID:      "watchPolicyV1PodDisruptionBudgetListForAllNamespaces",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchPolicyV1PodDisruptionBudgetListForAllNamespacesParams
			Response = WatchPolicyV1PodDisruptionBudgetListForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchPolicyV1PodDisruptionBudgetListForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchPolicyV1PodDisruptionBudgetListForAllNamespaces(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchPolicyV1PodDisruptionBudgetListForAllNamespaces(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchPolicyV1PodDisruptionBudgetListForAllNamespacesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchPolicyV1beta1NamespacedPodDisruptionBudgetRequest handles watchPolicyV1beta1NamespacedPodDisruptionBudget operation.
//
// Watch changes to an object of kind PodDisruptionBudget. deprecated: use the 'watch' parameter with
// a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
//
// GET /apis/policy/v1beta1/watch/namespaces/{namespace}/poddisruptionbudgets/{name}
func (s *Server) handleWatchPolicyV1beta1NamespacedPodDisruptionBudgetRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchPolicyV1beta1NamespacedPodDisruptionBudget"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/policy/v1beta1/watch/namespaces/{namespace}/poddisruptionbudgets/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchPolicyV1beta1NamespacedPodDisruptionBudget",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchPolicyV1beta1NamespacedPodDisruptionBudget",
			ID:   "watchPolicyV1beta1NamespacedPodDisruptionBudget",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchPolicyV1beta1NamespacedPodDisruptionBudget", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchPolicyV1beta1NamespacedPodDisruptionBudgetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchPolicyV1beta1NamespacedPodDisruptionBudgetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchPolicyV1beta1NamespacedPodDisruptionBudget",
			OperationSummary: "",
			OperationID:      "watchPolicyV1beta1NamespacedPodDisruptionBudget",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchPolicyV1beta1NamespacedPodDisruptionBudgetParams
			Response = WatchPolicyV1beta1NamespacedPodDisruptionBudgetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchPolicyV1beta1NamespacedPodDisruptionBudgetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchPolicyV1beta1NamespacedPodDisruptionBudget(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchPolicyV1beta1NamespacedPodDisruptionBudget(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchPolicyV1beta1NamespacedPodDisruptionBudgetResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchPolicyV1beta1NamespacedPodDisruptionBudgetListRequest handles watchPolicyV1beta1NamespacedPodDisruptionBudgetList operation.
//
// Watch individual changes to a list of PodDisruptionBudget. deprecated: use the 'watch' parameter
// with a list operation instead.
//
// GET /apis/policy/v1beta1/watch/namespaces/{namespace}/poddisruptionbudgets
func (s *Server) handleWatchPolicyV1beta1NamespacedPodDisruptionBudgetListRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchPolicyV1beta1NamespacedPodDisruptionBudgetList"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/policy/v1beta1/watch/namespaces/{namespace}/poddisruptionbudgets"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchPolicyV1beta1NamespacedPodDisruptionBudgetList",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchPolicyV1beta1NamespacedPodDisruptionBudgetList",
			ID:   "watchPolicyV1beta1NamespacedPodDisruptionBudgetList",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchPolicyV1beta1NamespacedPodDisruptionBudgetList", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchPolicyV1beta1NamespacedPodDisruptionBudgetListParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchPolicyV1beta1NamespacedPodDisruptionBudgetListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchPolicyV1beta1NamespacedPodDisruptionBudgetList",
			OperationSummary: "",
			OperationID:      "watchPolicyV1beta1NamespacedPodDisruptionBudgetList",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchPolicyV1beta1NamespacedPodDisruptionBudgetListParams
			Response = WatchPolicyV1beta1NamespacedPodDisruptionBudgetListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchPolicyV1beta1NamespacedPodDisruptionBudgetListParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchPolicyV1beta1NamespacedPodDisruptionBudgetList(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchPolicyV1beta1NamespacedPodDisruptionBudgetList(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchPolicyV1beta1NamespacedPodDisruptionBudgetListResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchPolicyV1beta1PodDisruptionBudgetListForAllNamespacesRequest handles watchPolicyV1beta1PodDisruptionBudgetListForAllNamespaces operation.
//
// Watch individual changes to a list of PodDisruptionBudget. deprecated: use the 'watch' parameter
// with a list operation instead.
//
// GET /apis/policy/v1beta1/watch/poddisruptionbudgets
func (s *Server) handleWatchPolicyV1beta1PodDisruptionBudgetListForAllNamespacesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchPolicyV1beta1PodDisruptionBudgetListForAllNamespaces"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/policy/v1beta1/watch/poddisruptionbudgets"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchPolicyV1beta1PodDisruptionBudgetListForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchPolicyV1beta1PodDisruptionBudgetListForAllNamespaces",
			ID:   "watchPolicyV1beta1PodDisruptionBudgetListForAllNamespaces",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchPolicyV1beta1PodDisruptionBudgetListForAllNamespaces", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchPolicyV1beta1PodDisruptionBudgetListForAllNamespacesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchPolicyV1beta1PodDisruptionBudgetListForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchPolicyV1beta1PodDisruptionBudgetListForAllNamespaces",
			OperationSummary: "",
			OperationID:      "watchPolicyV1beta1PodDisruptionBudgetListForAllNamespaces",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchPolicyV1beta1PodDisruptionBudgetListForAllNamespacesParams
			Response = WatchPolicyV1beta1PodDisruptionBudgetListForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchPolicyV1beta1PodDisruptionBudgetListForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchPolicyV1beta1PodDisruptionBudgetListForAllNamespaces(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchPolicyV1beta1PodDisruptionBudgetListForAllNamespaces(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchPolicyV1beta1PodDisruptionBudgetListForAllNamespacesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchPolicyV1beta1PodSecurityPolicyRequest handles watchPolicyV1beta1PodSecurityPolicy operation.
//
// Watch changes to an object of kind PodSecurityPolicy. deprecated: use the 'watch' parameter with a
// list operation instead, filtered to a single item with the 'fieldSelector' parameter.
//
// GET /apis/policy/v1beta1/watch/podsecuritypolicies/{name}
func (s *Server) handleWatchPolicyV1beta1PodSecurityPolicyRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchPolicyV1beta1PodSecurityPolicy"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/policy/v1beta1/watch/podsecuritypolicies/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchPolicyV1beta1PodSecurityPolicy",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchPolicyV1beta1PodSecurityPolicy",
			ID:   "watchPolicyV1beta1PodSecurityPolicy",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchPolicyV1beta1PodSecurityPolicy", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchPolicyV1beta1PodSecurityPolicyParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchPolicyV1beta1PodSecurityPolicyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchPolicyV1beta1PodSecurityPolicy",
			OperationSummary: "",
			OperationID:      "watchPolicyV1beta1PodSecurityPolicy",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchPolicyV1beta1PodSecurityPolicyParams
			Response = WatchPolicyV1beta1PodSecurityPolicyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchPolicyV1beta1PodSecurityPolicyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchPolicyV1beta1PodSecurityPolicy(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchPolicyV1beta1PodSecurityPolicy(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchPolicyV1beta1PodSecurityPolicyResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchPolicyV1beta1PodSecurityPolicyListRequest handles watchPolicyV1beta1PodSecurityPolicyList operation.
//
// Watch individual changes to a list of PodSecurityPolicy. deprecated: use the 'watch' parameter
// with a list operation instead.
//
// GET /apis/policy/v1beta1/watch/podsecuritypolicies
func (s *Server) handleWatchPolicyV1beta1PodSecurityPolicyListRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchPolicyV1beta1PodSecurityPolicyList"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/policy/v1beta1/watch/podsecuritypolicies"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchPolicyV1beta1PodSecurityPolicyList",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchPolicyV1beta1PodSecurityPolicyList",
			ID:   "watchPolicyV1beta1PodSecurityPolicyList",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchPolicyV1beta1PodSecurityPolicyList", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchPolicyV1beta1PodSecurityPolicyListParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchPolicyV1beta1PodSecurityPolicyListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchPolicyV1beta1PodSecurityPolicyList",
			OperationSummary: "",
			OperationID:      "watchPolicyV1beta1PodSecurityPolicyList",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchPolicyV1beta1PodSecurityPolicyListParams
			Response = WatchPolicyV1beta1PodSecurityPolicyListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchPolicyV1beta1PodSecurityPolicyListParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchPolicyV1beta1PodSecurityPolicyList(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchPolicyV1beta1PodSecurityPolicyList(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchPolicyV1beta1PodSecurityPolicyListResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchRbacAuthorizationV1ClusterRoleRequest handles watchRbacAuthorizationV1ClusterRole operation.
//
// Watch changes to an object of kind ClusterRole. deprecated: use the 'watch' parameter with a list
// operation instead, filtered to a single item with the 'fieldSelector' parameter.
//
// GET /apis/rbac.authorization.k8s.io/v1/watch/clusterroles/{name}
func (s *Server) handleWatchRbacAuthorizationV1ClusterRoleRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchRbacAuthorizationV1ClusterRole"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/rbac.authorization.k8s.io/v1/watch/clusterroles/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchRbacAuthorizationV1ClusterRole",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchRbacAuthorizationV1ClusterRole",
			ID:   "watchRbacAuthorizationV1ClusterRole",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchRbacAuthorizationV1ClusterRole", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchRbacAuthorizationV1ClusterRoleParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchRbacAuthorizationV1ClusterRoleRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchRbacAuthorizationV1ClusterRole",
			OperationSummary: "",
			OperationID:      "watchRbacAuthorizationV1ClusterRole",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchRbacAuthorizationV1ClusterRoleParams
			Response = WatchRbacAuthorizationV1ClusterRoleRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchRbacAuthorizationV1ClusterRoleParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchRbacAuthorizationV1ClusterRole(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchRbacAuthorizationV1ClusterRole(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchRbacAuthorizationV1ClusterRoleResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchRbacAuthorizationV1ClusterRoleBindingRequest handles watchRbacAuthorizationV1ClusterRoleBinding operation.
//
// Watch changes to an object of kind ClusterRoleBinding. deprecated: use the 'watch' parameter with
// a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
//
// GET /apis/rbac.authorization.k8s.io/v1/watch/clusterrolebindings/{name}
func (s *Server) handleWatchRbacAuthorizationV1ClusterRoleBindingRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchRbacAuthorizationV1ClusterRoleBinding"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/rbac.authorization.k8s.io/v1/watch/clusterrolebindings/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchRbacAuthorizationV1ClusterRoleBinding",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchRbacAuthorizationV1ClusterRoleBinding",
			ID:   "watchRbacAuthorizationV1ClusterRoleBinding",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchRbacAuthorizationV1ClusterRoleBinding", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchRbacAuthorizationV1ClusterRoleBindingParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchRbacAuthorizationV1ClusterRoleBindingRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchRbacAuthorizationV1ClusterRoleBinding",
			OperationSummary: "",
			OperationID:      "watchRbacAuthorizationV1ClusterRoleBinding",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchRbacAuthorizationV1ClusterRoleBindingParams
			Response = WatchRbacAuthorizationV1ClusterRoleBindingRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchRbacAuthorizationV1ClusterRoleBindingParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchRbacAuthorizationV1ClusterRoleBinding(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchRbacAuthorizationV1ClusterRoleBinding(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchRbacAuthorizationV1ClusterRoleBindingResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchRbacAuthorizationV1ClusterRoleBindingListRequest handles watchRbacAuthorizationV1ClusterRoleBindingList operation.
//
// Watch individual changes to a list of ClusterRoleBinding. deprecated: use the 'watch' parameter
// with a list operation instead.
//
// GET /apis/rbac.authorization.k8s.io/v1/watch/clusterrolebindings
func (s *Server) handleWatchRbacAuthorizationV1ClusterRoleBindingListRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchRbacAuthorizationV1ClusterRoleBindingList"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/rbac.authorization.k8s.io/v1/watch/clusterrolebindings"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchRbacAuthorizationV1ClusterRoleBindingList",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchRbacAuthorizationV1ClusterRoleBindingList",
			ID:   "watchRbacAuthorizationV1ClusterRoleBindingList",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchRbacAuthorizationV1ClusterRoleBindingList", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchRbacAuthorizationV1ClusterRoleBindingListParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchRbacAuthorizationV1ClusterRoleBindingListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchRbacAuthorizationV1ClusterRoleBindingList",
			OperationSummary: "",
			OperationID:      "watchRbacAuthorizationV1ClusterRoleBindingList",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchRbacAuthorizationV1ClusterRoleBindingListParams
			Response = WatchRbacAuthorizationV1ClusterRoleBindingListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchRbacAuthorizationV1ClusterRoleBindingListParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchRbacAuthorizationV1ClusterRoleBindingList(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchRbacAuthorizationV1ClusterRoleBindingList(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchRbacAuthorizationV1ClusterRoleBindingListResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchRbacAuthorizationV1ClusterRoleListRequest handles watchRbacAuthorizationV1ClusterRoleList operation.
//
// Watch individual changes to a list of ClusterRole. deprecated: use the 'watch' parameter with a
// list operation instead.
//
// GET /apis/rbac.authorization.k8s.io/v1/watch/clusterroles
func (s *Server) handleWatchRbacAuthorizationV1ClusterRoleListRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchRbacAuthorizationV1ClusterRoleList"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/rbac.authorization.k8s.io/v1/watch/clusterroles"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchRbacAuthorizationV1ClusterRoleList",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchRbacAuthorizationV1ClusterRoleList",
			ID:   "watchRbacAuthorizationV1ClusterRoleList",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchRbacAuthorizationV1ClusterRoleList", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchRbacAuthorizationV1ClusterRoleListParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchRbacAuthorizationV1ClusterRoleListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchRbacAuthorizationV1ClusterRoleList",
			OperationSummary: "",
			OperationID:      "watchRbacAuthorizationV1ClusterRoleList",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchRbacAuthorizationV1ClusterRoleListParams
			Response = WatchRbacAuthorizationV1ClusterRoleListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchRbacAuthorizationV1ClusterRoleListParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchRbacAuthorizationV1ClusterRoleList(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchRbacAuthorizationV1ClusterRoleList(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchRbacAuthorizationV1ClusterRoleListResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchRbacAuthorizationV1NamespacedRoleRequest handles watchRbacAuthorizationV1NamespacedRole operation.
//
// Watch changes to an object of kind Role. deprecated: use the 'watch' parameter with a list
// operation instead, filtered to a single item with the 'fieldSelector' parameter.
//
// GET /apis/rbac.authorization.k8s.io/v1/watch/namespaces/{namespace}/roles/{name}
func (s *Server) handleWatchRbacAuthorizationV1NamespacedRoleRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchRbacAuthorizationV1NamespacedRole"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/rbac.authorization.k8s.io/v1/watch/namespaces/{namespace}/roles/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchRbacAuthorizationV1NamespacedRole",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchRbacAuthorizationV1NamespacedRole",
			ID:   "watchRbacAuthorizationV1NamespacedRole",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchRbacAuthorizationV1NamespacedRole", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchRbacAuthorizationV1NamespacedRoleParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchRbacAuthorizationV1NamespacedRoleRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchRbacAuthorizationV1NamespacedRole",
			OperationSummary: "",
			OperationID:      "watchRbacAuthorizationV1NamespacedRole",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchRbacAuthorizationV1NamespacedRoleParams
			Response = WatchRbacAuthorizationV1NamespacedRoleRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchRbacAuthorizationV1NamespacedRoleParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchRbacAuthorizationV1NamespacedRole(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchRbacAuthorizationV1NamespacedRole(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchRbacAuthorizationV1NamespacedRoleResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchRbacAuthorizationV1NamespacedRoleBindingRequest handles watchRbacAuthorizationV1NamespacedRoleBinding operation.
//
// Watch changes to an object of kind RoleBinding. deprecated: use the 'watch' parameter with a list
// operation instead, filtered to a single item with the 'fieldSelector' parameter.
//
// GET /apis/rbac.authorization.k8s.io/v1/watch/namespaces/{namespace}/rolebindings/{name}
func (s *Server) handleWatchRbacAuthorizationV1NamespacedRoleBindingRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchRbacAuthorizationV1NamespacedRoleBinding"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/rbac.authorization.k8s.io/v1/watch/namespaces/{namespace}/rolebindings/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchRbacAuthorizationV1NamespacedRoleBinding",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchRbacAuthorizationV1NamespacedRoleBinding",
			ID:   "watchRbacAuthorizationV1NamespacedRoleBinding",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchRbacAuthorizationV1NamespacedRoleBinding", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchRbacAuthorizationV1NamespacedRoleBindingParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchRbacAuthorizationV1NamespacedRoleBindingRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchRbacAuthorizationV1NamespacedRoleBinding",
			OperationSummary: "",
			OperationID:      "watchRbacAuthorizationV1NamespacedRoleBinding",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchRbacAuthorizationV1NamespacedRoleBindingParams
			Response = WatchRbacAuthorizationV1NamespacedRoleBindingRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchRbacAuthorizationV1NamespacedRoleBindingParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchRbacAuthorizationV1NamespacedRoleBinding(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchRbacAuthorizationV1NamespacedRoleBinding(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchRbacAuthorizationV1NamespacedRoleBindingResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchRbacAuthorizationV1NamespacedRoleBindingListRequest handles watchRbacAuthorizationV1NamespacedRoleBindingList operation.
//
// Watch individual changes to a list of RoleBinding. deprecated: use the 'watch' parameter with a
// list operation instead.
//
// GET /apis/rbac.authorization.k8s.io/v1/watch/namespaces/{namespace}/rolebindings
func (s *Server) handleWatchRbacAuthorizationV1NamespacedRoleBindingListRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchRbacAuthorizationV1NamespacedRoleBindingList"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/rbac.authorization.k8s.io/v1/watch/namespaces/{namespace}/rolebindings"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchRbacAuthorizationV1NamespacedRoleBindingList",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchRbacAuthorizationV1NamespacedRoleBindingList",
			ID:   "watchRbacAuthorizationV1NamespacedRoleBindingList",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchRbacAuthorizationV1NamespacedRoleBindingList", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchRbacAuthorizationV1NamespacedRoleBindingListParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchRbacAuthorizationV1NamespacedRoleBindingListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchRbacAuthorizationV1NamespacedRoleBindingList",
			OperationSummary: "",
			OperationID:      "watchRbacAuthorizationV1NamespacedRoleBindingList",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchRbacAuthorizationV1NamespacedRoleBindingListParams
			Response = WatchRbacAuthorizationV1NamespacedRoleBindingListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchRbacAuthorizationV1NamespacedRoleBindingListParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchRbacAuthorizationV1NamespacedRoleBindingList(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchRbacAuthorizationV1NamespacedRoleBindingList(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchRbacAuthorizationV1NamespacedRoleBindingListResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchRbacAuthorizationV1NamespacedRoleListRequest handles watchRbacAuthorizationV1NamespacedRoleList operation.
//
// Watch individual changes to a list of Role. deprecated: use the 'watch' parameter with a list
// operation instead.
//
// GET /apis/rbac.authorization.k8s.io/v1/watch/namespaces/{namespace}/roles
func (s *Server) handleWatchRbacAuthorizationV1NamespacedRoleListRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchRbacAuthorizationV1NamespacedRoleList"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/rbac.authorization.k8s.io/v1/watch/namespaces/{namespace}/roles"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchRbacAuthorizationV1NamespacedRoleList",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchRbacAuthorizationV1NamespacedRoleList",
			ID:   "watchRbacAuthorizationV1NamespacedRoleList",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchRbacAuthorizationV1NamespacedRoleList", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchRbacAuthorizationV1NamespacedRoleListParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchRbacAuthorizationV1NamespacedRoleListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchRbacAuthorizationV1NamespacedRoleList",
			OperationSummary: "",
			OperationID:      "watchRbacAuthorizationV1NamespacedRoleList",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchRbacAuthorizationV1NamespacedRoleListParams
			Response = WatchRbacAuthorizationV1NamespacedRoleListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchRbacAuthorizationV1NamespacedRoleListParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchRbacAuthorizationV1NamespacedRoleList(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchRbacAuthorizationV1NamespacedRoleList(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchRbacAuthorizationV1NamespacedRoleListResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchRbacAuthorizationV1RoleBindingListForAllNamespacesRequest handles watchRbacAuthorizationV1RoleBindingListForAllNamespaces operation.
//
// Watch individual changes to a list of RoleBinding. deprecated: use the 'watch' parameter with a
// list operation instead.
//
// GET /apis/rbac.authorization.k8s.io/v1/watch/rolebindings
func (s *Server) handleWatchRbacAuthorizationV1RoleBindingListForAllNamespacesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchRbacAuthorizationV1RoleBindingListForAllNamespaces"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/rbac.authorization.k8s.io/v1/watch/rolebindings"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchRbacAuthorizationV1RoleBindingListForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchRbacAuthorizationV1RoleBindingListForAllNamespaces",
			ID:   "watchRbacAuthorizationV1RoleBindingListForAllNamespaces",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchRbacAuthorizationV1RoleBindingListForAllNamespaces", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchRbacAuthorizationV1RoleBindingListForAllNamespacesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchRbacAuthorizationV1RoleBindingListForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchRbacAuthorizationV1RoleBindingListForAllNamespaces",
			OperationSummary: "",
			OperationID:      "watchRbacAuthorizationV1RoleBindingListForAllNamespaces",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchRbacAuthorizationV1RoleBindingListForAllNamespacesParams
			Response = WatchRbacAuthorizationV1RoleBindingListForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchRbacAuthorizationV1RoleBindingListForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchRbacAuthorizationV1RoleBindingListForAllNamespaces(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchRbacAuthorizationV1RoleBindingListForAllNamespaces(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchRbacAuthorizationV1RoleBindingListForAllNamespacesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchRbacAuthorizationV1RoleListForAllNamespacesRequest handles watchRbacAuthorizationV1RoleListForAllNamespaces operation.
//
// Watch individual changes to a list of Role. deprecated: use the 'watch' parameter with a list
// operation instead.
//
// GET /apis/rbac.authorization.k8s.io/v1/watch/roles
func (s *Server) handleWatchRbacAuthorizationV1RoleListForAllNamespacesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchRbacAuthorizationV1RoleListForAllNamespaces"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/rbac.authorization.k8s.io/v1/watch/roles"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchRbacAuthorizationV1RoleListForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchRbacAuthorizationV1RoleListForAllNamespaces",
			ID:   "watchRbacAuthorizationV1RoleListForAllNamespaces",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchRbacAuthorizationV1RoleListForAllNamespaces", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchRbacAuthorizationV1RoleListForAllNamespacesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchRbacAuthorizationV1RoleListForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchRbacAuthorizationV1RoleListForAllNamespaces",
			OperationSummary: "",
			OperationID:      "watchRbacAuthorizationV1RoleListForAllNamespaces",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchRbacAuthorizationV1RoleListForAllNamespacesParams
			Response = WatchRbacAuthorizationV1RoleListForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchRbacAuthorizationV1RoleListForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchRbacAuthorizationV1RoleListForAllNamespaces(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchRbacAuthorizationV1RoleListForAllNamespaces(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchRbacAuthorizationV1RoleListForAllNamespacesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchSchedulingV1PriorityClassRequest handles watchSchedulingV1PriorityClass operation.
//
// Watch changes to an object of kind PriorityClass. deprecated: use the 'watch' parameter with a
// list operation instead, filtered to a single item with the 'fieldSelector' parameter.
//
// GET /apis/scheduling.k8s.io/v1/watch/priorityclasses/{name}
func (s *Server) handleWatchSchedulingV1PriorityClassRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchSchedulingV1PriorityClass"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/scheduling.k8s.io/v1/watch/priorityclasses/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchSchedulingV1PriorityClass",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchSchedulingV1PriorityClass",
			ID:   "watchSchedulingV1PriorityClass",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchSchedulingV1PriorityClass", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchSchedulingV1PriorityClassParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchSchedulingV1PriorityClassRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchSchedulingV1PriorityClass",
			OperationSummary: "",
			OperationID:      "watchSchedulingV1PriorityClass",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchSchedulingV1PriorityClassParams
			Response = WatchSchedulingV1PriorityClassRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchSchedulingV1PriorityClassParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchSchedulingV1PriorityClass(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchSchedulingV1PriorityClass(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchSchedulingV1PriorityClassResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchSchedulingV1PriorityClassListRequest handles watchSchedulingV1PriorityClassList operation.
//
// Watch individual changes to a list of PriorityClass. deprecated: use the 'watch' parameter with a
// list operation instead.
//
// GET /apis/scheduling.k8s.io/v1/watch/priorityclasses
func (s *Server) handleWatchSchedulingV1PriorityClassListRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchSchedulingV1PriorityClassList"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/scheduling.k8s.io/v1/watch/priorityclasses"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchSchedulingV1PriorityClassList",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchSchedulingV1PriorityClassList",
			ID:   "watchSchedulingV1PriorityClassList",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchSchedulingV1PriorityClassList", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchSchedulingV1PriorityClassListParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchSchedulingV1PriorityClassListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchSchedulingV1PriorityClassList",
			OperationSummary: "",
			OperationID:      "watchSchedulingV1PriorityClassList",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchSchedulingV1PriorityClassListParams
			Response = WatchSchedulingV1PriorityClassListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchSchedulingV1PriorityClassListParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchSchedulingV1PriorityClassList(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchSchedulingV1PriorityClassList(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchSchedulingV1PriorityClassListResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchStorageV1CSIDriverRequest handles watchStorageV1CSIDriver operation.
//
// Watch changes to an object of kind CSIDriver. deprecated: use the 'watch' parameter with a list
// operation instead, filtered to a single item with the 'fieldSelector' parameter.
//
// GET /apis/storage.k8s.io/v1/watch/csidrivers/{name}
func (s *Server) handleWatchStorageV1CSIDriverRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchStorageV1CSIDriver"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/storage.k8s.io/v1/watch/csidrivers/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchStorageV1CSIDriver",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchStorageV1CSIDriver",
			ID:   "watchStorageV1CSIDriver",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchStorageV1CSIDriver", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchStorageV1CSIDriverParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchStorageV1CSIDriverRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchStorageV1CSIDriver",
			OperationSummary: "",
			OperationID:      "watchStorageV1CSIDriver",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchStorageV1CSIDriverParams
			Response = WatchStorageV1CSIDriverRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchStorageV1CSIDriverParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchStorageV1CSIDriver(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchStorageV1CSIDriver(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchStorageV1CSIDriverResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchStorageV1CSIDriverListRequest handles watchStorageV1CSIDriverList operation.
//
// Watch individual changes to a list of CSIDriver. deprecated: use the 'watch' parameter with a list
// operation instead.
//
// GET /apis/storage.k8s.io/v1/watch/csidrivers
func (s *Server) handleWatchStorageV1CSIDriverListRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchStorageV1CSIDriverList"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/storage.k8s.io/v1/watch/csidrivers"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchStorageV1CSIDriverList",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchStorageV1CSIDriverList",
			ID:   "watchStorageV1CSIDriverList",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchStorageV1CSIDriverList", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchStorageV1CSIDriverListParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchStorageV1CSIDriverListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchStorageV1CSIDriverList",
			OperationSummary: "",
			OperationID:      "watchStorageV1CSIDriverList",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchStorageV1CSIDriverListParams
			Response = WatchStorageV1CSIDriverListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchStorageV1CSIDriverListParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchStorageV1CSIDriverList(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchStorageV1CSIDriverList(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchStorageV1CSIDriverListResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchStorageV1CSINodeRequest handles watchStorageV1CSINode operation.
//
// Watch changes to an object of kind CSINode. deprecated: use the 'watch' parameter with a list
// operation instead, filtered to a single item with the 'fieldSelector' parameter.
//
// GET /apis/storage.k8s.io/v1/watch/csinodes/{name}
func (s *Server) handleWatchStorageV1CSINodeRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchStorageV1CSINode"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/storage.k8s.io/v1/watch/csinodes/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchStorageV1CSINode",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchStorageV1CSINode",
			ID:   "watchStorageV1CSINode",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchStorageV1CSINode", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchStorageV1CSINodeParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchStorageV1CSINodeRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchStorageV1CSINode",
			OperationSummary: "",
			OperationID:      "watchStorageV1CSINode",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchStorageV1CSINodeParams
			Response = WatchStorageV1CSINodeRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchStorageV1CSINodeParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchStorageV1CSINode(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchStorageV1CSINode(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchStorageV1CSINodeResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchStorageV1CSINodeListRequest handles watchStorageV1CSINodeList operation.
//
// Watch individual changes to a list of CSINode. deprecated: use the 'watch' parameter with a list
// operation instead.
//
// GET /apis/storage.k8s.io/v1/watch/csinodes
func (s *Server) handleWatchStorageV1CSINodeListRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchStorageV1CSINodeList"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/storage.k8s.io/v1/watch/csinodes"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchStorageV1CSINodeList",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchStorageV1CSINodeList",
			ID:   "watchStorageV1CSINodeList",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchStorageV1CSINodeList", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchStorageV1CSINodeListParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchStorageV1CSINodeListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchStorageV1CSINodeList",
			OperationSummary: "",
			OperationID:      "watchStorageV1CSINodeList",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchStorageV1CSINodeListParams
			Response = WatchStorageV1CSINodeListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchStorageV1CSINodeListParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchStorageV1CSINodeList(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchStorageV1CSINodeList(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchStorageV1CSINodeListResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchStorageV1StorageClassRequest handles watchStorageV1StorageClass operation.
//
// Watch changes to an object of kind StorageClass. deprecated: use the 'watch' parameter with a list
// operation instead, filtered to a single item with the 'fieldSelector' parameter.
//
// GET /apis/storage.k8s.io/v1/watch/storageclasses/{name}
func (s *Server) handleWatchStorageV1StorageClassRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchStorageV1StorageClass"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/storage.k8s.io/v1/watch/storageclasses/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchStorageV1StorageClass",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchStorageV1StorageClass",
			ID:   "watchStorageV1StorageClass",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchStorageV1StorageClass", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchStorageV1StorageClassParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchStorageV1StorageClassRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchStorageV1StorageClass",
			OperationSummary: "",
			OperationID:      "watchStorageV1StorageClass",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchStorageV1StorageClassParams
			Response = WatchStorageV1StorageClassRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchStorageV1StorageClassParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchStorageV1StorageClass(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchStorageV1StorageClass(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchStorageV1StorageClassResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchStorageV1StorageClassListRequest handles watchStorageV1StorageClassList operation.
//
// Watch individual changes to a list of StorageClass. deprecated: use the 'watch' parameter with a
// list operation instead.
//
// GET /apis/storage.k8s.io/v1/watch/storageclasses
func (s *Server) handleWatchStorageV1StorageClassListRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchStorageV1StorageClassList"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/storage.k8s.io/v1/watch/storageclasses"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchStorageV1StorageClassList",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchStorageV1StorageClassList",
			ID:   "watchStorageV1StorageClassList",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchStorageV1StorageClassList", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchStorageV1StorageClassListParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchStorageV1StorageClassListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchStorageV1StorageClassList",
			OperationSummary: "",
			OperationID:      "watchStorageV1StorageClassList",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchStorageV1StorageClassListParams
			Response = WatchStorageV1StorageClassListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchStorageV1StorageClassListParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchStorageV1StorageClassList(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchStorageV1StorageClassList(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchStorageV1StorageClassListResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchStorageV1VolumeAttachmentRequest handles watchStorageV1VolumeAttachment operation.
//
// Watch changes to an object of kind VolumeAttachment. deprecated: use the 'watch' parameter with a
// list operation instead, filtered to a single item with the 'fieldSelector' parameter.
//
// GET /apis/storage.k8s.io/v1/watch/volumeattachments/{name}
func (s *Server) handleWatchStorageV1VolumeAttachmentRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchStorageV1VolumeAttachment"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/storage.k8s.io/v1/watch/volumeattachments/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchStorageV1VolumeAttachment",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchStorageV1VolumeAttachment",
			ID:   "watchStorageV1VolumeAttachment",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchStorageV1VolumeAttachment", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchStorageV1VolumeAttachmentParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchStorageV1VolumeAttachmentRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchStorageV1VolumeAttachment",
			OperationSummary: "",
			OperationID:      "watchStorageV1VolumeAttachment",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchStorageV1VolumeAttachmentParams
			Response = WatchStorageV1VolumeAttachmentRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchStorageV1VolumeAttachmentParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchStorageV1VolumeAttachment(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchStorageV1VolumeAttachment(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchStorageV1VolumeAttachmentResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchStorageV1VolumeAttachmentListRequest handles watchStorageV1VolumeAttachmentList operation.
//
// Watch individual changes to a list of VolumeAttachment. deprecated: use the 'watch' parameter with
// a list operation instead.
//
// GET /apis/storage.k8s.io/v1/watch/volumeattachments
func (s *Server) handleWatchStorageV1VolumeAttachmentListRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchStorageV1VolumeAttachmentList"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/storage.k8s.io/v1/watch/volumeattachments"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchStorageV1VolumeAttachmentList",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchStorageV1VolumeAttachmentList",
			ID:   "watchStorageV1VolumeAttachmentList",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchStorageV1VolumeAttachmentList", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchStorageV1VolumeAttachmentListParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchStorageV1VolumeAttachmentListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchStorageV1VolumeAttachmentList",
			OperationSummary: "",
			OperationID:      "watchStorageV1VolumeAttachmentList",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchStorageV1VolumeAttachmentListParams
			Response = WatchStorageV1VolumeAttachmentListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchStorageV1VolumeAttachmentListParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchStorageV1VolumeAttachmentList(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchStorageV1VolumeAttachmentList(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchStorageV1VolumeAttachmentListResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchStorageV1alpha1CSIStorageCapacityListForAllNamespacesRequest handles watchStorageV1alpha1CSIStorageCapacityListForAllNamespaces operation.
//
// Watch individual changes to a list of CSIStorageCapacity. deprecated: use the 'watch' parameter
// with a list operation instead.
//
// GET /apis/storage.k8s.io/v1alpha1/watch/csistoragecapacities
func (s *Server) handleWatchStorageV1alpha1CSIStorageCapacityListForAllNamespacesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchStorageV1alpha1CSIStorageCapacityListForAllNamespaces"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/storage.k8s.io/v1alpha1/watch/csistoragecapacities"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchStorageV1alpha1CSIStorageCapacityListForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchStorageV1alpha1CSIStorageCapacityListForAllNamespaces",
			ID:   "watchStorageV1alpha1CSIStorageCapacityListForAllNamespaces",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchStorageV1alpha1CSIStorageCapacityListForAllNamespaces", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchStorageV1alpha1CSIStorageCapacityListForAllNamespacesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchStorageV1alpha1CSIStorageCapacityListForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchStorageV1alpha1CSIStorageCapacityListForAllNamespaces",
			OperationSummary: "",
			OperationID:      "watchStorageV1alpha1CSIStorageCapacityListForAllNamespaces",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchStorageV1alpha1CSIStorageCapacityListForAllNamespacesParams
			Response = WatchStorageV1alpha1CSIStorageCapacityListForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchStorageV1alpha1CSIStorageCapacityListForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchStorageV1alpha1CSIStorageCapacityListForAllNamespaces(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchStorageV1alpha1CSIStorageCapacityListForAllNamespaces(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchStorageV1alpha1CSIStorageCapacityListForAllNamespacesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchStorageV1alpha1NamespacedCSIStorageCapacityRequest handles watchStorageV1alpha1NamespacedCSIStorageCapacity operation.
//
// Watch changes to an object of kind CSIStorageCapacity. deprecated: use the 'watch' parameter with
// a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
//
// GET /apis/storage.k8s.io/v1alpha1/watch/namespaces/{namespace}/csistoragecapacities/{name}
func (s *Server) handleWatchStorageV1alpha1NamespacedCSIStorageCapacityRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchStorageV1alpha1NamespacedCSIStorageCapacity"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/storage.k8s.io/v1alpha1/watch/namespaces/{namespace}/csistoragecapacities/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchStorageV1alpha1NamespacedCSIStorageCapacity",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchStorageV1alpha1NamespacedCSIStorageCapacity",
			ID:   "watchStorageV1alpha1NamespacedCSIStorageCapacity",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchStorageV1alpha1NamespacedCSIStorageCapacity", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchStorageV1alpha1NamespacedCSIStorageCapacityParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchStorageV1alpha1NamespacedCSIStorageCapacityRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchStorageV1alpha1NamespacedCSIStorageCapacity",
			OperationSummary: "",
			OperationID:      "watchStorageV1alpha1NamespacedCSIStorageCapacity",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchStorageV1alpha1NamespacedCSIStorageCapacityParams
			Response = WatchStorageV1alpha1NamespacedCSIStorageCapacityRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchStorageV1alpha1NamespacedCSIStorageCapacityParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchStorageV1alpha1NamespacedCSIStorageCapacity(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchStorageV1alpha1NamespacedCSIStorageCapacity(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchStorageV1alpha1NamespacedCSIStorageCapacityResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchStorageV1alpha1NamespacedCSIStorageCapacityListRequest handles watchStorageV1alpha1NamespacedCSIStorageCapacityList operation.
//
// Watch individual changes to a list of CSIStorageCapacity. deprecated: use the 'watch' parameter
// with a list operation instead.
//
// GET /apis/storage.k8s.io/v1alpha1/watch/namespaces/{namespace}/csistoragecapacities
func (s *Server) handleWatchStorageV1alpha1NamespacedCSIStorageCapacityListRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchStorageV1alpha1NamespacedCSIStorageCapacityList"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/storage.k8s.io/v1alpha1/watch/namespaces/{namespace}/csistoragecapacities"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchStorageV1alpha1NamespacedCSIStorageCapacityList",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchStorageV1alpha1NamespacedCSIStorageCapacityList",
			ID:   "watchStorageV1alpha1NamespacedCSIStorageCapacityList",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchStorageV1alpha1NamespacedCSIStorageCapacityList", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchStorageV1alpha1NamespacedCSIStorageCapacityListParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchStorageV1alpha1NamespacedCSIStorageCapacityListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchStorageV1alpha1NamespacedCSIStorageCapacityList",
			OperationSummary: "",
			OperationID:      "watchStorageV1alpha1NamespacedCSIStorageCapacityList",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchStorageV1alpha1NamespacedCSIStorageCapacityListParams
			Response = WatchStorageV1alpha1NamespacedCSIStorageCapacityListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchStorageV1alpha1NamespacedCSIStorageCapacityListParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchStorageV1alpha1NamespacedCSIStorageCapacityList(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchStorageV1alpha1NamespacedCSIStorageCapacityList(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchStorageV1alpha1NamespacedCSIStorageCapacityListResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchStorageV1beta1CSIStorageCapacityListForAllNamespacesRequest handles watchStorageV1beta1CSIStorageCapacityListForAllNamespaces operation.
//
// Watch individual changes to a list of CSIStorageCapacity. deprecated: use the 'watch' parameter
// with a list operation instead.
//
// GET /apis/storage.k8s.io/v1beta1/watch/csistoragecapacities
func (s *Server) handleWatchStorageV1beta1CSIStorageCapacityListForAllNamespacesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchStorageV1beta1CSIStorageCapacityListForAllNamespaces"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/storage.k8s.io/v1beta1/watch/csistoragecapacities"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchStorageV1beta1CSIStorageCapacityListForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchStorageV1beta1CSIStorageCapacityListForAllNamespaces",
			ID:   "watchStorageV1beta1CSIStorageCapacityListForAllNamespaces",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchStorageV1beta1CSIStorageCapacityListForAllNamespaces", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchStorageV1beta1CSIStorageCapacityListForAllNamespacesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchStorageV1beta1CSIStorageCapacityListForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchStorageV1beta1CSIStorageCapacityListForAllNamespaces",
			OperationSummary: "",
			OperationID:      "watchStorageV1beta1CSIStorageCapacityListForAllNamespaces",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchStorageV1beta1CSIStorageCapacityListForAllNamespacesParams
			Response = WatchStorageV1beta1CSIStorageCapacityListForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchStorageV1beta1CSIStorageCapacityListForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchStorageV1beta1CSIStorageCapacityListForAllNamespaces(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchStorageV1beta1CSIStorageCapacityListForAllNamespaces(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchStorageV1beta1CSIStorageCapacityListForAllNamespacesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchStorageV1beta1NamespacedCSIStorageCapacityRequest handles watchStorageV1beta1NamespacedCSIStorageCapacity operation.
//
// Watch changes to an object of kind CSIStorageCapacity. deprecated: use the 'watch' parameter with
// a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
//
// GET /apis/storage.k8s.io/v1beta1/watch/namespaces/{namespace}/csistoragecapacities/{name}
func (s *Server) handleWatchStorageV1beta1NamespacedCSIStorageCapacityRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchStorageV1beta1NamespacedCSIStorageCapacity"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/storage.k8s.io/v1beta1/watch/namespaces/{namespace}/csistoragecapacities/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchStorageV1beta1NamespacedCSIStorageCapacity",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchStorageV1beta1NamespacedCSIStorageCapacity",
			ID:   "watchStorageV1beta1NamespacedCSIStorageCapacity",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchStorageV1beta1NamespacedCSIStorageCapacity", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchStorageV1beta1NamespacedCSIStorageCapacityParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchStorageV1beta1NamespacedCSIStorageCapacityRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchStorageV1beta1NamespacedCSIStorageCapacity",
			OperationSummary: "",
			OperationID:      "watchStorageV1beta1NamespacedCSIStorageCapacity",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "name",
					In:   "path",
				}: params.Name,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchStorageV1beta1NamespacedCSIStorageCapacityParams
			Response = WatchStorageV1beta1NamespacedCSIStorageCapacityRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchStorageV1beta1NamespacedCSIStorageCapacityParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchStorageV1beta1NamespacedCSIStorageCapacity(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchStorageV1beta1NamespacedCSIStorageCapacity(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchStorageV1beta1NamespacedCSIStorageCapacityResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWatchStorageV1beta1NamespacedCSIStorageCapacityListRequest handles watchStorageV1beta1NamespacedCSIStorageCapacityList operation.
//
// Watch individual changes to a list of CSIStorageCapacity. deprecated: use the 'watch' parameter
// with a list operation instead.
//
// GET /apis/storage.k8s.io/v1beta1/watch/namespaces/{namespace}/csistoragecapacities
func (s *Server) handleWatchStorageV1beta1NamespacedCSIStorageCapacityListRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchStorageV1beta1NamespacedCSIStorageCapacityList"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apis/storage.k8s.io/v1beta1/watch/namespaces/{namespace}/csistoragecapacities"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchStorageV1beta1NamespacedCSIStorageCapacityList",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchStorageV1beta1NamespacedCSIStorageCapacityList",
			ID:   "watchStorageV1beta1NamespacedCSIStorageCapacityList",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityBearerToken(ctx, "WatchStorageV1beta1NamespacedCSIStorageCapacityList", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "BearerToken",
					Err:              err,
				}
				defer recordError("Security:BearerToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeWatchStorageV1beta1NamespacedCSIStorageCapacityListParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchStorageV1beta1NamespacedCSIStorageCapacityListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WatchStorageV1beta1NamespacedCSIStorageCapacityList",
			OperationSummary: "",
			OperationID:      "watchStorageV1beta1NamespacedCSIStorageCapacityList",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "allowWatchBookmarks",
					In:   "query",
				}: params.AllowWatchBookmarks,
				{
					Name: "continue",
					In:   "query",
				}: params.Continue,
				{
					Name: "fieldSelector",
					In:   "query",
				}: params.FieldSelector,
				{
					Name: "labelSelector",
					In:   "query",
				}: params.LabelSelector,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "namespace",
					In:   "path",
				}: params.Namespace,
				{
					Name: "pretty",
					In:   "query",
				}: params.Pretty,
				{
					Name: "resourceVersion",
					In:   "query",
				}: params.ResourceVersion,
				{
					Name: "resourceVersionMatch",
					In:   "query",
				}: params.ResourceVersionMatch,
				{
					Name: "timeoutSeconds",
					In:   "query",
				}: params.TimeoutSeconds,
				{
					Name: "watch",
					In:   "query",
				}: params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchStorageV1beta1NamespacedCSIStorageCapacityListParams
			Response = WatchStorageV1beta1NamespacedCSIStorageCapacityListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchStorageV1beta1NamespacedCSIStorageCapacityListParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WatchStorageV1beta1NamespacedCSIStorageCapacityList(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WatchStorageV1beta1NamespacedCSIStorageCapacityList(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchStorageV1beta1NamespacedCSIStorageCapacityListResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}
